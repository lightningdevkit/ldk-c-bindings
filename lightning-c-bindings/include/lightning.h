/* Text to put at the beginning of the generated file. Probably a license. */

/* Generated with cbindgen:0.16.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>


/**
 * An error when accessing the chain via [`Access`].
 *
 * [`Access`]: trait.Access.html
 */
typedef enum LDKAccessError {
   /**
    * The requested chain is unknown.
    */
   LDKAccessError_UnknownChain,
   /**
    * The requested transaction doesn't exist or hasn't confirmed.
    */
   LDKAccessError_UnknownTx,
   /**
    * Must be last for serialization purposes
    */
   LDKAccessError_Sentinel,
} LDKAccessError;

/**
 * An error enum representing a failure to persist a channel monitor update.
 */
typedef enum LDKChannelMonitorUpdateErr {
   /**
    * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
    * our state failed, but is expected to succeed at some point in the future).
    *
    * Such a failure will \"freeze\" a channel, preventing us from revoking old states or
    * submitting new commitment transactions to the counterparty. Once the update(s) which failed
    * have been successfully applied, ChannelManager::channel_monitor_updated can be used to
    * restore the channel to an operational state.
    *
    * Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If
    * you return a TemporaryFailure you must ensure that it is written to disk safely before
    * writing out the latest ChannelManager state.
    *
    * Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur
    * (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
    * to claim it on this channel) and those updates must be applied wherever they can be. At
    * least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
    * be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
    * the channel which would invalidate previous ChannelMonitors are not made when a channel has
    * been \"frozen\".
    *
    * Note that even if updates made after TemporaryFailure succeed you must still call
    * channel_monitor_updated to ensure you have the latest monitor and re-enable normal channel
    * operation.
    *
    * Note that the update being processed here will not be replayed for you when you call
    * ChannelManager::channel_monitor_updated, so you must store the update itself along
    * with the persisted ChannelMonitor on your own local disk prior to returning a
    * TemporaryFailure. You may, of course, employ a journaling approach, storing only the
    * ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at
    * reload-time.
    *
    * For deployments where a copy of ChannelMonitors and other local state are backed up in a
    * remote location (with local copies persisted immediately), it is anticipated that all
    * updates will return TemporaryFailure until the remote copies could be updated.
    */
   LDKChannelMonitorUpdateErr_TemporaryFailure,
   /**
    * Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
    * different watchtower and cannot update with all watchtowers that were previously informed
    * of this channel).
    *
    * At reception of this error, ChannelManager will force-close the channel and return at
    * least a final ChannelMonitorUpdate::ChannelForceClosed which must be delivered to at
    * least one ChannelMonitor copy. Revocation secret MUST NOT be released and offchain channel
    * update must be rejected.
    *
    * This failure may also signal a failure to update the local persisted copy of one of
    * the channel monitor instance.
    *
    * Note that even when you fail a holder commitment transaction update, you must store the
    * update to ensure you can claim from it in case of a duplicate copy of this ChannelMonitor
    * broadcasts it (e.g distributed channel-monitor deployment)
    *
    * In case of distributed watchtowers deployment, the new version must be written to disk, as
    * state may have been stored but rejected due to a block forcing a commitment broadcast. This
    * storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
    * lagging behind on block processing.
    */
   LDKChannelMonitorUpdateErr_PermanentFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKChannelMonitorUpdateErr_Sentinel,
} LDKChannelMonitorUpdateErr;

/**
 * An enum that represents the speed at which we want a transaction to confirm used for feerate
 * estimation.
 */
typedef enum LDKConfirmationTarget {
   /**
    * We are happy with this transaction confirming slowly when feerate drops some.
    */
   LDKConfirmationTarget_Background,
   /**
    * We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
    */
   LDKConfirmationTarget_Normal,
   /**
    * We'd like this transaction to confirm in the next few blocks.
    */
   LDKConfirmationTarget_HighPriority,
   /**
    * Must be last for serialization purposes
    */
   LDKConfirmationTarget_Sentinel,
} LDKConfirmationTarget;

/**
 * An enum representing the available verbosity levels of the logger.
 */
typedef enum LDKLevel {
   /**
    *Designates logger being silent
    */
   LDKLevel_Off,
   /**
    * Designates very serious errors
    */
   LDKLevel_Error,
   /**
    * Designates hazardous situations
    */
   LDKLevel_Warn,
   /**
    * Designates useful information
    */
   LDKLevel_Info,
   /**
    * Designates lower priority information
    */
   LDKLevel_Debug,
   /**
    * Designates very low priority, often extremely verbose, information
    */
   LDKLevel_Trace,
   /**
    * Must be last for serialization purposes
    */
   LDKLevel_Sentinel,
} LDKLevel;

typedef enum LDKNetwork {
   LDKNetwork_Bitcoin,
   LDKNetwork_Testnet,
   LDKNetwork_Regtest,
   LDKNetwork_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKNetwork_Sentinel,
} LDKNetwork;

typedef enum LDKSecp256k1Error {
   LDKSecp256k1Error_IncorrectSignature,
   LDKSecp256k1Error_InvalidMessage,
   LDKSecp256k1Error_InvalidPublicKey,
   LDKSecp256k1Error_InvalidSignature,
   LDKSecp256k1Error_InvalidSecretKey,
   LDKSecp256k1Error_InvalidRecoveryId,
   LDKSecp256k1Error_InvalidTweak,
   LDKSecp256k1Error_TweakCheckFailed,
   LDKSecp256k1Error_NotEnoughMemory,
   /**
    * Must be last for serialization purposes
    */
   LDKSecp256k1Error_Sentinel,
} LDKSecp256k1Error;

/**
 * A serialized transaction, in (pointer, length) form.
 *
 * This type optionally owns its own memory, and thus the semantics around access change based on
 * the `data_is_owned` flag. If `data_is_owned` is set, you must call `Transaction_free` to free
 * the underlying buffer before the object goes out of scope. If `data_is_owned` is not set, any
 * access to the buffer after the scope in which the object was provided to you is invalid. eg,
 * access after you return from the call in which a `!data_is_owned` `Transaction` is provided to
 * you would be invalid.
 *
 * Note that, while it may change in the future, because transactions on the Rust side are stored
 * in a deserialized form, all `Transaction`s generated on the Rust side will have `data_is_owned`
 * set. Similarly, while it may change in the future, all `Transaction`s you pass to Rust may have
 * `data_is_owned` either set or unset at your discretion.
 */
typedef struct LDKTransaction {
   /**
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   uintptr_t datalen;
   bool data_is_owned;
} LDKTransaction;

typedef struct LDKCVec_u8Z {
   uint8_t *data;
   uintptr_t datalen;
} LDKCVec_u8Z;

/**
 * A transaction output including a scriptPubKey and value.
 * This type *does* own its own memory, so must be free'd appropriately.
 */
typedef struct LDKTxOut {
   struct LDKCVec_u8Z script_pubkey;
   uint64_t value;
} LDKTxOut;

typedef struct LDKSecretKey {
   uint8_t bytes[32];
} LDKSecretKey;

typedef union LDKCResult_SecretKeyErrorZPtr {
   struct LDKSecretKey *result;
   enum LDKSecp256k1Error *err;
} LDKCResult_SecretKeyErrorZPtr;

typedef struct LDKCResult_SecretKeyErrorZ {
   union LDKCResult_SecretKeyErrorZPtr contents;
   bool result_ok;
} LDKCResult_SecretKeyErrorZ;

typedef struct LDKPublicKey {
   uint8_t compressed_form[33];
} LDKPublicKey;

typedef union LDKCResult_PublicKeyErrorZPtr {
   struct LDKPublicKey *result;
   enum LDKSecp256k1Error *err;
} LDKCResult_PublicKeyErrorZPtr;

typedef struct LDKCResult_PublicKeyErrorZ {
   union LDKCResult_PublicKeyErrorZPtr contents;
   bool result_ok;
} LDKCResult_PublicKeyErrorZ;



/**
 * The set of public keys which are used in the creation of one commitment transaction.
 * These are derived from the channel base keys and per-commitment data.
 *
 * A broadcaster key is provided from potential broadcaster of the computed transaction.
 * A countersignatory key is coming from a protocol participant unable to broadcast the
 * transaction.
 *
 * These keys are assumed to be good, either because the code derived them from
 * channel basepoints via the new function, or they were obtained via
 * CommitmentTransaction.trust().keys() because we trusted the source of the
 * pre-calculated keys.
 */
typedef struct MUST_USE_STRUCT LDKTxCreationKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxCreationKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxCreationKeys;



/**
 * An error in decoding a message or struct.
 */
typedef struct MUST_USE_STRUCT LDKDecodeError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDecodeError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDecodeError;

typedef union LDKCResult_TxCreationKeysDecodeErrorZPtr {
   struct LDKTxCreationKeys *result;
   struct LDKDecodeError *err;
} LDKCResult_TxCreationKeysDecodeErrorZPtr;

typedef struct LDKCResult_TxCreationKeysDecodeErrorZ {
   union LDKCResult_TxCreationKeysDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_TxCreationKeysDecodeErrorZ;



/**
 * One counterparty's public keys which do not change over the life of a channel.
 */
typedef struct MUST_USE_STRUCT LDKChannelPublicKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelPublicKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelPublicKeys;

typedef union LDKCResult_ChannelPublicKeysDecodeErrorZPtr {
   struct LDKChannelPublicKeys *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelPublicKeysDecodeErrorZPtr;

typedef struct LDKCResult_ChannelPublicKeysDecodeErrorZ {
   union LDKCResult_ChannelPublicKeysDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelPublicKeysDecodeErrorZ;

typedef union LDKCResult_TxCreationKeysErrorZPtr {
   struct LDKTxCreationKeys *result;
   enum LDKSecp256k1Error *err;
} LDKCResult_TxCreationKeysErrorZPtr;

typedef struct LDKCResult_TxCreationKeysErrorZ {
   union LDKCResult_TxCreationKeysErrorZPtr contents;
   bool result_ok;
} LDKCResult_TxCreationKeysErrorZ;



/**
 * Information about an HTLC as it appears in a commitment transaction
 */
typedef struct MUST_USE_STRUCT LDKHTLCOutputInCommitment {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCOutputInCommitment *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCOutputInCommitment;

typedef union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr {
   struct LDKHTLCOutputInCommitment *result;
   struct LDKDecodeError *err;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr;

typedef struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ {
   union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZ;



/**
 * Late-bound per-channel counterparty data used to build transactions.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyChannelTransactionParameters;

typedef union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
   struct LDKCounterpartyChannelTransactionParameters *result;
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr;

typedef struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
   union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ;



/**
 * Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
 * The fields are organized by holder/counterparty.
 *
 * Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
 * before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTransactionParameters;

typedef union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr {
   struct LDKChannelTransactionParameters *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelTransactionParametersDecodeErrorZPtr;

typedef struct LDKCResult_ChannelTransactionParametersDecodeErrorZ {
   union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelTransactionParametersDecodeErrorZ;

typedef struct LDKSignature {
   uint8_t compact_form[64];
} LDKSignature;

typedef struct LDKCVec_SignatureZ {
   struct LDKSignature *data;
   uintptr_t datalen;
} LDKCVec_SignatureZ;



/**
 * Information needed to build and sign a holder's commitment transaction.
 *
 * The transaction is only signed once we are ready to broadcast.
 */
typedef struct MUST_USE_STRUCT LDKHolderCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHolderCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHolderCommitmentTransaction;

typedef union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr {
   struct LDKHolderCommitmentTransaction *result;
   struct LDKDecodeError *err;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr;

typedef struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ {
   union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZ;



/**
 * A pre-built Bitcoin commitment transaction and its txid.
 */
typedef struct MUST_USE_STRUCT LDKBuiltCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBuiltCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBuiltCommitmentTransaction;

typedef union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr {
   struct LDKBuiltCommitmentTransaction *result;
   struct LDKDecodeError *err;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr;

typedef struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ {
   union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZ;



/**
 * This class tracks the per-transaction information needed to build a commitment transaction and to
 * actually build it and sign.  It is used for holder transactions that we sign only when needed
 * and for transactions we sign for the counterparty.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentTransaction;

typedef union LDKCResult_CommitmentTransactionDecodeErrorZPtr {
   struct LDKCommitmentTransaction *result;
   struct LDKDecodeError *err;
} LDKCResult_CommitmentTransactionDecodeErrorZPtr;

typedef struct LDKCResult_CommitmentTransactionDecodeErrorZ {
   union LDKCResult_CommitmentTransactionDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_CommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
 * transaction and the transaction creation keys) are trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedCommitmentTransaction;

typedef union LDKCResult_TrustedCommitmentTransactionNoneZPtr {
   struct LDKTrustedCommitmentTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedCommitmentTransactionNoneZPtr;

typedef struct LDKCResult_TrustedCommitmentTransactionNoneZ {
   union LDKCResult_TrustedCommitmentTransactionNoneZPtr contents;
   bool result_ok;
} LDKCResult_TrustedCommitmentTransactionNoneZ;

typedef union LDKCResult_CVec_SignatureZNoneZPtr {
   struct LDKCVec_SignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_SignatureZNoneZPtr;

typedef struct LDKCResult_CVec_SignatureZNoneZ {
   union LDKCResult_CVec_SignatureZNoneZPtr contents;
   bool result_ok;
} LDKCResult_CVec_SignatureZNoneZ;



/**
 * An accept_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAcceptChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAcceptChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAcceptChannel;



/**
 * An open_channel message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKOpenChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOpenChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOpenChannel;



/**
 * A funding_created message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingCreated {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingCreated *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingCreated;



/**
 * A funding_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingSigned;



/**
 * A funding_locked message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKFundingLocked {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingLocked *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingLocked;



/**
 * An announcement_signatures message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKAnnouncementSignatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAnnouncementSignatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAnnouncementSignatures;



/**
 * Struct used to return values from revoke_and_ack messages, containing a bunch of commitment
 * transaction updates if they were pending.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentUpdate;



/**
 * A revoke_and_ack message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKRevokeAndACK {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRevokeAndACK *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRevokeAndACK;



/**
 * A closing_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKClosingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSigned;



/**
 * A shutdown message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKShutdown {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdown *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdown;



/**
 * A channel_reestablish message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelReestablish {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReestablish *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReestablish;



/**
 * A channel_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelAnnouncement;



/**
 * A channel_update message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdate;



/**
 * A node_announcement message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncement;



/**
 * An error message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKErrorMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErrorMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErrorMessage;

/**
 * Used to put an error message in a LightningError
 */
typedef enum LDKErrorAction_Tag {
   /**
    * The peer took some action which made us think they were useless. Disconnect them.
    */
   LDKErrorAction_DisconnectPeer,
   /**
    * The peer did something harmless that we weren't able to process, just log and ignore
    */
   LDKErrorAction_IgnoreError,
   /**
    * The peer did something incorrect. Tell them.
    */
   LDKErrorAction_SendErrorMessage,
   /**
    * Must be last for serialization purposes
    */
   LDKErrorAction_Sentinel,
} LDKErrorAction_Tag;

typedef struct LDKErrorAction_LDKDisconnectPeer_Body {
   /**
    * An error message which we should make an effort to send before we disconnect.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKDisconnectPeer_Body;

typedef struct LDKErrorAction_LDKSendErrorMessage_Body {
   /**
    * The message to send.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKSendErrorMessage_Body;

typedef struct MUST_USE_STRUCT LDKErrorAction {
   LDKErrorAction_Tag tag;
   union {
      LDKErrorAction_LDKDisconnectPeer_Body disconnect_peer;
      LDKErrorAction_LDKSendErrorMessage_Body send_error_message;
   };
} LDKErrorAction;

/**
 * The information we received from a peer along the route of a payment we originated. This is
 * returned by ChannelMessageHandler::handle_update_fail_htlc to be passed into
 * RoutingMessageHandler::handle_htlc_fail_channel_update to update our network map.
 */
typedef enum LDKHTLCFailChannelUpdate_Tag {
   /**
    * We received an error which included a full ChannelUpdate message.
    */
   LDKHTLCFailChannelUpdate_ChannelUpdateMessage,
   /**
    * We received an error which indicated only that a channel has been closed
    */
   LDKHTLCFailChannelUpdate_ChannelClosed,
   /**
    * We received an error which indicated only that a node has failed
    */
   LDKHTLCFailChannelUpdate_NodeFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKHTLCFailChannelUpdate_Sentinel,
} LDKHTLCFailChannelUpdate_Tag;

typedef struct LDKHTLCFailChannelUpdate_LDKChannelUpdateMessage_Body {
   /**
    * The unwrapped message we received
    */
   struct LDKChannelUpdate msg;
} LDKHTLCFailChannelUpdate_LDKChannelUpdateMessage_Body;

typedef struct LDKHTLCFailChannelUpdate_LDKChannelClosed_Body {
   /**
    * The short_channel_id which has now closed.
    */
   uint64_t short_channel_id;
   /**
    * when this true, this channel should be permanently removed from the
    * consideration. Otherwise, this channel can be restored as new channel_update is received
    */
   bool is_permanent;
} LDKHTLCFailChannelUpdate_LDKChannelClosed_Body;

typedef struct LDKHTLCFailChannelUpdate_LDKNodeFailure_Body {
   /**
    * The node_id that has failed.
    */
   struct LDKPublicKey node_id;
   /**
    * when this true, node should be permanently removed from the
    * consideration. Otherwise, the channels connected to this node can be
    * restored as new channel_update is received
    */
   bool is_permanent;
} LDKHTLCFailChannelUpdate_LDKNodeFailure_Body;

typedef struct MUST_USE_STRUCT LDKHTLCFailChannelUpdate {
   LDKHTLCFailChannelUpdate_Tag tag;
   union {
      LDKHTLCFailChannelUpdate_LDKChannelUpdateMessage_Body channel_update_message;
      LDKHTLCFailChannelUpdate_LDKChannelClosed_Body channel_closed;
      LDKHTLCFailChannelUpdate_LDKNodeFailure_Body node_failure;
   };
} LDKHTLCFailChannelUpdate;



/**
 * A query_channel_range message is used to query a peer for channel
 * UTXOs in a range of blocks. The recipient of a query makes a best
 * effort to reply to the query using one or more reply_channel_range
 * messages.
 */
typedef struct MUST_USE_STRUCT LDKQueryChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryChannelRange;



/**
 * A query_short_channel_ids message is used to query a peer for
 * routing gossip messages related to one or more short_channel_ids.
 * The query recipient will reply with the latest, if available,
 * channel_announcement, channel_update and node_announcement messages
 * it maintains for the requested short_channel_ids followed by a
 * reply_short_channel_ids_end message. The short_channel_ids sent in
 * this query are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKQueryShortChannelIds {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryShortChannelIds *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryShortChannelIds;

/**
 * An event generated by ChannelManager which indicates a message should be sent to a peer (or
 * broadcast to most peers).
 * These events are handled by PeerManager::process_events if you are using a PeerManager.
 */
typedef enum LDKMessageSendEvent_Tag {
   /**
    * Used to indicate that we've accepted a channel open and should send the accept_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendAcceptChannel,
   /**
    * Used to indicate that we've initiated a channel open and should send the open_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendOpenChannel,
   /**
    * Used to indicate that a funding_created message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingCreated,
   /**
    * Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingSigned,
   /**
    * Used to indicate that a funding_locked message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingLocked,
   /**
    * Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendAnnouncementSignatures,
   /**
    * Used to indicate that a series of HTLC update messages, as well as a commitment_signed
    * message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_UpdateHTLCs,
   /**
    * Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendRevokeAndACK,
   /**
    * Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendClosingSigned,
   /**
    * Used to indicate that a shutdown message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendShutdown,
   /**
    * Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReestablish,
   /**
    * Used to indicate that a channel_announcement and channel_update should be broadcast to all
    * peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
    *
    * Note that after doing so, you very likely (unless you did so very recently) want to call
    * ChannelManager::broadcast_node_announcement to trigger a BroadcastNodeAnnouncement event.
    * This ensures that any nodes which see our channel_announcement also have a relevant
    * node_announcement, including relevant feature flags which may be important for routing
    * through or to us.
    */
   LDKMessageSendEvent_BroadcastChannelAnnouncement,
   /**
    * Used to indicate that a node_announcement should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastNodeAnnouncement,
   /**
    * Used to indicate that a channel_update should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastChannelUpdate,
   /**
    * Broadcast an error downstream to be handled
    */
   LDKMessageSendEvent_HandleError,
   /**
    * When a payment fails we may receive updates back from the hop where it failed. In such
    * cases this event is generated so that we can inform the network graph of this information.
    */
   LDKMessageSendEvent_PaymentFailureNetworkUpdate,
   /**
    * Query a peer for channels with funding transaction UTXOs in a block range.
    */
   LDKMessageSendEvent_SendChannelRangeQuery,
   /**
    * Request routing gossip messages from a peer for a list of channels identified by
    * their short_channel_ids.
    */
   LDKMessageSendEvent_SendShortIdsQuery,
   /**
    * Must be last for serialization purposes
    */
   LDKMessageSendEvent_Sentinel,
} LDKMessageSendEvent_Tag;

typedef struct LDKMessageSendEvent_LDKSendAcceptChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKAcceptChannel msg;
} LDKMessageSendEvent_LDKSendAcceptChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendOpenChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKOpenChannel msg;
} LDKMessageSendEvent_LDKSendOpenChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingCreated_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingCreated msg;
} LDKMessageSendEvent_LDKSendFundingCreated_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingSigned msg;
} LDKMessageSendEvent_LDKSendFundingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingLocked_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The funding_locked message which should be sent.
    */
   struct LDKFundingLocked msg;
} LDKMessageSendEvent_LDKSendFundingLocked_Body;

typedef struct LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The announcement_signatures message which should be sent.
    */
   struct LDKAnnouncementSignatures msg;
} LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body;

typedef struct LDKMessageSendEvent_LDKUpdateHTLCs_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The update messages which should be sent. ALL messages in the struct should be sent!
    */
   struct LDKCommitmentUpdate updates;
} LDKMessageSendEvent_LDKUpdateHTLCs_Body;

typedef struct LDKMessageSendEvent_LDKSendRevokeAndACK_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKRevokeAndACK msg;
} LDKMessageSendEvent_LDKSendRevokeAndACK_Body;

typedef struct LDKMessageSendEvent_LDKSendClosingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKClosingSigned msg;
} LDKMessageSendEvent_LDKSendClosingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendShutdown_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKShutdown msg;
} LDKMessageSendEvent_LDKSendShutdown_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReestablish_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKChannelReestablish msg;
} LDKMessageSendEvent_LDKSendChannelReestablish_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body {
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body {
   /**
    * The node_announcement which should be sent.
    */
   struct LDKNodeAnnouncement msg;
} LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body {
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKHandleError_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The action which should be taken.
    */
   struct LDKErrorAction action;
} LDKMessageSendEvent_LDKHandleError_Body;

typedef struct LDKMessageSendEvent_LDKPaymentFailureNetworkUpdate_Body {
   /**
    * The channel/node update which should be sent to NetGraphMsgHandler
    */
   struct LDKHTLCFailChannelUpdate update;
} LDKMessageSendEvent_LDKPaymentFailureNetworkUpdate_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelRangeQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_channel_range which should be sent.
    */
   struct LDKQueryChannelRange msg;
} LDKMessageSendEvent_LDKSendChannelRangeQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendShortIdsQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_short_channel_ids which should be sent.
    */
   struct LDKQueryShortChannelIds msg;
} LDKMessageSendEvent_LDKSendShortIdsQuery_Body;

typedef struct MUST_USE_STRUCT LDKMessageSendEvent {
   LDKMessageSendEvent_Tag tag;
   union {
      LDKMessageSendEvent_LDKSendAcceptChannel_Body send_accept_channel;
      LDKMessageSendEvent_LDKSendOpenChannel_Body send_open_channel;
      LDKMessageSendEvent_LDKSendFundingCreated_Body send_funding_created;
      LDKMessageSendEvent_LDKSendFundingSigned_Body send_funding_signed;
      LDKMessageSendEvent_LDKSendFundingLocked_Body send_funding_locked;
      LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body send_announcement_signatures;
      LDKMessageSendEvent_LDKUpdateHTLCs_Body update_htl_cs;
      LDKMessageSendEvent_LDKSendRevokeAndACK_Body send_revoke_and_ack;
      LDKMessageSendEvent_LDKSendClosingSigned_Body send_closing_signed;
      LDKMessageSendEvent_LDKSendShutdown_Body send_shutdown;
      LDKMessageSendEvent_LDKSendChannelReestablish_Body send_channel_reestablish;
      LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body broadcast_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body broadcast_node_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body broadcast_channel_update;
      LDKMessageSendEvent_LDKHandleError_Body handle_error;
      LDKMessageSendEvent_LDKPaymentFailureNetworkUpdate_Body payment_failure_network_update;
      LDKMessageSendEvent_LDKSendChannelRangeQuery_Body send_channel_range_query;
      LDKMessageSendEvent_LDKSendShortIdsQuery_Body send_short_ids_query;
   };
} LDKMessageSendEvent;

typedef struct LDKCVec_MessageSendEventZ {
   struct LDKMessageSendEvent *data;
   uintptr_t datalen;
} LDKCVec_MessageSendEventZ;



/**
 * An Err type for failure to process messages.
 */
typedef struct MUST_USE_STRUCT LDKLightningError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLightningError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLightningError;

typedef union LDKCResult_boolLightningErrorZPtr {
   bool *result;
   struct LDKLightningError *err;
} LDKCResult_boolLightningErrorZPtr;

typedef struct LDKCResult_boolLightningErrorZ {
   union LDKCResult_boolLightningErrorZPtr contents;
   bool result_ok;
} LDKCResult_boolLightningErrorZ;

typedef struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
   struct LDKChannelAnnouncement a;
   struct LDKChannelUpdate b;
   struct LDKChannelUpdate c;
} LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ;

typedef struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
   struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *data;
   uintptr_t datalen;
} LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ;

typedef struct LDKCVec_NodeAnnouncementZ {
   struct LDKNodeAnnouncement *data;
   uintptr_t datalen;
} LDKCVec_NodeAnnouncementZ;

typedef union LDKCResult_NoneLightningErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   struct LDKLightningError *err;
} LDKCResult_NoneLightningErrorZPtr;

typedef struct LDKCResult_NoneLightningErrorZ {
   union LDKCResult_NoneLightningErrorZPtr contents;
   bool result_ok;
} LDKCResult_NoneLightningErrorZ;

typedef struct LDKCVec_PublicKeyZ {
   struct LDKPublicKey *data;
   uintptr_t datalen;
} LDKCVec_PublicKeyZ;



/**
 * Error for PeerManager errors. If you get one of these, you must disconnect the socket and
 * generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
 * descriptor.
 */
typedef struct MUST_USE_STRUCT LDKPeerHandleError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerHandleError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerHandleError;

typedef union LDKCResult_CVec_u8ZPeerHandleErrorZPtr {
   struct LDKCVec_u8Z *result;
   struct LDKPeerHandleError *err;
} LDKCResult_CVec_u8ZPeerHandleErrorZPtr;

typedef struct LDKCResult_CVec_u8ZPeerHandleErrorZ {
   union LDKCResult_CVec_u8ZPeerHandleErrorZPtr contents;
   bool result_ok;
} LDKCResult_CVec_u8ZPeerHandleErrorZ;

typedef union LDKCResult_NonePeerHandleErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   struct LDKPeerHandleError *err;
} LDKCResult_NonePeerHandleErrorZPtr;

typedef struct LDKCResult_NonePeerHandleErrorZ {
   union LDKCResult_NonePeerHandleErrorZPtr contents;
   bool result_ok;
} LDKCResult_NonePeerHandleErrorZ;

typedef union LDKCResult_boolPeerHandleErrorZPtr {
   bool *result;
   struct LDKPeerHandleError *err;
} LDKCResult_boolPeerHandleErrorZPtr;

typedef struct LDKCResult_boolPeerHandleErrorZ {
   union LDKCResult_boolPeerHandleErrorZPtr contents;
   bool result_ok;
} LDKCResult_boolPeerHandleErrorZ;



/**
 * Features used within an `init` message.
 */
typedef struct MUST_USE_STRUCT LDKInitFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInitFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInitFeatures;

typedef union LDKCResult_InitFeaturesDecodeErrorZPtr {
   struct LDKInitFeatures *result;
   struct LDKDecodeError *err;
} LDKCResult_InitFeaturesDecodeErrorZPtr;

typedef struct LDKCResult_InitFeaturesDecodeErrorZ {
   union LDKCResult_InitFeaturesDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_InitFeaturesDecodeErrorZ;



/**
 * Features used within a `node_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKNodeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeFeatures;

typedef union LDKCResult_NodeFeaturesDecodeErrorZPtr {
   struct LDKNodeFeatures *result;
   struct LDKDecodeError *err;
} LDKCResult_NodeFeaturesDecodeErrorZPtr;

typedef struct LDKCResult_NodeFeaturesDecodeErrorZ {
   union LDKCResult_NodeFeaturesDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_NodeFeaturesDecodeErrorZ;



/**
 * Features used within a `channel_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKChannelFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelFeatures;

typedef union LDKCResult_ChannelFeaturesDecodeErrorZPtr {
   struct LDKChannelFeatures *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelFeaturesDecodeErrorZPtr;

typedef struct LDKCResult_ChannelFeaturesDecodeErrorZ {
   union LDKCResult_ChannelFeaturesDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelFeaturesDecodeErrorZ;



/**
 * Features used within an invoice.
 */
typedef struct MUST_USE_STRUCT LDKInvoiceFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceFeatures;

typedef union LDKCResult_InvoiceFeaturesDecodeErrorZPtr {
   struct LDKInvoiceFeatures *result;
   struct LDKDecodeError *err;
} LDKCResult_InvoiceFeaturesDecodeErrorZPtr;

typedef struct LDKCResult_InvoiceFeaturesDecodeErrorZ {
   union LDKCResult_InvoiceFeaturesDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_InvoiceFeaturesDecodeErrorZ;



/**
 * Options which apply on a per-channel basis and may change at runtime or based on negotiation
 * with our counterparty.
 */
typedef struct MUST_USE_STRUCT LDKChannelConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelConfig;

typedef union LDKCResult_ChannelConfigDecodeErrorZPtr {
   struct LDKChannelConfig *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelConfigDecodeErrorZPtr;

typedef struct LDKCResult_ChannelConfigDecodeErrorZ {
   union LDKCResult_ChannelConfigDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelConfigDecodeErrorZ;



/**
 * Details about one direction of a channel. Received
 * within a channel update.
 */
typedef struct MUST_USE_STRUCT LDKDirectionalChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectionalChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectionalChannelInfo;

typedef union LDKCResult_DirectionalChannelInfoDecodeErrorZPtr {
   struct LDKDirectionalChannelInfo *result;
   struct LDKDecodeError *err;
} LDKCResult_DirectionalChannelInfoDecodeErrorZPtr;

typedef struct LDKCResult_DirectionalChannelInfoDecodeErrorZ {
   union LDKCResult_DirectionalChannelInfoDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_DirectionalChannelInfoDecodeErrorZ;



/**
 * Details about a channel (both directions).
 * Received within a channel announcement.
 */
typedef struct MUST_USE_STRUCT LDKChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelInfo;

typedef union LDKCResult_ChannelInfoDecodeErrorZPtr {
   struct LDKChannelInfo *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelInfoDecodeErrorZPtr;

typedef struct LDKCResult_ChannelInfoDecodeErrorZ {
   union LDKCResult_ChannelInfoDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelInfoDecodeErrorZ;



/**
 * Fees for routing via a given channel or a node
 */
typedef struct MUST_USE_STRUCT LDKRoutingFees {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoutingFees *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoutingFees;

typedef union LDKCResult_RoutingFeesDecodeErrorZPtr {
   struct LDKRoutingFees *result;
   struct LDKDecodeError *err;
} LDKCResult_RoutingFeesDecodeErrorZPtr;

typedef struct LDKCResult_RoutingFeesDecodeErrorZ {
   union LDKCResult_RoutingFeesDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_RoutingFeesDecodeErrorZ;

typedef struct LDKFourBytes {
   uint8_t data[4];
} LDKFourBytes;

typedef struct LDKSixteenBytes {
   uint8_t data[16];
} LDKSixteenBytes;

typedef struct LDKTenBytes {
   uint8_t data[10];
} LDKTenBytes;

/**
 * Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
 * look up the corresponding function in rust-lightning's docs.
 */
typedef struct LDKThirtyTwoBytes {
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * An address which can be used to connect to a remote peer
 */
typedef enum LDKNetAddress_Tag {
   /**
    * An IPv4 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv4,
   /**
    * An IPv6 address/port on which the peer is listening.
    */
   LDKNetAddress_IPv6,
   /**
    * An old-style Tor onion address/port on which the peer is listening.
    */
   LDKNetAddress_OnionV2,
   /**
    * A new-style Tor onion address/port on which the peer is listening.
    * To create the human-readable \"hostname\", concatenate ed25519_pubkey, checksum, and version,
    * wrap as base32 and append \".onion\".
    */
   LDKNetAddress_OnionV3,
   /**
    * Must be last for serialization purposes
    */
   LDKNetAddress_Sentinel,
} LDKNetAddress_Tag;

typedef struct LDKNetAddress_LDKIPv4_Body {
   /**
    * The 4-byte IPv4 address
    */
   struct LDKFourBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv4_Body;

typedef struct LDKNetAddress_LDKIPv6_Body {
   /**
    * The 16-byte IPv6 address
    */
   struct LDKSixteenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKIPv6_Body;

typedef struct LDKNetAddress_LDKOnionV2_Body {
   /**
    * The bytes (usually encoded in base32 with \".onion\" appended)
    */
   struct LDKTenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKOnionV2_Body;

typedef struct LDKNetAddress_LDKOnionV3_Body {
   /**
    * The ed25519 long-term public key of the peer
    */
   struct LDKThirtyTwoBytes ed25519_pubkey;
   /**
    * The checksum of the pubkey and version, as included in the onion address
    */
   uint16_t checksum;
   /**
    * The version byte, as defined by the Tor Onion v3 spec.
    */
   uint8_t version;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKNetAddress_LDKOnionV3_Body;

typedef struct MUST_USE_STRUCT LDKNetAddress {
   LDKNetAddress_Tag tag;
   union {
      LDKNetAddress_LDKIPv4_Body i_pv4;
      LDKNetAddress_LDKIPv6_Body i_pv6;
      LDKNetAddress_LDKOnionV2_Body onion_v2;
      LDKNetAddress_LDKOnionV3_Body onion_v3;
   };
} LDKNetAddress;

typedef struct LDKCVec_NetAddressZ {
   struct LDKNetAddress *data;
   uintptr_t datalen;
} LDKCVec_NetAddressZ;



/**
 * Information received in the latest node_announcement from this node.
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncementInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncementInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncementInfo;

typedef union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr {
   struct LDKNodeAnnouncementInfo *result;
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr;

typedef struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ {
   union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZ;

typedef struct LDKCVec_u64Z {
   uint64_t *data;
   uintptr_t datalen;
} LDKCVec_u64Z;



/**
 * Details about a node in the network, known from the network announcement.
 */
typedef struct MUST_USE_STRUCT LDKNodeInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeInfo;

typedef union LDKCResult_NodeInfoDecodeErrorZPtr {
   struct LDKNodeInfo *result;
   struct LDKDecodeError *err;
} LDKCResult_NodeInfoDecodeErrorZPtr;

typedef struct LDKCResult_NodeInfoDecodeErrorZ {
   union LDKCResult_NodeInfoDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_NodeInfoDecodeErrorZ;



/**
 * Represents the network as nodes and channels between them
 */
typedef struct MUST_USE_STRUCT LDKNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetworkGraph;

typedef union LDKCResult_NetworkGraphDecodeErrorZPtr {
   struct LDKNetworkGraph *result;
   struct LDKDecodeError *err;
} LDKCResult_NetworkGraphDecodeErrorZPtr;

typedef struct LDKCResult_NetworkGraphDecodeErrorZ {
   union LDKCResult_NetworkGraphDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_NetworkGraphDecodeErrorZ;

typedef struct LDKC2Tuple_usizeTransactionZ {
   uintptr_t a;
   struct LDKTransaction b;
} LDKC2Tuple_usizeTransactionZ;

typedef struct LDKCVec_C2Tuple_usizeTransactionZZ {
   struct LDKC2Tuple_usizeTransactionZ *data;
   uintptr_t datalen;
} LDKCVec_C2Tuple_usizeTransactionZZ;

typedef union LDKCResult_NoneChannelMonitorUpdateErrZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   enum LDKChannelMonitorUpdateErr *err;
} LDKCResult_NoneChannelMonitorUpdateErrZPtr;

typedef struct LDKCResult_NoneChannelMonitorUpdateErrZ {
   union LDKCResult_NoneChannelMonitorUpdateErrZPtr contents;
   bool result_ok;
} LDKCResult_NoneChannelMonitorUpdateErrZ;



/**
 * Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
 * chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
 * preimage claim backward will lead to loss of funds.
 *
 * [`chain::Watch`]: ../trait.Watch.html
 */
typedef struct MUST_USE_STRUCT LDKHTLCUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCUpdate;



/**
 * A reference to a transaction output.
 *
 * Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
 * due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
 */
typedef struct MUST_USE_STRUCT LDKOutPoint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOutPoint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOutPoint;

/**
 * An event to be processed by the ChannelManager.
 */
typedef enum LDKMonitorEvent_Tag {
   /**
    * A monitor event containing an HTLCUpdate.
    */
   LDKMonitorEvent_HTLCEvent,
   /**
    * A monitor event that the Channel's commitment transaction was broadcasted.
    */
   LDKMonitorEvent_CommitmentTxBroadcasted,
   /**
    * Must be last for serialization purposes
    */
   LDKMonitorEvent_Sentinel,
} LDKMonitorEvent_Tag;

typedef struct MUST_USE_STRUCT LDKMonitorEvent {
   LDKMonitorEvent_Tag tag;
   union {
      struct {
         struct LDKHTLCUpdate htlc_event;
      };
      struct {
         struct LDKOutPoint commitment_tx_broadcasted;
      };
   };
} LDKMonitorEvent;

typedef struct LDKCVec_MonitorEventZ {
   struct LDKMonitorEvent *data;
   uintptr_t datalen;
} LDKCVec_MonitorEventZ;



/**
 * Information about a spendable output to a P2WSH script. See
 * SpendableOutputDescriptor::DelayedPaymentOutput for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKDelayedPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDelayedPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDelayedPaymentOutputDescriptor;



/**
 * Information about a spendable output to our \"payment key\". See
 * SpendableOutputDescriptor::StaticPaymentOutput for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKStaticPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeStaticPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKStaticPaymentOutputDescriptor;

/**
 * When on-chain outputs are created by rust-lightning (which our counterparty is not able to
 * claim at any point in the future) an event is generated which you must track and be able to
 * spend on-chain. The information needed to do this is provided in this enum, including the
 * outpoint describing which txid and output index is available, the full output which exists at
 * that txid/index, and any keys or other information required to sign.
 */
typedef enum LDKSpendableOutputDescriptor_Tag {
   /**
    * An output to a script which was provided via KeysInterface directly, either from
    * `get_destination_script()` or `get_shutdown_pubkey()`, thus you should already know how to
    * spend it. No secret keys are provided as rust-lightning was never given any key.
    * These may include outputs from a transaction punishing our counterparty or claiming an HTLC
    * on-chain using the payment preimage or after it has timed out.
    */
   LDKSpendableOutputDescriptor_StaticOutput,
   /**
    * An output to a P2WSH script which can be spent with a single signature after a CSV delay.
    *
    * The witness in the spending input should be:
    * <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
    *
    * Note that the nSequence field in the spending input must be set to to_self_delay
    * (which means the transaction is not broadcastable until at least to_self_delay
    * blocks after the outpoint confirms).
    *
    * These are generally the result of a \"revocable\" output to us, spendable only by us unless
    * it is an output from an old state which we broadcast (which should never happen).
    *
    * To derive the delayed_payment key which is used to sign for this input, you must pass the
    * holder delayed_payment_base_key (ie the private key which corresponds to the pubkey in
    * Sign::pubkeys().delayed_payment_basepoint) and the provided per_commitment_point to
    * chan_utils::derive_private_key. The public key can be generated without the secret key
    * using chan_utils::derive_public_key and only the delayed_payment_basepoint which appears in
    * Sign::pubkeys().
    *
    * To derive the revocation_pubkey provided here (which is used in the witness
    * script generation), you must pass the counterparty revocation_basepoint (which appears in the
    * call to Sign::ready_channel) and the provided per_commitment point
    * to chan_utils::derive_public_revocation_key.
    *
    * The witness script which is hashed and included in the output script_pubkey may be
    * regenerated by passing the revocation_pubkey (derived as above), our delayed_payment pubkey
    * (derived as above), and the to_self_delay contained here to
    * chan_utils::get_revokeable_redeemscript.
    */
   LDKSpendableOutputDescriptor_DelayedPaymentOutput,
   /**
    * An output to a P2WPKH, spendable exclusively by our payment key (ie the private key which
    * corresponds to the public key in Sign::pubkeys().payment_point).
    * The witness in the spending input, is, thus, simply:
    * <BIP 143 signature> <payment key>
    *
    * These are generally the result of our counterparty having broadcast the current state,
    * allowing us to claim the non-HTLC-encumbered outputs immediately.
    */
   LDKSpendableOutputDescriptor_StaticPaymentOutput,
   /**
    * Must be last for serialization purposes
    */
   LDKSpendableOutputDescriptor_Sentinel,
} LDKSpendableOutputDescriptor_Tag;

typedef struct LDKSpendableOutputDescriptor_LDKStaticOutput_Body {
   /**
    * The outpoint which is spendable
    */
   struct LDKOutPoint outpoint;
   /**
    * The output which is referenced by the given outpoint.
    */
   struct LDKTxOut output;
} LDKSpendableOutputDescriptor_LDKStaticOutput_Body;

typedef struct MUST_USE_STRUCT LDKSpendableOutputDescriptor {
   LDKSpendableOutputDescriptor_Tag tag;
   union {
      LDKSpendableOutputDescriptor_LDKStaticOutput_Body static_output;
      struct {
         struct LDKDelayedPaymentOutputDescriptor delayed_payment_output;
      };
      struct {
         struct LDKStaticPaymentOutputDescriptor static_payment_output;
      };
   };
} LDKSpendableOutputDescriptor;

typedef struct LDKCVec_SpendableOutputDescriptorZ {
   struct LDKSpendableOutputDescriptor *data;
   uintptr_t datalen;
} LDKCVec_SpendableOutputDescriptorZ;

/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */
typedef enum LDKEvent_Tag {
   /**
    * Used to indicate that the client should generate a funding transaction with the given
    * parameters and then call ChannelManager::funding_transaction_generated.
    * Generated in ChannelManager message handling.
    * Note that *all inputs* in the funding transaction must spend SegWit outputs or your
    * counterparty can steal your funds!
    */
   LDKEvent_FundingGenerationReady,
   /**
    * Used to indicate that the client may now broadcast the funding transaction it created for a
    * channel. Broadcasting such a transaction prior to this event may lead to our counterparty
    * trivially stealing all funds in the funding transaction!
    */
   LDKEvent_FundingBroadcastSafe,
   /**
    * Indicates we've received money! Just gotta dig out that payment preimage and feed it to
    * ChannelManager::claim_funds to get it....
    * Note that if the preimage is not known or the amount paid is incorrect, you should call
    * ChannelManager::fail_htlc_backwards to free up resources for this HTLC and avoid
    * network congestion.
    * The amount paid should be considered 'incorrect' when it is less than or more than twice
    * the amount expected.
    * If you fail to call either ChannelManager::claim_funds or
    * ChannelManager::fail_htlc_backwards within the HTLC's timeout, the HTLC will be
    * automatically failed.
    */
   LDKEvent_PaymentReceived,
   /**
    * Indicates an outbound payment we made succeeded (ie it made it all the way to its target
    * and we got back the payment preimage for it).
    * Note that duplicative PaymentSent Events may be generated - it is your responsibility to
    * deduplicate them by payment_preimage (which MUST be unique)!
    */
   LDKEvent_PaymentSent,
   /**
    * Indicates an outbound payment we made failed. Probably some intermediary node dropped
    * something. You may wish to retry with a different route.
    * Note that duplicative PaymentFailed Events may be generated - it is your responsibility to
    * deduplicate them by payment_hash (which MUST be unique)!
    */
   LDKEvent_PaymentFailed,
   /**
    * Used to indicate that ChannelManager::process_pending_htlc_forwards should be called at a
    * time in the future.
    */
   LDKEvent_PendingHTLCsForwardable,
   /**
    * Used to indicate that an output was generated on-chain which you should know how to spend.
    * Such an output will *not* ever be spent by rust-lightning, and are not at risk of your
    * counterparty spending them due to some kind of timeout. Thus, you need to store them
    * somewhere and spend them when you create on-chain transactions.
    */
   LDKEvent_SpendableOutputs,
   /**
    * Must be last for serialization purposes
    */
   LDKEvent_Sentinel,
} LDKEvent_Tag;

typedef struct LDKEvent_LDKFundingGenerationReady_Body {
   /**
    * The random channel_id we picked which you'll need to pass into
    * ChannelManager::funding_transaction_generated.
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The value, in satoshis, that the output should have.
    */
   uint64_t channel_value_satoshis;
   /**
    * The script which should be used in the transaction output.
    */
   struct LDKCVec_u8Z output_script;
   /**
    * The value passed in to ChannelManager::create_channel
    */
   uint64_t user_channel_id;
} LDKEvent_LDKFundingGenerationReady_Body;

typedef struct LDKEvent_LDKFundingBroadcastSafe_Body {
   /**
    * The output, which was passed to ChannelManager::funding_transaction_generated, which is
    * now safe to broadcast.
    */
   struct LDKOutPoint funding_txo;
   /**
    * The value passed in to ChannelManager::create_channel
    */
   uint64_t user_channel_id;
} LDKEvent_LDKFundingBroadcastSafe_Body;

typedef struct LDKEvent_LDKPaymentReceived_Body {
   /**
    * The hash for which the preimage should be handed to the ChannelManager.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The \"payment secret\". This authenticates the sender to the recipient, preventing a
    * number of deanonymization attacks during the routing process.
    * As nodes upgrade, the invoices you provide should likely migrate to setting the
    * payment_secret feature to required, at which point you should fail_backwards any HTLCs
    * which have a None here.
    * Until then, however, values of None should be ignored, and only incorrect Some values
    * should result in an HTLC fail_backwards.
    * Note that, in any case, this value must be passed as-is to any fail or claim calls as
    * the HTLC index includes this value.
    */
   struct LDKThirtyTwoBytes payment_secret;
   /**
    * The value, in thousandths of a satoshi, that this payment is for. Note that you must
    * compare this to the expected value before accepting the payment (as otherwise you are
    * providing proof-of-payment for less than the value you expected!).
    */
   uint64_t amt;
} LDKEvent_LDKPaymentReceived_Body;

typedef struct LDKEvent_LDKPaymentSent_Body {
   /**
    * The preimage to the hash given to ChannelManager::send_payment.
    * Note that this serves as a payment receipt, if you wish to have such a thing, you must
    * store it somehow!
    */
   struct LDKThirtyTwoBytes payment_preimage;
} LDKEvent_LDKPaymentSent_Body;

typedef struct LDKEvent_LDKPaymentFailed_Body {
   /**
    * The hash which was given to ChannelManager::send_payment.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * Indicates the payment was rejected for some reason by the recipient. This implies that
    * the payment has failed, not just the route in question. If this is not set, you may
    * retry the payment via a different route.
    */
   bool rejected_by_dest;
} LDKEvent_LDKPaymentFailed_Body;

typedef struct LDKEvent_LDKPendingHTLCsForwardable_Body {
   /**
    * The minimum amount of time that should be waited prior to calling
    * process_pending_htlc_forwards. To increase the effort required to correlate payments,
    * you should wait a random amount of time in roughly the range (now + time_forwardable,
    * now + 5*time_forwardable).
    */
   uint64_t time_forwardable;
} LDKEvent_LDKPendingHTLCsForwardable_Body;

typedef struct LDKEvent_LDKSpendableOutputs_Body {
   /**
    * The outputs which you should store as spendable by you.
    */
   struct LDKCVec_SpendableOutputDescriptorZ outputs;
} LDKEvent_LDKSpendableOutputs_Body;

typedef struct MUST_USE_STRUCT LDKEvent {
   LDKEvent_Tag tag;
   union {
      LDKEvent_LDKFundingGenerationReady_Body funding_generation_ready;
      LDKEvent_LDKFundingBroadcastSafe_Body funding_broadcast_safe;
      LDKEvent_LDKPaymentReceived_Body payment_received;
      LDKEvent_LDKPaymentSent_Body payment_sent;
      LDKEvent_LDKPaymentFailed_Body payment_failed;
      LDKEvent_LDKPendingHTLCsForwardable_Body pending_htl_cs_forwardable;
      LDKEvent_LDKSpendableOutputs_Body spendable_outputs;
   };
} LDKEvent;

typedef struct LDKCVec_EventZ {
   struct LDKEvent *data;
   uintptr_t datalen;
} LDKCVec_EventZ;

typedef union LDKCResult_OutPointDecodeErrorZPtr {
   struct LDKOutPoint *result;
   struct LDKDecodeError *err;
} LDKCResult_OutPointDecodeErrorZPtr;

typedef struct LDKCResult_OutPointDecodeErrorZ {
   union LDKCResult_OutPointDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_OutPointDecodeErrorZ;



/**
 * An update generated by the underlying Channel itself which contains some new information the
 * ChannelMonitor should be made aware of.
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitorUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitorUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitorUpdate;

typedef union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr {
   struct LDKChannelMonitorUpdate *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr;

typedef struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ {
   union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZ;

typedef union LDKCResult_HTLCUpdateDecodeErrorZPtr {
   struct LDKHTLCUpdate *result;
   struct LDKDecodeError *err;
} LDKCResult_HTLCUpdateDecodeErrorZPtr;

typedef struct LDKCResult_HTLCUpdateDecodeErrorZ {
   union LDKCResult_HTLCUpdateDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_HTLCUpdateDecodeErrorZ;



/**
 * General Err type for ChannelMonitor actions. Generally, this implies that the data provided is
 * inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this
 * means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was
 * corrupted.
 * Contains a developer-readable error message.
 */
typedef struct MUST_USE_STRUCT LDKMonitorUpdateError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMonitorUpdateError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMonitorUpdateError;

typedef union LDKCResult_NoneMonitorUpdateErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   struct LDKMonitorUpdateError *err;
} LDKCResult_NoneMonitorUpdateErrorZPtr;

typedef struct LDKCResult_NoneMonitorUpdateErrorZ {
   union LDKCResult_NoneMonitorUpdateErrorZPtr contents;
   bool result_ok;
} LDKCResult_NoneMonitorUpdateErrorZ;

typedef struct LDKC2Tuple_OutPointScriptZ {
   struct LDKOutPoint a;
   struct LDKCVec_u8Z b;
} LDKC2Tuple_OutPointScriptZ;

typedef struct LDKC2Tuple_u32ScriptZ {
   uint32_t a;
   struct LDKCVec_u8Z b;
} LDKC2Tuple_u32ScriptZ;

typedef struct LDKCVec_C2Tuple_u32ScriptZZ {
   struct LDKC2Tuple_u32ScriptZ *data;
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32ScriptZZ;

typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ {
   struct LDKThirtyTwoBytes a;
   struct LDKCVec_C2Tuple_u32ScriptZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ;

typedef struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ {
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *data;
   uintptr_t datalen;
} LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ;

typedef struct LDKCVec_TransactionZ {
   struct LDKTransaction *data;
   uintptr_t datalen;
} LDKCVec_TransactionZ;

typedef struct LDKC2Tuple_u32TxOutZ {
   uint32_t a;
   struct LDKTxOut b;
} LDKC2Tuple_u32TxOutZ;

typedef struct LDKCVec_C2Tuple_u32TxOutZZ {
   struct LDKC2Tuple_u32TxOutZ *data;
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32TxOutZZ;

typedef struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ {
   struct LDKThirtyTwoBytes a;
   struct LDKCVec_C2Tuple_u32TxOutZZ b;
} LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ;

typedef struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ {
   struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *data;
   uintptr_t datalen;
} LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ;

typedef struct LDKC2Tuple_SignatureCVec_SignatureZZ {
   struct LDKSignature a;
   struct LDKCVec_SignatureZ b;
} LDKC2Tuple_SignatureCVec_SignatureZZ;

typedef union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr {
   struct LDKC2Tuple_SignatureCVec_SignatureZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr;

typedef struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ {
   union LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZPtr contents;
   bool result_ok;
} LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ;

typedef union LDKCResult_SignatureNoneZPtr {
   struct LDKSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SignatureNoneZPtr;

typedef struct LDKCResult_SignatureNoneZ {
   union LDKCResult_SignatureNoneZPtr contents;
   bool result_ok;
} LDKCResult_SignatureNoneZ;



/**
 * The unsigned part of a channel_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelAnnouncement;

/**
 * A trait to sign lightning channel transactions as described in BOLT 3.
 *
 * Signing services could be implemented on a hardware wallet. In this case,
 * the current Sign would be a front-end on top of a communication
 * channel connected to your secure device and lightning key material wouldn't
 * reside on a hot server. Nevertheless, a this deployment would still need
 * to trust the ChannelManager to avoid loss of funds as this latest component
 * could ask to sign commitment transaction with HTLCs paying to attacker pubkeys.
 *
 * A more secure iteration would be to use hashlock (or payment points) to pair
 * invoice/incoming HTLCs with outgoing HTLCs to implement a no-trust-ChannelManager
 * at the price of more state and computation on the hardware wallet side. In the future,
 * we are looking forward to design such interface.
 *
 * In any case, ChannelMonitor or fallback watchtowers are always going to be trusted
 * to act, as liveness and breach reply correctness are always going to be hard requirements
 * of LN security model, orthogonal of key management issues.
 */
typedef struct LDKSign {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the per-commitment point for a specific commitment number
    *
    * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
    */
   struct LDKPublicKey (*get_per_commitment_point)(const void *this_arg, uint64_t idx);
   /**
    * Gets the commitment secret for a specific commitment number as part of the revocation process
    *
    * An external signer implementation should error here if the commitment was already signed
    * and should refuse to sign it in the future.
    *
    * May be called more than once for the same index.
    *
    * Note that the commitment number starts at (1 << 48) - 1 and counts backwards.
    */
   struct LDKThirtyTwoBytes (*release_commitment_secret)(const void *this_arg, uint64_t idx);
   /**
    * Gets the holder's channel public keys and basepoints
    */
   struct LDKChannelPublicKeys pubkeys;
   /**
    * Fill in the pubkeys field as a reference to it will be given to Rust after this returns
    * Note that this takes a pointer to this object, not the this_ptr like other methods do
    * This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
    */
   void (*set_pubkeys)(const struct LDKSign*NONNULL_PTR );
   /**
    * Gets an arbitrary identifier describing the set of keys which are provided back to you in
    * some SpendableOutputDescriptor types. This should be sufficient to identify this
    * Sign object uniquely and lookup or re-derive its keys.
    */
   struct LDKThirtyTwoBytes (*channel_keys_id)(const void *this_arg);
   /**
    * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
    *
    * Note that if signing fails or is rejected, the channel will be force-closed.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_counterparty_commitment)(const void *this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signatures for a holder's commitment transaction and its claiming HTLC transactions.
    * This will only ever be called with a non-revoked commitment_tx.  This will be called with the
    * latest commitment_tx when we initiate a force-close.
    * This will be called with the previous latest, just to get claiming HTLC signatures, if we are
    * reacting to a ChannelMonitor replica that decided to broadcast before it had been updated to
    * the latest.
    * This may be called multiple times for the same transaction.
    *
    * An external signer implementation should check that the commitment has not been revoked.
    *
    * May return Err if key derivation fails.  Callers, such as ChannelMonitor, will panic in such a case.
    */
   struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ (*sign_holder_commitment_and_htlcs)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signature for the given input in a transaction spending an HTLC or commitment
    * transaction output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiples outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiples time for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * per_commitment_key is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    *
    * htlc holds HTLC elements (hash, timelock) if the output being spent is a HTLC output, thus
    * changing the format of the witness script (which is committed to in the BIP 143
    * signatures).
    */
   struct LDKCResult_SignatureNoneZ (*sign_justice_transaction)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
    * transaction, either offered or received.
    *
    * Such a transaction may claim multiples offered outputs at same time if we know the
    * preimage for each when we create it, but only the input at index `input` should be
    * signed for here. It may be called multiple times for same output(s) if a fee-bump is
    * needed with regards to an upcoming timelock expiration.
    *
    * Witness_script is either a offered or received script as defined in BOLT3 for HTLC
    * outputs.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * Per_commitment_point is the dynamic point corresponding to the channel state
    * detected onchain. It has been generated by our counterparty and is used to derive
    * channel state keys, which are then included in the witness script and committed to in the
    * BIP 143 signature.
    */
   struct LDKCResult_SignatureNoneZ (*sign_counterparty_htlc_transaction)(const void *this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a (proposed) closing transaction.
    *
    * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
    * chosen to forgo their output as dust.
    */
   struct LDKCResult_SignatureNoneZ (*sign_closing_transaction)(const void *this_arg, struct LDKTransaction closing_tx);
   /**
    * Signs a channel announcement message with our funding key, proving it comes from one
    * of the channel participants.
    *
    * Note that if this fails or is rejected, the channel will not be publicly announced and
    * our counterparty may (though likely will not) close the channel on us for violating the
    * protocol.
    */
   struct LDKCResult_SignatureNoneZ (*sign_channel_announcement)(const void *this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Set the counterparty static channel data, including basepoints,
    * counterparty_selected/holder_selected_contest_delay and funding outpoint.
    * This is done as soon as the funding outpoint is known.  Since these are static channel data,
    * they MUST NOT be allowed to change to different values once set.
    *
    * channel_parameters.is_populated() MUST be true.
    *
    * We bind holder_selected_contest_delay late here for API convenience.
    *
    * Will be called before any signatures are applied.
    */
   void (*ready_channel)(void *this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters);
   /**
    * Creates a copy of the object pointed to by this_arg, for a copy of this Sign.
    * Note that the ultimate copy of the Sign will have all function pointers the same as the original.
    * May be NULL if no action needs to be taken, the this_arg pointer will be copied into the new Sign.
    */
   void *(*clone)(const void *this_arg);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSign;



/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Pending Events or updated HTLCs which have not yet been read out by
 * get_and_clear_pending_monitor_events or get_and_clear_pending_events are serialized to disk and
 * reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events
 * gotten are fully handled before re-serializing the new state.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitor;

typedef struct LDKC2Tuple_BlockHashChannelMonitorZ {
   struct LDKThirtyTwoBytes a;
   struct LDKChannelMonitor b;
} LDKC2Tuple_BlockHashChannelMonitorZ;

typedef union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr {
   struct LDKC2Tuple_BlockHashChannelMonitorZ *result;
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr;

typedef struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ {
   union LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ;

typedef union LDKCResult_TxOutAccessErrorZPtr {
   struct LDKTxOut *result;
   enum LDKAccessError *err;
} LDKCResult_TxOutAccessErrorZPtr;

typedef struct LDKCResult_TxOutAccessErrorZ {
   union LDKCResult_TxOutAccessErrorZPtr contents;
   bool result_ok;
} LDKCResult_TxOutAccessErrorZ;

/**
 * A Rust str object, ie a reference to a UTF8-valid string.
 * This is *not* null-terminated so cannot be used directly as a C string!
 */
typedef struct LDKStr {
   const uint8_t *chars;
   uintptr_t len;
} LDKStr;

/**
 * Indicates an error on the client's part (usually some variant of attempting to use too-low or
 * too-high values)
 */
typedef enum LDKAPIError_Tag {
   /**
    * Indicates the API was wholly misused (see err for more). Cases where these can be returned
    * are documented, but generally indicates some precondition of a function was violated.
    */
   LDKAPIError_APIMisuseError,
   /**
    * Due to a high feerate, we were unable to complete the request.
    * For example, this may be returned if the feerate implies we cannot open a channel at the
    * requested value, but opening a larger channel would succeed.
    */
   LDKAPIError_FeeRateTooHigh,
   /**
    * A malformed Route was provided (eg overflowed value, node id mismatch, overly-looped route,
    * too-many-hops, etc).
    */
   LDKAPIError_RouteError,
   /**
    * We were unable to complete the request as the Channel required to do so is unable to
    * complete the request (or was not found). This can take many forms, including disconnected
    * peer, channel at capacity, channel shutting down, etc.
    */
   LDKAPIError_ChannelUnavailable,
   /**
    * An attempt to call watch/update_channel returned an Err (ie you did this!), causing the
    * attempted action to fail.
    */
   LDKAPIError_MonitorUpdateFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKAPIError_Sentinel,
} LDKAPIError_Tag;

typedef struct LDKAPIError_LDKAPIMisuseError_Body {
   /**
    * A human-readable error message
    */
   struct LDKCVec_u8Z err;
} LDKAPIError_LDKAPIMisuseError_Body;

typedef struct LDKAPIError_LDKFeeRateTooHigh_Body {
   /**
    * A human-readable error message
    */
   struct LDKCVec_u8Z err;
   /**
    * The feerate which was too high.
    */
   uint32_t feerate;
} LDKAPIError_LDKFeeRateTooHigh_Body;

typedef struct LDKAPIError_LDKRouteError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKRouteError_Body;

typedef struct LDKAPIError_LDKChannelUnavailable_Body {
   /**
    * A human-readable error message
    */
   struct LDKCVec_u8Z err;
} LDKAPIError_LDKChannelUnavailable_Body;

typedef struct MUST_USE_STRUCT LDKAPIError {
   LDKAPIError_Tag tag;
   union {
      LDKAPIError_LDKAPIMisuseError_Body api_misuse_error;
      LDKAPIError_LDKFeeRateTooHigh_Body fee_rate_too_high;
      LDKAPIError_LDKRouteError_Body route_error;
      LDKAPIError_LDKChannelUnavailable_Body channel_unavailable;
   };
} LDKAPIError;

typedef union LDKCResult_NoneAPIErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   struct LDKAPIError *err;
} LDKCResult_NoneAPIErrorZPtr;

typedef struct LDKCResult_NoneAPIErrorZ {
   union LDKCResult_NoneAPIErrorZPtr contents;
   bool result_ok;
} LDKCResult_NoneAPIErrorZ;

typedef struct LDKCVec_CResult_NoneAPIErrorZZ {
   struct LDKCResult_NoneAPIErrorZ *data;
   uintptr_t datalen;
} LDKCVec_CResult_NoneAPIErrorZZ;

typedef struct LDKCVec_APIErrorZ {
   struct LDKAPIError *data;
   uintptr_t datalen;
} LDKCVec_APIErrorZ;



/**
 * Details of a channel, as returned by ChannelManager::list_channels and ChannelManager::list_usable_channels
 */
typedef struct MUST_USE_STRUCT LDKChannelDetails {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelDetails *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelDetails;

typedef struct LDKCVec_ChannelDetailsZ {
   struct LDKChannelDetails *data;
   uintptr_t datalen;
} LDKCVec_ChannelDetailsZ;

/**
 * If a payment fails to send, it can be in one of several states. This enum is returned as the
 * Err() type describing which state the payment is in, see the description of individual enum
 * states for more.
 */
typedef enum LDKPaymentSendFailure_Tag {
   /**
    * A parameter which was passed to send_payment was invalid, preventing us from attempting to
    * send the payment at all. No channel state has been changed or messages sent to peers, and
    * once you've changed the parameter at error, you can freely retry the payment in full.
    */
   LDKPaymentSendFailure_ParameterError,
   /**
    * A parameter in a single path which was passed to send_payment was invalid, preventing us
    * from attempting to send the payment at all. No channel state has been changed or messages
    * sent to peers, and once you've changed the parameter at error, you can freely retry the
    * payment in full.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment.
    */
   LDKPaymentSendFailure_PathParameterError,
   /**
    * All paths which were attempted failed to send, with no channel state change taking place.
    * You can freely retry the payment in full (though you probably want to do so over different
    * paths than the ones selected).
    */
   LDKPaymentSendFailure_AllFailedRetrySafe,
   /**
    * Some paths which were attempted failed to send, though possibly not all. At least some
    * paths have irrevocably committed to the HTLC and retrying the payment in full would result
    * in over-/re-payment.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment, and any Errs which are not APIError::MonitorUpdateFailed can be safely
    * retried (though there is currently no API with which to do so).
    *
    * Any entries which contain Err(APIError::MonitorUpdateFailed) or Ok(()) MUST NOT be retried
    * as they will result in over-/re-payment. These HTLCs all either successfully sent (in the
    * case of Ok(())) or will send once channel_monitor_updated is called on the next-hop channel
    * with the latest update_id.
    */
   LDKPaymentSendFailure_PartialFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentSendFailure_Sentinel,
} LDKPaymentSendFailure_Tag;

typedef struct MUST_USE_STRUCT LDKPaymentSendFailure {
   LDKPaymentSendFailure_Tag tag;
   union {
      struct {
         struct LDKAPIError parameter_error;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ path_parameter_error;
      };
      struct {
         struct LDKCVec_APIErrorZ all_failed_retry_safe;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ partial_failure;
      };
   };
} LDKPaymentSendFailure;

typedef union LDKCResult_NonePaymentSendFailureZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   struct LDKPaymentSendFailure *err;
} LDKCResult_NonePaymentSendFailureZPtr;

typedef struct LDKCResult_NonePaymentSendFailureZ {
   union LDKCResult_NonePaymentSendFailureZPtr contents;
   bool result_ok;
} LDKCResult_NonePaymentSendFailureZ;

typedef struct LDKCVec_ChannelMonitorZ {
   struct LDKChannelMonitor *data;
   uintptr_t datalen;
} LDKCVec_ChannelMonitorZ;

/**
 * The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
 * blocks are connected and disconnected.
 *
 * Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
 * responsible for maintaining a set of monitors such that they can be updated accordingly as
 * channel state changes and HTLCs are resolved. See method documentation for specific
 * requirements.
 *
 * Implementations **must** ensure that updates are successfully applied and persisted upon method
 * completion. If an update fails with a [`PermanentFailure`], then it must immediately shut down
 * without taking any further action such as persisting the current state.
 *
 * If an implementation maintains multiple instances of a channel's monitor (e.g., by storing
 * backup copies), then it must ensure that updates are applied across all instances. Otherwise, it
 * could result in a revoked transaction being broadcast, allowing the counterparty to claim all
 * funds in the channel. See [`ChannelMonitorUpdateErr`] for more details about how to handle
 * multiple instances.
 *
 * [`ChannelMonitor`]: channelmonitor/struct.ChannelMonitor.html
 * [`ChannelMonitorUpdateErr`]: channelmonitor/enum.ChannelMonitorUpdateErr.html
 * [`PermanentFailure`]: channelmonitor/enum.ChannelMonitorUpdateErr.html#variant.PermanentFailure
 */
typedef struct LDKWatch {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Watches a channel identified by `funding_txo` using `monitor`.
    *
    * Implementations are responsible for watching the chain for the funding transaction along
    * with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
    * calling [`block_connected`] and [`block_disconnected`] on the monitor.
    *
    * [`get_outputs_to_watch`]: channelmonitor/struct.ChannelMonitor.html#method.get_outputs_to_watch
    * [`block_connected`]: channelmonitor/struct.ChannelMonitor.html#method.block_connected
    * [`block_disconnected`]: channelmonitor/struct.ChannelMonitor.html#method.block_disconnected
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*watch_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor);
   /**
    * Updates a channel identified by `funding_txo` by applying `update` to its monitor.
    *
    * Implementations must call [`update_monitor`] with the given update. See
    * [`ChannelMonitorUpdateErr`] for invariants around returning an error.
    *
    * [`update_monitor`]: channelmonitor/struct.ChannelMonitor.html#method.update_monitor
    * [`ChannelMonitorUpdateErr`]: channelmonitor/enum.ChannelMonitorUpdateErr.html
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*update_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitorUpdate update);
   /**
    * Returns any monitor events since the last call. Subsequent calls must only return new
    * events.
    */
   struct LDKCVec_MonitorEventZ (*release_pending_monitor_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWatch;

/**
 * An interface to send a transaction to the Bitcoin network.
 */
typedef struct LDKBroadcasterInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Sends a transaction out to (hopefully) be mined.
    */
   void (*broadcast_transaction)(const void *this_arg, struct LDKTransaction tx);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBroadcasterInterface;

typedef union LDKCResult_SignDecodeErrorZPtr {
   struct LDKSign *result;
   struct LDKDecodeError *err;
} LDKCResult_SignDecodeErrorZPtr;

typedef struct LDKCResult_SignDecodeErrorZ {
   union LDKCResult_SignDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_SignDecodeErrorZ;

typedef struct LDKu8slice {
   const uint8_t *data;
   uintptr_t datalen;
} LDKu8slice;

/**
 * A trait to describe an object which can get user secrets and key material.
 */
typedef struct LDKKeysInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Get node secret key (aka node_id or network_key).
    *
    * This method must return the same value each time it is called.
    */
   struct LDKSecretKey (*get_node_secret)(const void *this_arg);
   /**
    * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKCVec_u8Z (*get_destination_script)(const void *this_arg);
   /**
    * Get a public key which we will send funds to (in the form of a P2WPKH output) when closing
    * a channel.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKPublicKey (*get_shutdown_pubkey)(const void *this_arg);
   /**
    * Get a new set of Sign for per-channel secrets. These MUST be unique even if you
    * restarted with some stale data!
    *
    * This method must return a different value each time it is called.
    */
   struct LDKSign (*get_channel_signer)(const void *this_arg, bool inbound, uint64_t channel_value_satoshis);
   /**
    * Gets a unique, cryptographically-secure, random 32 byte value. This is used for encrypting
    * onion packets and for temporary channel IDs. There is no requirement that these be
    * persisted anywhere, though they must be unique across restarts.
    *
    * This method must return a different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*get_secure_random_bytes)(const void *this_arg);
   /**
    * Reads a `Signer` for this `KeysInterface` from the given input stream.
    * This is only called during deserialization of other objects which contain
    * `Sign`-implementing objects (ie `ChannelMonitor`s and `ChannelManager`s).
    * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
    * contain no versioning scheme. You may wish to include your own version prefix and ensure
    * you've read all of the provided bytes to ensure no corruption occurred.
    */
   struct LDKCResult_SignDecodeErrorZ (*read_chan_signer)(const void *this_arg, struct LDKu8slice reader);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKKeysInterface;

/**
 * A trait which should be implemented to provide feerate information on a number of time
 * horizons.
 *
 * Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
 * called from inside the library in response to chain events, P2P events, or timer events).
 */
typedef struct LDKFeeEstimator {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets estimated satoshis of fee required per 1000 Weight-Units.
    *
    * Must be no smaller than 253 (ie 1 satoshi-per-byte rounded up to ensure later round-downs
    * don't put us below 1 satoshi-per-byte).
    *
    * This translates to:
    *  * satoshis-per-byte * 250
    *  * ceil(satoshis-per-kbyte / 4)
    */
   uint32_t (*get_est_sat_per_1000_weight)(const void *this_arg, enum LDKConfirmationTarget confirmation_target);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFeeEstimator;

/**
 * A trait encapsulating the operations required of a logger
 */
typedef struct LDKLogger {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Logs the `Record`
    */
   void (*log)(const void *this_arg, const char *record);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLogger;



/**
 * Manager which keeps track of a number of channels and sends messages to the appropriate
 * channel, also tracking HTLC preimages and forwarding onion packets appropriately.
 *
 * Implements ChannelMessageHandler, handling the multi-channel parts and passing things through
 * to individual Channels.
 *
 * Implements Writeable to write out all channel state to disk. Implies peer_disconnected() for
 * all peers during write/read (though does not modify this instance, only the instance being
 * serialized). This will result in any channels which have not yet exchanged funding_created (ie
 * called funding_transaction_generated for outbound channels).
 *
 * Note that you can be a bit lazier about writing out ChannelManager than you can be with
 * ChannelMonitors. With ChannelMonitors you MUST write each monitor update out to disk before
 * returning from chain::Watch::watch_/update_channel, with ChannelManagers, writing updates
 * happens out-of-band (and will prevent any other ChannelManager operations from occurring during
 * the serialization process). If the deserialized version is out-of-date compared to the
 * ChannelMonitors passed by reference to read(), those channels will be force-closed based on the
 * ChannelMonitor state and no funds will be lost (mod on-chain transaction fees).
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelManager), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie call block_disconnected() until you get to a common block and then call
 * block_connected() to step towards your best block) upon deserialization before using the
 * object!
 *
 * Note that ChannelManager is responsible for tracking liveness of its channels and generating
 * ChannelUpdate messages informing peers that the channel is temporarily disabled. To avoid
 * spam due to quick disconnection/reconnection, updates are not sent until the channel has been
 * offline for a full minute. In order to track this, you must call
 * timer_chan_freshness_every_min roughly once per minute, though it doesn't have to be perfect.
 *
 * Rather than using a plain ChannelManager, it is preferable to use either a SimpleArcChannelManager
 * a SimpleRefChannelManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefChannelManager, and use a
 * SimpleArcChannelManager when you require a ChannelManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 */
typedef struct MUST_USE_STRUCT LDKChannelManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManager;

typedef struct LDKC2Tuple_BlockHashChannelManagerZ {
   struct LDKThirtyTwoBytes a;
   struct LDKChannelManager b;
} LDKC2Tuple_BlockHashChannelManagerZ;

typedef union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr {
   struct LDKC2Tuple_BlockHashChannelManagerZ *result;
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr;

typedef struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ {
   union LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ;

typedef union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr {
   struct LDKSpendableOutputDescriptor *result;
   struct LDKDecodeError *err;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr;

typedef struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ {
   union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZ;

typedef struct LDKCVec_CVec_u8ZZ {
   struct LDKCVec_u8Z *data;
   uintptr_t datalen;
} LDKCVec_CVec_u8ZZ;

typedef union LDKCResult_CVec_CVec_u8ZZNoneZPtr {
   struct LDKCVec_CVec_u8ZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_CVec_u8ZZNoneZPtr;

typedef struct LDKCResult_CVec_CVec_u8ZZNoneZ {
   union LDKCResult_CVec_CVec_u8ZZNoneZPtr contents;
   bool result_ok;
} LDKCResult_CVec_CVec_u8ZZNoneZ;



/**
 * A simple implementation of Sign that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */
typedef struct MUST_USE_STRUCT LDKInMemorySigner {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInMemorySigner *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInMemorySigner;

typedef union LDKCResult_InMemorySignerDecodeErrorZPtr {
   struct LDKInMemorySigner *result;
   struct LDKDecodeError *err;
} LDKCResult_InMemorySignerDecodeErrorZPtr;

typedef struct LDKCResult_InMemorySignerDecodeErrorZ {
   union LDKCResult_InMemorySignerDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_InMemorySignerDecodeErrorZ;

typedef struct LDKCVec_TxOutZ {
   struct LDKTxOut *data;
   uintptr_t datalen;
} LDKCVec_TxOutZ;

typedef union LDKCResult_TransactionNoneZPtr {
   struct LDKTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TransactionNoneZPtr;

typedef struct LDKCResult_TransactionNoneZ {
   union LDKCResult_TransactionNoneZPtr contents;
   bool result_ok;
} LDKCResult_TransactionNoneZ;



/**
 * A hop in a route
 */
typedef struct MUST_USE_STRUCT LDKRouteHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHop;

typedef struct LDKCVec_RouteHopZ {
   struct LDKRouteHop *data;
   uintptr_t datalen;
} LDKCVec_RouteHopZ;

typedef struct LDKCVec_CVec_RouteHopZZ {
   struct LDKCVec_RouteHopZ *data;
   uintptr_t datalen;
} LDKCVec_CVec_RouteHopZZ;



/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */
typedef struct MUST_USE_STRUCT LDKRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoute;

typedef union LDKCResult_RouteDecodeErrorZPtr {
   struct LDKRoute *result;
   struct LDKDecodeError *err;
} LDKCResult_RouteDecodeErrorZPtr;

typedef struct LDKCResult_RouteDecodeErrorZ {
   union LDKCResult_RouteDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_RouteDecodeErrorZ;



/**
 * A channel descriptor which provides a last-hop route to get_route
 */
typedef struct MUST_USE_STRUCT LDKRouteHint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHint;

typedef struct LDKCVec_RouteHintZ {
   struct LDKRouteHint *data;
   uintptr_t datalen;
} LDKCVec_RouteHintZ;

typedef union LDKCResult_RouteLightningErrorZPtr {
   struct LDKRoute *result;
   struct LDKLightningError *err;
} LDKCResult_RouteLightningErrorZPtr;

typedef struct LDKCResult_RouteLightningErrorZ {
   union LDKCResult_RouteLightningErrorZPtr contents;
   bool result_ok;
} LDKCResult_RouteLightningErrorZ;

typedef union LDKCResult_NetAddressu8ZPtr {
   struct LDKNetAddress *result;
   uint8_t *err;
} LDKCResult_NetAddressu8ZPtr;

typedef struct LDKCResult_NetAddressu8Z {
   union LDKCResult_NetAddressu8ZPtr contents;
   bool result_ok;
} LDKCResult_NetAddressu8Z;

typedef union LDKCResult_CResult_NetAddressu8ZDecodeErrorZPtr {
   struct LDKCResult_NetAddressu8Z *result;
   struct LDKDecodeError *err;
} LDKCResult_CResult_NetAddressu8ZDecodeErrorZPtr;

typedef struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ {
   union LDKCResult_CResult_NetAddressu8ZDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_CResult_NetAddressu8ZDecodeErrorZ;



/**
 * An update_add_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateAddHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateAddHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateAddHTLC;

typedef struct LDKCVec_UpdateAddHTLCZ {
   struct LDKUpdateAddHTLC *data;
   uintptr_t datalen;
} LDKCVec_UpdateAddHTLCZ;



/**
 * An update_fulfill_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFulfillHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFulfillHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFulfillHTLC;

typedef struct LDKCVec_UpdateFulfillHTLCZ {
   struct LDKUpdateFulfillHTLC *data;
   uintptr_t datalen;
} LDKCVec_UpdateFulfillHTLCZ;



/**
 * An update_fail_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailHTLC;

typedef struct LDKCVec_UpdateFailHTLCZ {
   struct LDKUpdateFailHTLC *data;
   uintptr_t datalen;
} LDKCVec_UpdateFailHTLCZ;



/**
 * An update_fail_malformed_htlc message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailMalformedHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailMalformedHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailMalformedHTLC;

typedef struct LDKCVec_UpdateFailMalformedHTLCZ {
   struct LDKUpdateFailMalformedHTLC *data;
   uintptr_t datalen;
} LDKCVec_UpdateFailMalformedHTLCZ;

typedef union LDKCResult_AcceptChannelDecodeErrorZPtr {
   struct LDKAcceptChannel *result;
   struct LDKDecodeError *err;
} LDKCResult_AcceptChannelDecodeErrorZPtr;

typedef struct LDKCResult_AcceptChannelDecodeErrorZ {
   union LDKCResult_AcceptChannelDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_AcceptChannelDecodeErrorZ;

typedef union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr {
   struct LDKAnnouncementSignatures *result;
   struct LDKDecodeError *err;
} LDKCResult_AnnouncementSignaturesDecodeErrorZPtr;

typedef struct LDKCResult_AnnouncementSignaturesDecodeErrorZ {
   union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_AnnouncementSignaturesDecodeErrorZ;

typedef union LDKCResult_ChannelReestablishDecodeErrorZPtr {
   struct LDKChannelReestablish *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelReestablishDecodeErrorZPtr;

typedef struct LDKCResult_ChannelReestablishDecodeErrorZ {
   union LDKCResult_ChannelReestablishDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelReestablishDecodeErrorZ;

typedef union LDKCResult_ClosingSignedDecodeErrorZPtr {
   struct LDKClosingSigned *result;
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedDecodeErrorZPtr;

typedef struct LDKCResult_ClosingSignedDecodeErrorZ {
   union LDKCResult_ClosingSignedDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ClosingSignedDecodeErrorZ;



/**
 * A commitment_signed message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKCommitmentSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentSigned;

typedef union LDKCResult_CommitmentSignedDecodeErrorZPtr {
   struct LDKCommitmentSigned *result;
   struct LDKDecodeError *err;
} LDKCResult_CommitmentSignedDecodeErrorZPtr;

typedef struct LDKCResult_CommitmentSignedDecodeErrorZ {
   union LDKCResult_CommitmentSignedDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_CommitmentSignedDecodeErrorZ;

typedef union LDKCResult_FundingCreatedDecodeErrorZPtr {
   struct LDKFundingCreated *result;
   struct LDKDecodeError *err;
} LDKCResult_FundingCreatedDecodeErrorZPtr;

typedef struct LDKCResult_FundingCreatedDecodeErrorZ {
   union LDKCResult_FundingCreatedDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_FundingCreatedDecodeErrorZ;

typedef union LDKCResult_FundingSignedDecodeErrorZPtr {
   struct LDKFundingSigned *result;
   struct LDKDecodeError *err;
} LDKCResult_FundingSignedDecodeErrorZPtr;

typedef struct LDKCResult_FundingSignedDecodeErrorZ {
   union LDKCResult_FundingSignedDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_FundingSignedDecodeErrorZ;

typedef union LDKCResult_FundingLockedDecodeErrorZPtr {
   struct LDKFundingLocked *result;
   struct LDKDecodeError *err;
} LDKCResult_FundingLockedDecodeErrorZPtr;

typedef struct LDKCResult_FundingLockedDecodeErrorZ {
   union LDKCResult_FundingLockedDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_FundingLockedDecodeErrorZ;



/**
 * An init message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKInit {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInit *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInit;

typedef union LDKCResult_InitDecodeErrorZPtr {
   struct LDKInit *result;
   struct LDKDecodeError *err;
} LDKCResult_InitDecodeErrorZPtr;

typedef struct LDKCResult_InitDecodeErrorZ {
   union LDKCResult_InitDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_InitDecodeErrorZ;

typedef union LDKCResult_OpenChannelDecodeErrorZPtr {
   struct LDKOpenChannel *result;
   struct LDKDecodeError *err;
} LDKCResult_OpenChannelDecodeErrorZPtr;

typedef struct LDKCResult_OpenChannelDecodeErrorZ {
   union LDKCResult_OpenChannelDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_OpenChannelDecodeErrorZ;

typedef union LDKCResult_RevokeAndACKDecodeErrorZPtr {
   struct LDKRevokeAndACK *result;
   struct LDKDecodeError *err;
} LDKCResult_RevokeAndACKDecodeErrorZPtr;

typedef struct LDKCResult_RevokeAndACKDecodeErrorZ {
   union LDKCResult_RevokeAndACKDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_RevokeAndACKDecodeErrorZ;

typedef union LDKCResult_ShutdownDecodeErrorZPtr {
   struct LDKShutdown *result;
   struct LDKDecodeError *err;
} LDKCResult_ShutdownDecodeErrorZPtr;

typedef struct LDKCResult_ShutdownDecodeErrorZ {
   union LDKCResult_ShutdownDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ShutdownDecodeErrorZ;

typedef union LDKCResult_UpdateFailHTLCDecodeErrorZPtr {
   struct LDKUpdateFailHTLC *result;
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailHTLCDecodeErrorZPtr;

typedef struct LDKCResult_UpdateFailHTLCDecodeErrorZ {
   union LDKCResult_UpdateFailHTLCDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UpdateFailHTLCDecodeErrorZ;

typedef union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
   struct LDKUpdateFailMalformedHTLC *result;
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr;

typedef struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ {
   union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ;



/**
 * An update_fee message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKUpdateFee {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFee *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFee;

typedef union LDKCResult_UpdateFeeDecodeErrorZPtr {
   struct LDKUpdateFee *result;
   struct LDKDecodeError *err;
} LDKCResult_UpdateFeeDecodeErrorZPtr;

typedef struct LDKCResult_UpdateFeeDecodeErrorZ {
   union LDKCResult_UpdateFeeDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UpdateFeeDecodeErrorZ;

typedef union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr {
   struct LDKUpdateFulfillHTLC *result;
   struct LDKDecodeError *err;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr;

typedef struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ {
   union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZ;

typedef union LDKCResult_UpdateAddHTLCDecodeErrorZPtr {
   struct LDKUpdateAddHTLC *result;
   struct LDKDecodeError *err;
} LDKCResult_UpdateAddHTLCDecodeErrorZPtr;

typedef struct LDKCResult_UpdateAddHTLCDecodeErrorZ {
   union LDKCResult_UpdateAddHTLCDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UpdateAddHTLCDecodeErrorZ;



/**
 * A ping message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPing {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePing *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPing;

typedef union LDKCResult_PingDecodeErrorZPtr {
   struct LDKPing *result;
   struct LDKDecodeError *err;
} LDKCResult_PingDecodeErrorZPtr;

typedef struct LDKCResult_PingDecodeErrorZ {
   union LDKCResult_PingDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_PingDecodeErrorZ;



/**
 * A pong message to be sent or received from a peer
 */
typedef struct MUST_USE_STRUCT LDKPong {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePong *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPong;

typedef union LDKCResult_PongDecodeErrorZPtr {
   struct LDKPong *result;
   struct LDKDecodeError *err;
} LDKCResult_PongDecodeErrorZPtr;

typedef struct LDKCResult_PongDecodeErrorZ {
   union LDKCResult_PongDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_PongDecodeErrorZ;

typedef union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
   struct LDKUnsignedChannelAnnouncement *result;
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr;

typedef struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ {
   union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ;

typedef union LDKCResult_ChannelAnnouncementDecodeErrorZPtr {
   struct LDKChannelAnnouncement *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelAnnouncementDecodeErrorZPtr;

typedef struct LDKCResult_ChannelAnnouncementDecodeErrorZ {
   union LDKCResult_ChannelAnnouncementDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelAnnouncementDecodeErrorZ;



/**
 * The unsigned part of a channel_update
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelUpdate;

typedef union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr {
   struct LDKUnsignedChannelUpdate *result;
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr;

typedef struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ {
   union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZ;

typedef union LDKCResult_ChannelUpdateDecodeErrorZPtr {
   struct LDKChannelUpdate *result;
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateDecodeErrorZPtr;

typedef struct LDKCResult_ChannelUpdateDecodeErrorZ {
   union LDKCResult_ChannelUpdateDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ChannelUpdateDecodeErrorZ;

typedef union LDKCResult_ErrorMessageDecodeErrorZPtr {
   struct LDKErrorMessage *result;
   struct LDKDecodeError *err;
} LDKCResult_ErrorMessageDecodeErrorZPtr;

typedef struct LDKCResult_ErrorMessageDecodeErrorZ {
   union LDKCResult_ErrorMessageDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ErrorMessageDecodeErrorZ;



/**
 * The unsigned part of a node_announcement
 */
typedef struct MUST_USE_STRUCT LDKUnsignedNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedNodeAnnouncement;

typedef union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
   struct LDKUnsignedNodeAnnouncement *result;
   struct LDKDecodeError *err;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr;

typedef struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ {
   union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ;

typedef union LDKCResult_NodeAnnouncementDecodeErrorZPtr {
   struct LDKNodeAnnouncement *result;
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementDecodeErrorZPtr;

typedef struct LDKCResult_NodeAnnouncementDecodeErrorZ {
   union LDKCResult_NodeAnnouncementDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_NodeAnnouncementDecodeErrorZ;

typedef union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr {
   struct LDKQueryShortChannelIds *result;
   struct LDKDecodeError *err;
} LDKCResult_QueryShortChannelIdsDecodeErrorZPtr;

typedef struct LDKCResult_QueryShortChannelIdsDecodeErrorZ {
   union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_QueryShortChannelIdsDecodeErrorZ;



/**
 * A reply_short_channel_ids_end message is sent as a reply to a
 * query_short_channel_ids message. The query recipient makes a best
 * effort to respond based on their local network view which may not be
 * a perfect view of the network.
 */
typedef struct MUST_USE_STRUCT LDKReplyShortChannelIdsEnd {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyShortChannelIdsEnd *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyShortChannelIdsEnd;

typedef union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
   struct LDKReplyShortChannelIdsEnd *result;
   struct LDKDecodeError *err;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr;

typedef struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ {
   union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ;

typedef union LDKCResult_QueryChannelRangeDecodeErrorZPtr {
   struct LDKQueryChannelRange *result;
   struct LDKDecodeError *err;
} LDKCResult_QueryChannelRangeDecodeErrorZPtr;

typedef struct LDKCResult_QueryChannelRangeDecodeErrorZ {
   union LDKCResult_QueryChannelRangeDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_QueryChannelRangeDecodeErrorZ;



/**
 * A reply_channel_range message is a reply to a query_channel_range
 * message. Multiple reply_channel_range messages can be sent in reply
 * to a single query_channel_range message. The query recipient makes a
 * best effort to respond based on their local network view which may
 * not be a perfect view of the network. The short_channel_ids in the
 * reply are encoded. We only support encoding_type=0 uncompressed
 * serialization and do not support encoding_type=1 zlib serialization.
 */
typedef struct MUST_USE_STRUCT LDKReplyChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyChannelRange;

typedef union LDKCResult_ReplyChannelRangeDecodeErrorZPtr {
   struct LDKReplyChannelRange *result;
   struct LDKDecodeError *err;
} LDKCResult_ReplyChannelRangeDecodeErrorZPtr;

typedef struct LDKCResult_ReplyChannelRangeDecodeErrorZ {
   union LDKCResult_ReplyChannelRangeDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_ReplyChannelRangeDecodeErrorZ;



/**
 * A gossip_timestamp_filter message is used by a node to request
 * gossip relay for messages in the requested time range when the
 * gossip_queries feature has been negotiated.
 */
typedef struct MUST_USE_STRUCT LDKGossipTimestampFilter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeGossipTimestampFilter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKGossipTimestampFilter;

typedef union LDKCResult_GossipTimestampFilterDecodeErrorZPtr {
   struct LDKGossipTimestampFilter *result;
   struct LDKDecodeError *err;
} LDKCResult_GossipTimestampFilterDecodeErrorZPtr;

typedef struct LDKCResult_GossipTimestampFilterDecodeErrorZ {
   union LDKCResult_GossipTimestampFilterDecodeErrorZPtr contents;
   bool result_ok;
} LDKCResult_GossipTimestampFilterDecodeErrorZ;

/**
 * A trait indicating an object may generate message send events
 */
typedef struct LDKMessageSendEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the list of pending events which were generated by previous actions, clearing the list
    * in the process.
    */
   struct LDKCVec_MessageSendEventZ (*get_and_clear_pending_msg_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKMessageSendEventsProvider;

/**
 * A trait indicating an object may generate events
 */
typedef struct LDKEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the list of pending events which were generated by previous actions, clearing the list
    * in the process.
    */
   struct LDKCVec_EventZ (*get_and_clear_pending_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventsProvider;



/**
 * Configuration we set when applicable.
 *
 * Default::default() provides sane defaults.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeConfig;



/**
 * Optional channel limits which are applied during channel creation.
 *
 * These limits are only applied to our counterparty's limits, not our own.
 *
 * Use 0/<type>::max_value() as appropriate to skip checking.
 *
 * Provides sane defaults for most configurations.
 *
 * Most additional limits are disabled except those with which specify a default in individual
 * field documentation. Note that this may result in barely-usable channels, but since they
 * are applied mostly only to incoming channels that's not much of a problem.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeLimits {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeLimits *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeLimits;



/**
 * Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
 *
 * Default::default() provides sane defaults for most configurations
 * (but currently with 0 relay fees!)
 */
typedef struct MUST_USE_STRUCT LDKUserConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUserConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUserConfig;

/**
 * The `Access` trait defines behavior for accessing chain data and state, such as blocks and
 * UTXOs.
 */
typedef struct LDKAccess {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
    * Returns an error if `genesis_hash` is for a different chain or if such a transaction output
    * is unknown.
    *
    * [`short_channel_id`]: https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#definition-of-short_channel_id
    */
   struct LDKCResult_TxOutAccessErrorZ (*get_utxo)(const void *this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKAccess;

/**
 * The `Listen` trait is used to be notified of when blocks have been connected or disconnected
 * from the chain.
 *
 * Useful when needing to replay chain data upon startup or as new chain events occur.
 */
typedef struct LDKListen {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies the listener that a block was added at the given height.
    */
   void (*block_connected)(const void *this_arg, struct LDKu8slice block, uint32_t height);
   /**
    * Notifies the listener that a block was removed at the given height.
    */
   void (*block_disconnected)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKListen;

/**
 * The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
 * channels.
 *
 * This is useful in order to have a [`Watch`] implementation convey to a chain source which
 * transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
 * the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
 * receiving full blocks from a chain source, any further filtering is unnecessary.
 *
 * After an output has been registered, subsequent block retrievals from the chain source must not
 * exclude any transactions matching the new criteria nor any in-block descendants of such
 * transactions.
 *
 * Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
 * should not block on I/O. Implementations should instead queue the newly monitored data to be
 * processed later. Then, in order to block until the data has been processed, any `Watch`
 * invocation that has called the `Filter` must return [`TemporaryFailure`].
 *
 * [`Watch`]: trait.Watch.html
 * [`TemporaryFailure`]: channelmonitor/enum.ChannelMonitorUpdateErr.html#variant.TemporaryFailure
 * [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
 * [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
 */
typedef struct LDKFilter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
    * a spending condition.
    */
   void (*register_tx)(const void *this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey);
   /**
    * Registers interest in spends of a transaction output identified by `outpoint` having
    * `script_pubkey` as the spending condition.
    */
   void (*register_output)(const void *this_arg, const struct LDKOutPoint *NONNULL_PTR outpoint, struct LDKu8slice script_pubkey);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFilter;

/**
 * `Persist` defines behavior for persisting channel monitors: this could mean
 * writing once to disk, and/or uploading to one or more backup services.
 *
 * Note that for every new monitor, you **must** persist the new `ChannelMonitor`
 * to disk/backups. And, on every update, you **must** persist either the
 * `ChannelMonitorUpdate` or the updated monitor itself. Otherwise, there is risk
 * of situations such as revoking a transaction, then crashing before this
 * revocation can be persisted, then unintentionally broadcasting a revoked
 * transaction and losing money. This is a risk because previous channel states
 * are toxic, so it's important that whatever channel state is persisted is
 * kept up-to-date.
 */
typedef struct LDKPersist {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist a new channel's data. The data can be stored any way you want, but
    * the identifier provided by Rust-Lightning is the channel's outpoint (and
    * it is up to you to maintain a correct mapping between the outpoint and the
    * stored channel data). Note that you **must** persist every new monitor to
    * disk. See the `Persist` trait documentation for more details.
    *
    * See [`ChannelMonitor::serialize_for_disk`] for writing out a `ChannelMonitor`,
    * and [`ChannelMonitorUpdateErr`] for requirements when returning errors.
    *
    * [`ChannelMonitor::serialize_for_disk`]: struct.ChannelMonitor.html#method.serialize_for_disk
    * [`ChannelMonitorUpdateErr`]: enum.ChannelMonitorUpdateErr.html
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*persist_new_channel)(const void *this_arg, struct LDKOutPoint id, const struct LDKChannelMonitor *NONNULL_PTR data);
   /**
    * Update one channel's data. The provided `ChannelMonitor` has already
    * applied the given update.
    *
    * Note that on every update, you **must** persist either the
    * `ChannelMonitorUpdate` or the updated monitor itself to disk/backups. See
    * the `Persist` trait documentation for more details.
    *
    * If an implementer chooses to persist the updates only, they need to make
    * sure that all the updates are applied to the `ChannelMonitors` *before*
    * the set of channel monitors is given to the `ChannelManager`
    * deserialization routine. See [`ChannelMonitor::update_monitor`] for
    * applying a monitor update to a monitor. If full `ChannelMonitors` are
    * persisted, then there is no need to persist individual updates.
    *
    * Note that there could be a performance tradeoff between persisting complete
    * channel monitors on every update vs. persisting only updates and applying
    * them in batches. The size of each monitor grows `O(number of state updates)`
    * whereas updates are small and `O(1)`.
    *
    * See [`ChannelMonitor::serialize_for_disk`] for writing out a `ChannelMonitor`,
    * [`ChannelMonitorUpdate::write`] for writing out an update, and
    * [`ChannelMonitorUpdateErr`] for requirements when returning errors.
    *
    * [`ChannelMonitor::update_monitor`]: struct.ChannelMonitor.html#impl-1
    * [`ChannelMonitor::serialize_for_disk`]: struct.ChannelMonitor.html#method.serialize_for_disk
    * [`ChannelMonitorUpdate::write`]: struct.ChannelMonitorUpdate.html#method.write
    * [`ChannelMonitorUpdateErr`]: enum.ChannelMonitorUpdateErr.html
    */
   struct LDKCResult_NoneChannelMonitorUpdateErrZ (*update_persisted_channel)(const void *this_arg, struct LDKOutPoint id, const struct LDKChannelMonitorUpdate *NONNULL_PTR update, const struct LDKChannelMonitor *NONNULL_PTR data);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersist;



/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * [`chain::Watch`]: ../trait.Watch.html
 * [`ChannelManager`]: ../../ln/channelmanager/struct.ChannelManager.html
 * [module-level documentation]: index.html
 */
typedef struct MUST_USE_STRUCT LDKChainMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainMonitor;



/**
 * Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
 * and derives keys from that.
 *
 * Your node_id is seed/0'
 * ChannelMonitor closes may use seed/1'
 * Cooperative closes may use seed/2'
 * The two close keys may be needed to claim on-chain funds!
 */
typedef struct MUST_USE_STRUCT LDKKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKKeysManager;



/**
 * Chain-related parameters used to construct a new `ChannelManager`.
 *
 * Typically, the block-specific parameters are derived from the best block hash for the network,
 * as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
 * are not needed when deserializing a previously constructed `ChannelManager`.
 */
typedef struct MUST_USE_STRUCT LDKChainParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainParameters;

typedef struct LDKThreeBytes {
   uint8_t data[3];
} LDKThreeBytes;

/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different their_node_ids, however
 * they MUST NOT be called in parallel when the two calls have the same their_node_id.
 */
typedef struct LDKChannelMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming open_channel message from the given peer.
    */
   void (*handle_open_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKOpenChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming accept_channel message from the given peer.
    */
   void (*handle_accept_channel)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKAcceptChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_created message from the given peer.
    */
   void (*handle_funding_created)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_signed message from the given peer.
    */
   void (*handle_funding_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming funding_locked message from the given peer.
    */
   void (*handle_funding_locked)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingLocked *NONNULL_PTR msg);
   /**
    * Handle an incoming shutdown message from the given peer.
    */
   void (*handle_shutdown)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInitFeatures *NONNULL_PTR their_features, const struct LDKShutdown *NONNULL_PTR msg);
   /**
    * Handle an incoming closing_signed message from the given peer.
    */
   void (*handle_closing_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming update_add_htlc message from the given peer.
    */
   void (*handle_update_add_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fulfill_htlc message from the given peer.
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_htlc message from the given peer.
    */
   void (*handle_update_fail_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fail_malformed_htlc message from the given peer.
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming commitment_signed message from the given peer.
    */
   void (*handle_commitment_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming revoke_and_ack message from the given peer.
    */
   void (*handle_revoke_and_ack)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg);
   /**
    * Handle an incoming update_fee message from the given peer.
    */
   void (*handle_update_fee)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg);
   /**
    * Handle an incoming announcement_signatures message from the given peer.
    */
   void (*handle_announcement_signatures)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost. If no connection
    * is believed to be possible in the future (eg they're sending us messages we don't
    * understand or indicate they require unknown feature bits), no_connection_possible is set
    * and any outstanding channels should be failed.
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible);
   /**
    * Handle a peer reconnecting, possibly generating channel_reestablish message(s).
    */
   void (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_reestablish message from the given peer.
    */
   void (*handle_channel_reestablish)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg);
   /**
    * Handle an incoming error message from the given peer.
    */
   void (*handle_error)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelMessageHandler;



/**
 * Arguments for the creation of a ChannelManager that are not deserialized.
 *
 * At a high-level, the process for deserializing a ChannelManager and resuming normal operation
 * is:
 * 1) Deserialize all stored ChannelMonitors.
 * 2) Deserialize the ChannelManager by filling in this struct and calling:
 *    <(BlockHash, ChannelManager)>::read(reader, args)
 *    This may result in closing some Channels if the ChannelMonitor is newer than the stored
 *    ChannelManager state to ensure no loss of funds. Thus, transactions may be broadcasted.
 * 3) If you are not fetching full blocks, register all relevant ChannelMonitor outpoints the same
 *    way you would handle a `chain::Filter` call using ChannelMonitor::get_outputs_to_watch() and
 *    ChannelMonitor::get_funding_txo().
 * 4) Reconnect blocks on your ChannelMonitors.
 * 5) Disconnect/connect blocks on the ChannelManager.
 * 6) Move the ChannelMonitors into your local chain::Watch.
 *
 * Note that the ordering of #4-6 is not of importance, however all three must occur before you
 * call any other methods on the newly-deserialized ChannelManager.
 *
 * Note that because some channels may be closed during deserialization, it is critical that you
 * always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
 * you. If you deserialize an old ChannelManager (during which force-closure transactions may be
 * broadcast), and then later deserialize a newer version of the same ChannelManager (which will
 * not force-close the same channels but consider them live), you may end up revoking a state for
 * which you've already broadcasted the transaction.
 */
typedef struct MUST_USE_STRUCT LDKChannelManagerReadArgs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManagerReadArgs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManagerReadArgs;



/**
 * Proof that the sender knows the per-commitment secret of the previous commitment transaction.
 * This is used to convince the recipient that the channel is at a certain commitment
 * number even if they lost that data due to a local failure.  Of course, the peer may lie
 * and even later commitments may have been revoked.
 */
typedef struct MUST_USE_STRUCT LDKDataLossProtect {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDataLossProtect *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDataLossProtect;

/**
 * A trait to describe an object which can receive routing messages.
 *
 * # Implementor DoS Warnings
 *
 * For `gossip_queries` messages there are potential DoS vectors when handling
 * inbound queries. Implementors using an on-disk network graph should be aware of
 * repeated disk I/O for queries accessing different parts of the network graph.
 */
typedef struct LDKRoutingMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming node_announcement message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_node_announcement)(const void *this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
   /**
    * Handle a channel_announcement message, returning true if it should be forwarded on, false
    * or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_announcement)(const void *this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Handle an incoming channel_update message, returning true if it should be forwarded on,
    * false or returning an Err otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_update)(const void *this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Handle some updates to the route graph that we learned due to an outbound failed payment.
    */
   void (*handle_htlc_fail_channel_update)(const void *this_arg, const struct LDKHTLCFailChannelUpdate *NONNULL_PTR update);
   /**
    * Gets a subset of the channel announcements and updates required to dump our routing table
    * to a remote node, starting at the short_channel_id indicated by starting_point and
    * including the batch_amount entries immediately higher in numerical value than starting_point.
    */
   struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ (*get_next_channel_announcements)(const void *this_arg, uint64_t starting_point, uint8_t batch_amount);
   /**
    * Gets a subset of the node announcements required to dump our routing table to a remote node,
    * starting at the node *after* the provided publickey and including batch_amount entries
    * immediately higher (as defined by <PublicKey as Ord>::cmp) than starting_point.
    * If None is provided for starting_point, we start at the first node.
    */
   struct LDKCVec_NodeAnnouncementZ (*get_next_node_announcements)(const void *this_arg, struct LDKPublicKey starting_point, uint8_t batch_amount);
   /**
    * Called when a connection is established with a peer. This can be used to
    * perform routing table synchronization using a strategy defined by the
    * implementor.
    */
   void (*sync_routing_table)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init);
   /**
    * Handles the reply of a query we initiated to learn about channels
    * for a given range of blocks. We can expect to receive one or more
    * replies to a single query.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg);
   /**
    * Handles the reply of a query we initiated asking for routing gossip
    * messages for a list of channels. We should receive this message when
    * a node has completed its best effort to send us the pertaining routing
    * gossip messages.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_short_channel_ids_end)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg);
   /**
    * Handles when a peer asks us to send a list of short_channel_ids
    * for the requested range of blocks.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg);
   /**
    * Handles when a peer asks us to send routing gossip messages for a
    * list of short_channel_ids.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_short_channel_ids)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRoutingMessageHandler;



/**
 * A dummy struct which implements `RoutingMessageHandler` without storing any routing information
 * or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKIgnoringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeIgnoringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKIgnoringMessageHandler;



/**
 * A dummy struct which implements `ChannelMessageHandler` without having any channels.
 * You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKErroringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErroringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErroringMessageHandler;



/**
 * Provides references to trait impls which handle different types of messages.
 */
typedef struct MUST_USE_STRUCT LDKMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMessageHandler;

/**
 * Provides an object which can be used to send data to and which uniquely identifies a connection
 * to a remote host. You will need to be able to generate multiple of these which meet Eq and
 * implement Hash to meet the PeerManager API.
 *
 * For efficiency, Clone should be relatively cheap for this type.
 *
 * You probably want to just extend an int and put a file descriptor in a struct and implement
 * send_data. Note that if you are using a higher-level net library that may call close() itself,
 * be careful to ensure you don't have races whereby you might register a new connection with an
 * fd which is the same as a previous one which has yet to be removed via
 * PeerManager::socket_disconnected().
 */
typedef struct LDKSocketDescriptor {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Attempts to send some data from the given slice to the peer.
    *
    * Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
    * Note that in the disconnected case, socket_disconnected must still fire and further write
    * attempts may occur until that time.
    *
    * If the returned size is smaller than data.len(), a write_available event must
    * trigger the next time more data can be written. Additionally, until the a send_data event
    * completes fully, no further read_events should trigger on the same peer!
    *
    * If a read_event on this descriptor had previously returned true (indicating that read
    * events should be paused to prevent DoS in the send buffer), resume_read may be set
    * indicating that read events on this descriptor should resume. A resume_read of false does
    * *not* imply that further read events should be paused.
    */
   uintptr_t (*send_data)(void *this_arg, struct LDKu8slice data, bool resume_read);
   /**
    * Disconnect the socket pointed to by this SocketDescriptor. Once this function returns, no
    * more calls to write_buffer_space_avail, read_event or socket_disconnected may be made with
    * this descriptor. No socket_disconnected call should be generated as a result of this call,
    * though races may occur whereby disconnect_socket is called after a call to
    * socket_disconnected but prior to socket_disconnected returning.
    */
   void (*disconnect_socket)(void *this_arg);
   /**
    * Checks if two objects are equal given this object's this_arg pointer and another object.
    */
   bool (*eq)(const void *this_arg, const struct LDKSocketDescriptor *NONNULL_PTR other_arg);
   /**
    * Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
    * This is used, for example, for inclusion of this object in a hash map.
    */
   uint64_t (*hash)(const void *this_arg);
   /**
    * Creates a copy of the object pointed to by this_arg, for a copy of this SocketDescriptor.
    * Note that the ultimate copy of the SocketDescriptor will have all function pointers the same as the original.
    * May be NULL if no action needs to be taken, the this_arg pointer will be copied into the new SocketDescriptor.
    */
   void *(*clone)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSocketDescriptor;



/**
 * A PeerManager manages a set of peers, described by their SocketDescriptor and marshalls socket
 * events into messages which it passes on to its MessageHandlers.
 *
 * Rather than using a plain PeerManager, it is preferable to use either a SimpleArcPeerManager
 * a SimpleRefPeerManager, for conciseness. See their documentation for more details, but
 * essentially you should default to using a SimpleRefPeerManager, and use a
 * SimpleArcPeerManager when you require a PeerManager with a static lifetime, such as when
 * you're using lightning-net-tokio.
 */
typedef struct MUST_USE_STRUCT LDKPeerManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerManager;



/**
 * Static channel fields used to build transactions given per-commitment fields, organized by
 * broadcaster/countersignatory.
 *
 * This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
 * as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelTransactionParameters;



/**
 * A simple newtype for RwLockReadGuard<'a, NetworkGraph>.
 * This exists only to make accessing a RwLock<NetworkGraph> possible from
 * the C bindings, as it can be done directly in Rust code.
 */
typedef struct MUST_USE_STRUCT LDKLockedNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLockedNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLockedNetworkGraph;



/**
 * Receives and validates network updates from peers,
 * stores authentic and relevant data as a network graph.
 * This network graph is then used for routing payments.
 * Provides interface to help with initial routing sync by
 * serving historical announcements.
 */
typedef struct MUST_USE_STRUCT LDKNetGraphMsgHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetGraphMsgHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetGraphMsgHandler;

extern const uintptr_t MAX_BUF_SIZE;

extern const uint64_t MIN_RELAY_FEE_SAT_PER_1000_WEIGHT;

extern const uint64_t CLOSED_CHANNEL_UPDATE_ID;

extern const uintptr_t REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH;

void Transaction_free(struct LDKTransaction _res);

void TxOut_free(struct LDKTxOut _res);

struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);

struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_ok(struct LDKSecretKey o);

struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_err(enum LDKSecp256k1Error e);

void CResult_SecretKeyErrorZ_free(struct LDKCResult_SecretKeyErrorZ _res);

struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);

struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);

void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);

struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);

struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);

struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);

struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);

struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_ok(struct LDKTxCreationKeys o);

struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_err(enum LDKSecp256k1Error e);

void CResult_TxCreationKeysErrorZ_free(struct LDKCResult_TxCreationKeysErrorZ _res);

struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);

struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);

struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);

struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);

struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);

struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);

struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);

struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);

struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);

struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);

struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);

struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);

struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);

struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);

struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);

void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);

struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);

struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);

void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);

struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);

void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);

struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);

struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);

void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);

struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);

struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);

struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);

void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);

void CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);

void CVec_NodeAnnouncementZ_free(struct LDKCVec_NodeAnnouncementZ _res);

struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);

struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);

void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);

struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);

void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);

void CVec_u8Z_free(struct LDKCVec_u8Z _res);

struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);

struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);

void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);

struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);

struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);

struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);

void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);

struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);

struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);

struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);

void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);

struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);

struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);

struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);

struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);

struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);

struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);

struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);

struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(struct LDKInvoiceFeatures o);

struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceFeaturesDecodeErrorZ _res);

struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);

struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);

struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_ok(struct LDKDirectionalChannelInfo o);

struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_DirectionalChannelInfoDecodeErrorZ_free(struct LDKCResult_DirectionalChannelInfoDecodeErrorZ _res);

struct LDKCResult_DirectionalChannelInfoDecodeErrorZ CResult_DirectionalChannelInfoDecodeErrorZ_clone(const struct LDKCResult_DirectionalChannelInfoDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);

struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);

struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);

struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);

struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);

void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);

struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);

struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);

struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);

void CVec_u64Z_free(struct LDKCVec_u64Z _res);

struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);

struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);

struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);

struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);

struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_clone(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR orig);

struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);

void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);

void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);

struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_ok(void);

struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_err(enum LDKChannelMonitorUpdateErr e);

void CResult_NoneChannelMonitorUpdateErrZ_free(struct LDKCResult_NoneChannelMonitorUpdateErrZ _res);

struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_clone(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR orig);

void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);

void CVec_EventZ_free(struct LDKCVec_EventZ _res);

struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);

struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);

struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);

struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);

struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);

struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);

struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_NoneMonitorUpdateErrorZ CResult_NoneMonitorUpdateErrorZ_ok(void);

struct LDKCResult_NoneMonitorUpdateErrorZ CResult_NoneMonitorUpdateErrorZ_err(struct LDKMonitorUpdateError e);

void CResult_NoneMonitorUpdateErrorZ_free(struct LDKCResult_NoneMonitorUpdateErrorZ _res);

struct LDKCResult_NoneMonitorUpdateErrorZ CResult_NoneMonitorUpdateErrorZ_clone(const struct LDKCResult_NoneMonitorUpdateErrorZ *NONNULL_PTR orig);

struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(const struct LDKC2Tuple_OutPointScriptZ *NONNULL_PTR orig);

struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);

void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);

struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(const struct LDKC2Tuple_u32ScriptZ *NONNULL_PTR orig);

struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);

void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);

void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);

struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);

void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);

void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);

void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);

struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);

struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);

void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);

void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);

struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);

void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);

void CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ _res);

struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);

void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);

struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);

struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);

void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);

struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(struct LDKTxOut o);

struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(enum LDKAccessError e);

void CResult_TxOutAccessErrorZ_free(struct LDKCResult_TxOutAccessErrorZ _res);

struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR orig);

struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);

struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);

void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);

struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);

void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);

void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);

void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);

struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);

struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);

struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);

void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);

struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);

void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);

struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);

struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);

struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);

struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);

struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);

struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);

void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);

struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);

struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);

void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);

struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);

struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);

struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);

void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);

struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);

struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(struct LDKSign o);

struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_SignDecodeErrorZ_free(struct LDKCResult_SignDecodeErrorZ _res);

struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR orig);

void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);

struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);

struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);

void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);

struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);

struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);

struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);

struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);

void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);

struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);

struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);

void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);

void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);

void CVec_CVec_RouteHopZZ_free(struct LDKCVec_CVec_RouteHopZZ _res);

struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);

struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);

struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);

void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);

struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);

struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);

void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);

struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);

struct LDKCResult_NetAddressu8Z CResult_NetAddressu8Z_ok(struct LDKNetAddress o);

struct LDKCResult_NetAddressu8Z CResult_NetAddressu8Z_err(uint8_t e);

void CResult_NetAddressu8Z_free(struct LDKCResult_NetAddressu8Z _res);

struct LDKCResult_NetAddressu8Z CResult_NetAddressu8Z_clone(const struct LDKCResult_NetAddressu8Z *NONNULL_PTR orig);

struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ CResult_CResult_NetAddressu8ZDecodeErrorZ_ok(struct LDKCResult_NetAddressu8Z o);

struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ CResult_CResult_NetAddressu8ZDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_CResult_NetAddressu8ZDecodeErrorZ_free(struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ _res);

struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ CResult_CResult_NetAddressu8ZDecodeErrorZ_clone(const struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ *NONNULL_PTR orig);

void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);

void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);

void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);

void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);

struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);

struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);

struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);

struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);

struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);

struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);

struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);

struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);

struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);

struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);

struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);

struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);

struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);

struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);

struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_ok(struct LDKFundingLocked o);

struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_FundingLockedDecodeErrorZ_free(struct LDKCResult_FundingLockedDecodeErrorZ _res);

struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_clone(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);

struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);

struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);

struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);

struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);

struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);

struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);

struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);

struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);

struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);

struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);

struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);

struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);

struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);

struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);

struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);

struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);

struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);

struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);

struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);

struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);

struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);

struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);

struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);

struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);

struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);

struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);

struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);

struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);

struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);

struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);

struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);

struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);

struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);

struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);

struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);

struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);

struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);

struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);

struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);

struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);

struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);

struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);

struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);

struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);

struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);

struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);

void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);

struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees any resources used by the Event
 */
void Event_free(struct LDKEvent this_ptr);

/**
 * Creates a copy of the Event
 */
struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);

/**
 * Serialize the Event object into a byte array which can be read by Event_read
 */
struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);

/**
 * Frees any resources used by the MessageSendEvent
 */
void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);

/**
 * Creates a copy of the MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventsProvider_free(struct LDKEventsProvider this_ptr);

/**
 * Frees any resources used by the APIError
 */
void APIError_free(struct LDKAPIError this_ptr);

/**
 * Creates a copy of the APIError
 */
struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);

/**
 * Creates a copy of the Level
 */
enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);

/**
 * Returns the most verbose logging level.
 */
MUST_USE_RES enum LDKLevel Level_max(void);

/**
 * Calls the free function if one is set
 */
void Logger_free(struct LDKLogger this_ptr);

/**
 * Frees any resources used by the ChannelHandshakeConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * Default value: 6.
 */
uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * Default value: 6.
 */
void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to the amount of time we require our counterparty to wait to claim their money.
 *
 * It's one of the main parameter of our security model. We (or one of our watchtowers) MUST
 * be online to check for peer having broadcast a revoked transaction to steal our funds
 * at least once every our_to_self_delay blocks.
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: BREAKDOWN_TIMEOUT (currently 144), we enforce it as a minimum at channel
 * opening so you can tweak config to ask for more security, not less.
 */
uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the amount of time we require our counterparty to wait to claim their money.
 *
 * It's one of the main parameter of our security model. We (or one of our watchtowers) MUST
 * be online to check for peer having broadcast a revoked transaction to steal our funds
 * at least once every our_to_self_delay blocks.
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: BREAKDOWN_TIMEOUT (currently 144), we enforce it as a minimum at channel
 * opening so you can tweak config to ask for more security, not less.
 */
void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ChannelHandshakeConfig given each field
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg);

/**
 * Creates a copy of the ChannelHandshakeConfig
 */
struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeConfig. See other documentaiton for details on what this implies.
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

/**
 * Frees any resources used by the ChannelHandshakeLimits, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);

/**
 * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Minimum allowed satoshis when a channel is funded, this is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Outputs below a certain value will not be added to on-chain transactions. The dust value is
 * required to always be higher than this value so this only applies to HTLC outputs (and
 * potentially to-self outputs before any payments have been made).
 * Thus, HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain.
 * This setting allows you to set a minimum dust limit for their commitment transactions,
 * reflecting the reality that tiny outputs are not considered standard transactions and will
 * not propagate through the Bitcoin network.
 *
 * Default value: 546, the current dust limit on the Bitcoin network.
 */
uint64_t ChannelHandshakeLimits_get_min_dust_limit_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Outputs below a certain value will not be added to on-chain transactions. The dust value is
 * required to always be higher than this value so this only applies to HTLC outputs (and
 * potentially to-self outputs before any payments have been made).
 * Thus, HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain.
 * This setting allows you to set a minimum dust limit for their commitment transactions,
 * reflecting the reality that tiny outputs are not considered standard transactions and will
 * not propagate through the Bitcoin network.
 *
 * Default value: 546, the current dust limit on the Bitcoin network.
 */
void ChannelHandshakeLimits_set_min_dust_limit_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Maximum allowed threshold above which outputs will not be generated in their commitment
 * transactions.
 * HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain.
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_dust_limit_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Maximum allowed threshold above which outputs will not be generated in their commitment
 * transactions.
 * HTLCs below this amount plus HTLC transaction fees are not enforceable on-chain.
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_dust_limit_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to force the incoming channel to match our announced channel preference in
 * ChannelConfig.
 *
 * Default value: true, to make the default that no announced channels are possible (which is
 * appropriate for any nodes which are not online very reliably).
 */
bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to force the incoming channel to match our announced channel preference in
 * ChannelConfig.
 *
 * Default value: true, to make the default that no announced channels are possible (which is
 * appropriate for any nodes which are not online very reliably).
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new ChannelHandshakeLimits given each field
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint64_t min_dust_limit_satoshis_arg, uint64_t max_dust_limit_satoshis_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

/**
 * Creates a copy of the ChannelHandshakeLimits
 */
struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeLimits. See other documentaiton for details on what this implies.
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

/**
 * Frees any resources used by the ChannelConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelConfig_free(struct LDKChannelConfig this_obj);

/**
 * Amount (in millionths of a satoshi) the channel will charge per transferred satoshi.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
uint32_t ChannelConfig_get_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in millionths of a satoshi) the channel will charge per transferred satoshi.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
void ChannelConfig_set_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless ChannelHandshakeLimits::force_announced_channel_preferences is set.
 *
 * This cannot be changed after the initial channel handshake.
 *
 * Default value: false.
 */
bool ChannelConfig_get_announced_channel(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless ChannelHandshakeLimits::force_announced_channel_preferences is set.
 *
 * This cannot be changed after the initial channel handshake.
 *
 * Default value: false.
 */
void ChannelConfig_set_announced_channel(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * This cannot be changed after a channel has been initialized.
 *
 * Default value: true.
 */
bool ChannelConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * This cannot be changed after a channel has been initialized.
 *
 * Default value: true.
 */
void ChannelConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ChannelConfig given each field
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t fee_proportional_millionths_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg);

/**
 * Creates a copy of the ChannelConfig
 */
struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelConfig. See other documentaiton for details on what this implies.
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);

/**
 * Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
 */
struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);

/**
 * Read a ChannelConfig from a byte array, created by ChannelConfig_write
 */
struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UserConfig, if is_owned is set and inner is non-NULL.
 */
void UserConfig_free(struct LDKUserConfig this_obj);

/**
 * Channel config that we propose to our counterparty.
 */
struct LDKChannelHandshakeConfig UserConfig_get_own_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config that we propose to our counterparty.
 */
void UserConfig_set_own_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);

/**
 * Limits applied to our counterparty's proposed channel config settings.
 */
struct LDKChannelHandshakeLimits UserConfig_get_peer_channel_config_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Limits applied to our counterparty's proposed channel config settings.
 */
void UserConfig_set_peer_channel_config_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);

/**
 * Channel config which affects behavior during channel lifetime.
 */
struct LDKChannelConfig UserConfig_get_channel_options(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config which affects behavior during channel lifetime.
 */
void UserConfig_set_channel_options(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * Constructs a new UserConfig given each field
 */
MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig own_channel_config_arg, struct LDKChannelHandshakeLimits peer_channel_config_limits_arg, struct LDKChannelConfig channel_options_arg);

/**
 * Creates a copy of the UserConfig
 */
struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);

/**
 * Creates a "default" UserConfig. See other documentaiton for details on what this implies.
 */
MUST_USE_RES struct LDKUserConfig UserConfig_default(void);

/**
 * Creates a copy of the AccessError
 */
enum LDKAccessError AccessError_clone(const enum LDKAccessError *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Access_free(struct LDKAccess this_ptr);

/**
 * Calls the free function if one is set
 */
void Listen_free(struct LDKListen this_ptr);

/**
 * Calls the free function if one is set
 */
void Watch_free(struct LDKWatch this_ptr);

/**
 * Calls the free function if one is set
 */
void Filter_free(struct LDKFilter this_ptr);

/**
 * Calls the free function if one is set
 */
void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);

/**
 * Creates a copy of the ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void FeeEstimator_free(struct LDKFeeEstimator this_ptr);

/**
 * Frees any resources used by the ChainMonitor, if is_owned is set and inner is non-NULL.
 */
void ChainMonitor_free(struct LDKChainMonitor this_obj);

/**
 * Dispatches to per-channel monitors, which are responsible for updating their on-chain view
 * of a channel and reacting accordingly based on transactions in the connected block. See
 * [`ChannelMonitor::block_connected`] for details. Any HTLCs that were resolved on chain will
 * be returned by [`chain::Watch::release_pending_monitor_events`].
 *
 * Calls back to [`chain::Filter`] if any monitor indicated new outputs to watch. Subsequent
 * calls must not exclude any transactions matching the new outputs nor any in-block
 * descendants of such transactions. It is not necessary to re-fetch the block to obtain
 * updated `txdata`.
 *
 * [`ChannelMonitor::block_connected`]: ../channelmonitor/struct.ChannelMonitor.html#method.block_connected
 * [`chain::Watch::release_pending_monitor_events`]: ../trait.Watch.html#tymethod.release_pending_monitor_events
 * [`chain::Filter`]: ../trait.Filter.html
 */
void ChainMonitor_block_connected(const struct LDKChainMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);

/**
 * Dispatches to per-channel monitors, which are responsible for updating their on-chain view
 * of a channel based on the disconnected block. See [`ChannelMonitor::block_disconnected`] for
 * details.
 *
 * [`ChannelMonitor::block_disconnected`]: ../channelmonitor/struct.ChannelMonitor.html#method.block_disconnected
 */
void ChainMonitor_block_disconnected(const struct LDKChainMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t disconnected_height);

/**
 * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
 *
 * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
 * will call back to it indicating transactions and outputs of interest. This allows clients to
 * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
 * always need to fetch full blocks absent another means for determining which blocks contain
 * transactions relevant to the watched channels.
 *
 * [`chain::Filter`]: ../trait.Filter.html
 */
MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKFilter *chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);

/**
 * Constructs a new Watch which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
 */
struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 *
 * [`CLOSED_CHANNEL_UPDATE_ID`]: constant.CLOSED_CHANNEL_UPDATE_ID.html
 */
uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with one exception specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instance where update_id values are not strictly increasing is the case where we
 * allow post-force-close updates with a special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. See
 * its docs for more details.
 *
 * [`CLOSED_CHANNEL_UPDATE_ID`]: constant.CLOSED_CHANNEL_UPDATE_ID.html
 */
void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelMonitorUpdate
 */
struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
 */
struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);

/**
 * Creates a copy of the ChannelMonitorUpdateErr
 */
enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_clone(const enum LDKChannelMonitorUpdateErr *NONNULL_PTR orig);

/**
 * Frees any resources used by the MonitorUpdateError, if is_owned is set and inner is non-NULL.
 */
void MonitorUpdateError_free(struct LDKMonitorUpdateError this_obj);

/**
 * Creates a copy of the MonitorUpdateError
 */
struct LDKMonitorUpdateError MonitorUpdateError_clone(const struct LDKMonitorUpdateError *NONNULL_PTR orig);

/**
 * Frees any resources used by the MonitorEvent
 */
void MonitorEvent_free(struct LDKMonitorEvent this_ptr);

/**
 * Creates a copy of the MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);

/**
 * Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
 */
void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);

/**
 * Creates a copy of the HTLCUpdate
 */
struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);

/**
 * Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
 */
struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);

/**
 * Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitor_free(struct LDKChannelMonitor this_obj);

/**
 * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
 */
struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);

/**
 * Updates a ChannelMonitor on the basis of some new information provided by the Channel
 * itself.
 *
 * panics if the given update is not the next update by update_id.
 */
MUST_USE_RES struct LDKCResult_NoneMonitorUpdateErrorZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
 * ChannelMonitor.
 */
MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
 */
MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets a list of txids, with their output scripts (in the order they appear in the
 * transaction), which we must learn about spends of via block_connected().
 */
MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
 * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
 * have been registered.
 */
void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);

/**
 * Get the list of HTLCs who's status has been updated on chain. This should be called by
 * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
 *
 * [`chain::Watch::release_pending_monitor_events`]: ../trait.Watch.html#tymethod.release_pending_monitor_events
 */
MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the list of pending events which were generated by previous actions, clearing the list
 * in the process.
 *
 * This is called by ChainMonitor::get_and_clear_pending_events() and is equivalent to
 * EventsProvider::get_and_clear_pending_events() except that it requires &mut self as we do
 * no internal locking in ChannelMonitors.
 */
MUST_USE_RES struct LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Used by ChannelManager deserialization to broadcast the latest holder state if its copy of
 * the Channel was out-of-date. You may use it to get a broadcastable holder toxic tx in case of
 * fallen-behind, i.e when receiving a channel_reestablish with a proof that our counterparty side knows
 * a higher revocation secret than the holder commitment number we are aware of. Broadcasting these
 * transactions are UNSAFE, as they allow counterparty side to punish you. Nevertheless you may want to
 * broadcast them if counterparty don't close channel with his higher commitment transaction after a
 * substantial amount of time (a month or even a year) to get back funds. Best may be to contact
 * out-of-band the other node operator to coordinate with him if option is available to you.
 * In any-case, choice is up to the user.
 */
MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Processes transactions in a newly connected block, which may result in any of the following:
 * - update the monitor's state against resolved HTLCs
 * - punish the counterparty in the case of seeing a revoked commitment transaction
 * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
 * - detect settled outputs for later spending
 * - schedule and bump any in-flight claims
 *
 * Returns any new outputs to watch from `txdata`; after called, these are also included in
 * [`get_outputs_to_watch`].
 *
 * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
 */
MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Determines if the disconnected block contained any transactions of interest and updates
 * appropriately.
 */
void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Calls the free function if one is set
 */
void Persist_free(struct LDKPersist this_ptr);

/**
 * Read a C2Tuple_BlockHashChannelMonitorZ from a byte array, created by C2Tuple_BlockHashChannelMonitorZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKKeysInterface *NONNULL_PTR arg);

/**
 * Frees any resources used by the OutPoint, if is_owned is set and inner is non-NULL.
 */
void OutPoint_free(struct LDKOutPoint this_obj);

/**
 * The referenced transaction's txid.
 */
const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];

/**
 * The referenced transaction's txid.
 */
void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The index of the referenced output in its transaction's vout.
 */
uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);

/**
 * The index of the referenced output in its transaction's vout.
 */
void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new OutPoint given each field
 */
MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);

/**
 * Creates a copy of the OutPoint
 */
struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);

/**
 * Convert an `OutPoint` to a lightning channel id.
 */
MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);

/**
 * Serialize the OutPoint object into a byte array which can be read by OutPoint_read
 */
struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);

/**
 * Read a OutPoint from a byte array, created by OutPoint_write
 */
struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DelayedPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable
 */
struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable
 */
void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Per commitment point to derive delayed_payment_key by key holder
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * Per commitment point to derive delayed_payment_key by key holder
 */
void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
 * the witness_script.
 */
uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The nSequence value which must be set in the spending input to satisfy the OP_CSV in
 * the witness_script.
 */
void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The output which is referenced by the given outpoint
 */
void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new DelayedPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the DelayedPaymentOutputDescriptor
 */
struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Frees any resources used by the StaticPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable
 */
struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable
 */
void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The output which is referenced by the given outpoint
 */
void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to
 * `Sign::channel_keys_id()`. This may be useful in re-deriving keys used in
 * the channel to spend the output.
 */
void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this transactions spends.
 */
uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this transactions spends.
 */
void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new StaticPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the StaticPaymentOutputDescriptor
 */
struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Frees any resources used by the SpendableOutputDescriptor
 */
void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);

/**
 * Creates a copy of the SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);

/**
 * Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
 */
struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Creates a copy of a Sign
 */
struct LDKSign Sign_clone(const struct LDKSign *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Sign_free(struct LDKSign this_ptr);

/**
 * Calls the free function if one is set
 */
void KeysInterface_free(struct LDKKeysInterface this_ptr);

/**
 * Frees any resources used by the InMemorySigner, if is_owned is set and inner is non-NULL.
 */
void InMemorySigner_free(struct LDKInMemorySigner this_obj);

/**
 * Private key of anchor tx
 */
const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Private key of anchor tx
 */
void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key for blinded revocation pubkey
 */
const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key for blinded revocation pubkey
 */
void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
 */
const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions
 */
void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used in HTLC tx
 */
const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used in HTLC tx
 */
void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder htlc secret key used in commitment tx htlc outputs
 */
const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder htlc secret key used in commitment tx htlc outputs
 */
void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Commitment seed
 */
const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Commitment seed
 */
void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Creates a copy of the InMemorySigner
 */
struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);

/**
 * Create a new InMemorySigner
 */
MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);

/**
 * Counterparty pubkeys.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * The contest_delay value specified by our counterparty and applied on holder-broadcastable
 * transactions, ie the amount of time that we have to wait to recover our funds if we
 * broadcast a transaction.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * The contest_delay value specified by us and applied on transactions broadcastable
 * by our counterparty, ie the amount of time that they have to wait to recover their funds
 * if they broadcast a transaction.
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Whether the holder is the initiator
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Funding outpoint
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Obtain a ChannelTransactionParameters for this channel, to be used when verifying or
 * building transactions.
 *
 * Will panic if ready_channel wasn't called.
 */
MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Sign the single input of spend_tx at index `input_idx` which spends the output
 * described by descriptor, returning the witness stack for the input.
 *
 * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
 * or is not spending the outpoint described by `descriptor.outpoint`.
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Sign the single input of spend_tx at index `input_idx` which spends the output
 * described by descriptor, returning the witness stack for the input.
 *
 * Returns an Err if the input at input_idx does not exist, has a non-empty script_sig,
 * is not spending the outpoint described by `descriptor.outpoint`, or does not have a
 * sequence set to `descriptor.to_self_delay`.
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Constructs a new Sign which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Sign must be freed before this_arg is
 */
struct LDKSign InMemorySigner_as_Sign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
 */
struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);

/**
 * Read a InMemorySigner from a byte array, created by InMemorySigner_write
 */
struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the KeysManager, if is_owned is set and inner is non-NULL.
 */
void KeysManager_free(struct LDKKeysManager this_obj);

/**
 * Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
 * CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
 * starting_time isn't strictly required to actually be a time, but it must absolutely,
 * without a doubt, be unique to this instance. ie if you start multiple times with the same
 * seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
 * simply use the current time (with very high precision).
 *
 * The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
 * obviously, starting_time should be unique every time you reload the library - it is only
 * used to generate new ephemeral key data (which will be stored by the individual channel if
 * necessary).
 *
 * Note that the seed is required to recover certain on-chain funds independent of
 * ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
 * channel, and some on-chain during-closing funds.
 *
 * Note that until the 0.1 release there is no guarantee of backward compatibility between
 * versions. Once the library is more fully supported, the docs will be updated to include a
 * detailed description of the guarantee.
 */
MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);

/**
 * Derive an old Sign containing per-channel secrets based on a key derivation parameters.
 *
 * Key derivation parameters are accessible through a per-channel secrets
 * Sign::channel_keys_id and is provided inside DynamicOuputP2WSH in case of
 * onchain output detection for which a corresponding delayed_payment_key must be derived.
 */
MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Creates a Transaction which spends the given descriptors to the given outputs, plus an
 * output to the given change destination (if sufficient change value remains). The
 * transaction will have a feerate, at least, of the given value.
 *
 * Returns `Err(())` if the output value is greater than the input value minus required fee or
 * if a descriptor was duplicated.
 *
 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
 *
 * May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
 * this KeysManager or one of the `InMemorySigner` created by this KeysManager.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);

/**
 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
 */
struct LDKKeysInterface KeysManager_as_KeysInterface(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
 */
void ChannelManager_free(struct LDKChannelManager this_obj);

/**
 * Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
 */
void ChainParameters_free(struct LDKChainParameters this_obj);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);

/**
 * The hash of the latest block successfully connected.
 */
const uint8_t (*ChainParameters_get_latest_hash(const struct LDKChainParameters *NONNULL_PTR this_ptr))[32];

/**
 * The hash of the latest block successfully connected.
 */
void ChainParameters_set_latest_hash(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
uintptr_t ChainParameters_get_latest_height(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
void ChainParameters_set_latest_height(struct LDKChainParameters *NONNULL_PTR this_ptr, uintptr_t val);

/**
 * Constructs a new ChainParameters given each field
 */
MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKThirtyTwoBytes latest_hash_arg, uintptr_t latest_height_arg);

/**
 * Frees any resources used by the ChannelDetails, if is_owned is set and inner is non-NULL.
 */
void ChannelDetails_free(struct LDKChannelDetails this_obj);

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The node_id of our counterparty
 */
struct LDKPublicKey ChannelDetails_get_remote_network_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The node_id of our counterparty
 */
void ChannelDetails_set_remote_network_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
struct LDKInitFeatures ChannelDetails_get_counterparty_features(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
void ChannelDetails_set_counterparty_features(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The user_id passed in to create_channel, or 0 if the channel was inbound.
 */
uint64_t ChannelDetails_get_user_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The user_id passed in to create_channel, or 0 if the channel was inbound.
 */
void ChannelDetails_set_user_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 */
uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 */
void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 */
uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, who's balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 */
void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
 * the peer is connected, and (c) no monitor update failure is pending resolution.
 */
bool ChannelDetails_get_is_live(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is (a) confirmed and funding_locked messages have been exchanged, (b)
 * the peer is connected, and (c) no monitor update failure is pending resolution.
 */
void ChannelDetails_set_is_live(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * Creates a copy of the ChannelDetails
 */
struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);

/**
 * Frees any resources used by the PaymentSendFailure
 */
void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);

/**
 * Creates a copy of the PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);

/**
 * Constructs a new ChannelManager to hold several channels and route between them.
 *
 * This is the main \"logic hub\" for all channel-related actions, and implements
 * ChannelMessageHandler.
 *
 * Non-proportional fees are fixed according to our risk using the provided fee estimator.
 *
 * panics if channel_value_satoshis is >= `MAX_FUNDING_SATOSHIS`!
 *
 * Users need to notify the new ChannelManager when a new block is connected or
 * disconnected using its `block_connected` and `block_disconnected` methods, starting
 * from after `params.latest_hash`.
 */
MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKKeysInterface keys_manager, struct LDKUserConfig config, struct LDKChainParameters params);

/**
 * Creates a new outbound channel to the given remote node and with the given value.
 *
 * user_id will be provided back as user_channel_id in FundingGenerationReady and
 * FundingBroadcastSafe events to allow tracking of which events correspond with which
 * create_channel call. Note that user_channel_id defaults to 0 for inbound channels, so you
 * may wish to avoid using 0 for user_id here.
 *
 * If successful, will generate a SendOpenChannel message event, so you should probably poll
 * PeerManager::process_events afterwards.
 *
 * Raises APIError::APIMisuseError when channel_value_satoshis > 2**24 or push_msat is
 * greater than channel_value_satoshis * 1k or channel_value_satoshis is < 1000.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_id, struct LDKUserConfig override_config);

/**
 * Gets the list of open channels, in random order. See ChannelDetail field documentation for
 * more information.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the list of usable channels, in random order. Useful as an argument to
 * get_route to ensure non-announced channels are used.
 *
 * These are guaranteed to have their is_live value set to true, see the documentation for
 * ChannelDetails::is_live for more info on exactly what the criteria are.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 * May generate a SendShutdown message event on success, which should be relayed.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);

/**
 * Force closes a channel, immediately broadcasting the latest local commitment transaction to
 * the chain and rejecting new HTLCs on the given channel. Fails if channel_id is unknown to the manager.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);

/**
 * Force close all channels, immediately broadcasting the latest local commitment transaction
 * for each to the chain and rejecting new HTLCs on each.
 */
void ChannelManager_force_close_all_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Sends a payment along a given route.
 *
 * Value parameters are provided via the last hop in route, see documentation for RouteHop
 * fields for more info.
 *
 * Note that if the payment_hash already exists elsewhere (eg you're sending a duplicative
 * payment), we don't do anything to stop you! We always try to ensure that if the provided
 * next hop knows the preimage to payment_hash they can claim an additional amount as
 * specified in the last hop in the route! Thus, you should probably do your own
 * payment_preimage tracking (which you should already be doing as they represent \"proof of
 * payment\") and prevent double-sends yourself.
 *
 * May generate SendHTLCs message(s) event on success, which should be relayed.
 *
 * Each path may have a different return value, and PaymentSendValue may return a Vec with
 * each entry matching the corresponding-index entry in the route paths, see
 * PaymentSendFailure for more info.
 *
 * In general, a path may raise:
 *  * APIError::RouteError when an invalid route or forwarding parameter (cltv_delta, fee,
 *    node public key) is specified.
 *  * APIError::ChannelUnavailable if the next-hop channel is not available for updates
 *    (including due to previous monitor update failure or new permanent monitor update
 *    failure).
 *  * APIError::MonitorUpdateFailed if a new monitor update failure prevented sending the
 *    relevant updates.
 *
 * Note that depending on the type of the PaymentSendFailure the HTLC may have been
 * irrevocably committed to on our end. In such a case, do NOT retry the payment with a
 * different route unless you intend to pay twice!
 *
 * payment_secret is unrelated to payment_hash (or PaymentPreimage) and exists to authenticate
 * the sender to the recipient and prevent payment-probing (deanonymization) attacks. For
 * newer nodes, it will be provided to you in the invoice. If you do not have one, the Route
 * must not contain multiple paths as multi-path payments require a recipient-provided
 * payment_secret.
 * If a payment_secret *is* provided, we assume that the invoice had the payment_secret feature
 * bit set (either as required or as available). If multiple paths are present in the Route,
 * we assume the invoice had the basic_mpp feature set.
 */
MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);

/**
 * Call this upon creation of a funding transaction for the given channel.
 *
 * Note that ALL inputs in the transaction pointed to by funding_txo MUST spend SegWit outputs
 * or your counterparty can steal your funds!
 *
 * Panics if a funding transaction has already been provided for this channel.
 *
 * May panic if the funding_txo is duplicative with some other channel (note that this should
 * be trivially prevented by using unique funding transaction keys per-channel).
 */
void ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKOutPoint funding_txo);

/**
 * Generates a signed node_announcement from the given arguments and creates a
 * BroadcastNodeAnnouncement event. Note that such messages will be ignored unless peers have
 * seen a channel_announcement from us (ie unless we have public channels open).
 *
 * RGB is a node \"color\" and alias is a printable human-readable string to describe this node
 * to humans. They carry no in-protocol meaning.
 *
 * addresses represent the set (possibly empty) of socket addresses on which this node accepts
 * incoming connections. These will be broadcast to the network, publicly tying these
 * addresses together. If you wish to preserve user privacy, addresses should likely contain
 * only Tor Onion addresses.
 *
 * Panics if addresses is absurdly large (more than 500).
 */
void ChannelManager_broadcast_node_announcement(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);

/**
 * Processes HTLCs which are pending waiting on random forward delay.
 *
 * Should only really ever be called in response to a PendingHTLCsForwardable event.
 * Will likely generate further events.
 */
void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * If a peer is disconnected we mark any channels with that peer as 'disabled'.
 * After some time, if channels are still disabled we need to broadcast a ChannelUpdate
 * to inform the network about the uselessness of these channels.
 *
 * This method handles all the details, and must be called roughly once per minute.
 *
 * Note that in some rare cases this may generate a `chain::Watch::update_channel` call.
 */
void ChannelManager_timer_chan_freshness_every_min(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
 * after a PaymentReceived event, failing the HTLC back to its origin and freeing resources
 * along the path (including in our own channel on which we received it).
 * Returns false if no payment was found to fail backwards, true if the process of failing the
 * HTLC backwards has been started.
 */
MUST_USE_RES bool ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32], struct LDKThirtyTwoBytes payment_secret);

/**
 * Provides a payment preimage in response to a PaymentReceived event, returning true and
 * generating message events for the net layer to claim the payment, if possible. Thus, you
 * should probably kick the net layer to go send messages if this returns true!
 *
 * You must specify the expected amounts for this HTLC, and we will only claim HTLCs
 * available within a few percent of the expected amount. This is critical for several
 * reasons : a) it avoids providing senders with `proof-of-payment` (in the form of the
 * payment_preimage without having provided the full value and b) it avoids certain
 * privacy-breaking recipient-probing attacks which may reveal payment activity to
 * motivated attackers.
 *
 * Note that the privacy concerns in (b) are not relevant in payments with a payment_secret
 * set. Thus, for such payments we will claim any payments which do not under-pay.
 *
 * May panic if called except in response to a PaymentReceived event.
 */
MUST_USE_RES bool ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_secret, uint64_t expected_amount);

/**
 * Gets the node_id held by this ChannelManager
 */
MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Restores a single, given channel to normal operation after a
 * ChannelMonitorUpdateErr::TemporaryFailure was returned from a channel monitor update
 * operation.
 *
 * All ChannelMonitor updates up to and including highest_applied_update_id must have been
 * fully committed in every copy of the given channels' ChannelMonitors.
 *
 * Note that there is no effect to calling with a highest_applied_update_id other than the
 * current latest ChannelMonitorUpdate and one call to this function after multiple
 * ChannelMonitorUpdateErr::TemporaryFailures is fine. The highest_applied_update_id field
 * exists largely only to prevent races between this and concurrent update_monitor calls.
 *
 * Thus, the anticipated use is, at a high level:
 *  1) You register a chain::Watch with this ChannelManager,
 *  2) it stores each update to disk, and begins updating any remote (eg watchtower) copies of
 *     said ChannelMonitors as it can, returning ChannelMonitorUpdateErr::TemporaryFailures
 *     any time it cannot do so instantly,
 *  3) update(s) are applied to each remote copy of a ChannelMonitor,
 *  4) once all remote copies are updated, you call this function with the update_id that
 *     completed, and once it is the latest the Channel will be re-enabled.
 */
void ChannelManager_channel_monitor_updated(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKOutPoint *NONNULL_PTR funding_txo, uint64_t highest_applied_update_id);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Updates channel state based on transactions seen in a connected block.
 */
void ChannelManager_block_connected(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);

/**
 * Updates channel state based on a disconnected block.
 *
 * If necessary, the channel may be force-closed without letting the counterparty participate
 * in the shutdown.
 */
void ChannelManager_block_disconnected(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*header)[80]);

/**
 * Blocks until ChannelManager needs to be persisted. Only one listener on
 * `await_persistable_update` or `await_persistable_update_timeout` is guaranteed to be woken
 * up.
 */
void ChannelManager_await_persistable_update(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
 */
struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);

/**
 * Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
 */
void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
const struct LDKKeysInterface *ChannelManagerReadArgs_get_keys_manager(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
void ChannelManagerReadArgs_set_keys_manager(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKKeysInterface val);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);

/**
 * Simple utility function to create a ChannelManagerReadArgs which creates the monitor
 * HashMap for you. This is primarily useful for C bindings where it is not practical to
 * populate a HashMap directly from C.
 */
MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKKeysInterface keys_manager, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);

/**
 * Read a C2Tuple_BlockHashChannelManagerZ from a byte array, created by C2Tuple_BlockHashChannelManagerZ_write
 */
struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);

/**
 * Frees any resources used by the DecodeError, if is_owned is set and inner is non-NULL.
 */
void DecodeError_free(struct LDKDecodeError this_obj);

/**
 * Creates a copy of the DecodeError
 */
struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);

/**
 * Frees any resources used by the Init, if is_owned is set and inner is non-NULL.
 */
void Init_free(struct LDKInit this_obj);

/**
 * The relevant features which the sender supports
 */
struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The relevant features which the sender supports
 */
void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * Constructs a new Init given each field
 */
MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg);

/**
 * Creates a copy of the Init
 */
struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErrorMessage, if is_owned is set and inner is non-NULL.
 */
void ErrorMessage_free(struct LDKErrorMessage this_obj);

/**
 * The channel ID involved in the error
 */
const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the error
 */
void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs
 * or printed to stdout).  Otherwise, a well crafted error message may trigger a security
 * vulnerability in the terminal emulator or the logging subsystem.
 */
struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable error description.
 * The string should be sanitized before it is used (e.g. emitted to logs
 * or printed to stdout).  Otherwise, a well crafted error message may trigger a security
 * vulnerability in the terminal emulator or the logging subsystem.
 */
void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new ErrorMessage given each field
 */
MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z data_arg);

/**
 * Creates a copy of the ErrorMessage
 */
struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);

/**
 * Frees any resources used by the Ping, if is_owned is set and inner is non-NULL.
 */
void Ping_free(struct LDKPing this_obj);

/**
 * The desired response length
 */
uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The desired response length
 */
void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The ping packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Ping given each field
 */
MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);

/**
 * Creates a copy of the Ping
 */
struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);

/**
 * Frees any resources used by the Pong, if is_owned is set and inner is non-NULL.
 */
void Pong_free(struct LDKPong this_obj);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);

/**
 * The pong packet size.
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Pong given each field
 */
MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);

/**
 * Creates a copy of the Pong
 */
struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);

/**
 * Frees any resources used by the OpenChannel, if is_owned is set and inner is non-NULL.
 */
void OpenChannel_free(struct LDKOpenChannel this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The channel value
 */
uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel value
 */
void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by update_fee
 */
void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender
 */
struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender
 */
void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Channel flags
 */
uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);

/**
 * Creates a copy of the OpenChannel
 */
struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);

/**
 * Frees any resources used by the AcceptChannel, if is_owned is set and inner is non-NULL.
 */
void AcceptChannel_free(struct LDKAcceptChannel this_obj);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the AcceptChannel
 */
struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingCreated, if is_owned is set and inner is non-NULL.
 */
void FundingCreated_free(struct LDKFundingCreated this_obj);

/**
 * A temporary channel ID, until the funding is established
 */
const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding is established
 */
void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The funding transaction ID
 */
const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * The funding transaction ID
 */
void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The specific output index funding this channel
 */
uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The specific output index funding this channel
 */
void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The signature of the channel initiator (funder) on the funding transaction
 */
struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The signature of the channel initiator (funder) on the funding transaction
 */
void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingCreated given each field
 */
MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingCreated
 */
struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingSigned, if is_owned is set and inner is non-NULL.
 */
void FundingSigned_free(struct LDKFundingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The signature of the channel acceptor (fundee) on the funding transaction
 */
struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);

/**
 * The signature of the channel acceptor (fundee) on the funding transaction
 */
void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new FundingSigned given each field
 */
MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the FundingSigned
 */
struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the FundingLocked, if is_owned is set and inner is non-NULL.
 */
void FundingLocked_free(struct LDKFundingLocked this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingLocked_get_channel_id(const struct LDKFundingLocked *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingLocked_set_channel_id(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The per-commitment point of the second commitment transaction
 */
struct LDKPublicKey FundingLocked_get_next_per_commitment_point(const struct LDKFundingLocked *NONNULL_PTR this_ptr);

/**
 * The per-commitment point of the second commitment transaction
 */
void FundingLocked_set_next_per_commitment_point(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new FundingLocked given each field
 */
MUST_USE_RES struct LDKFundingLocked FundingLocked_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the FundingLocked
 */
struct LDKFundingLocked FundingLocked_clone(const struct LDKFundingLocked *NONNULL_PTR orig);

/**
 * Frees any resources used by the Shutdown, if is_owned is set and inner is non-NULL.
 */
void Shutdown_free(struct LDKShutdown this_obj);

/**
 * The channel ID
 */
const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);

/**
 * The destination of this peer's funds on closing.
 * Must be in one of these forms: p2pkh, p2sh, p2wpkh, p2wsh.
 */
void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new Shutdown given each field
 */
MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);

/**
 * Creates a copy of the Shutdown
 */
struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);

/**
 * Frees any resources used by the ClosingSigned, if is_owned is set and inner is non-NULL.
 */
void ClosingSigned_free(struct LDKClosingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The proposed total fee for the closing transaction
 */
uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The proposed total fee for the closing transaction
 */
void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature on the closing transaction
 */
struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the closing transaction
 */
void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new ClosingSigned given each field
 */
MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg);

/**
 * Creates a copy of the ClosingSigned
 */
struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateAddHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The HTLC value in milli-satoshi
 */
uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC value in milli-satoshi
 */
void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The expiry height of the HTLC
 */
uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The expiry height of the HTLC
 */
void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UpdateAddHTLC
 */
struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFulfillHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new UpdateFulfillHTLC given each field
 */
MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);

/**
 * Creates a copy of the UpdateFulfillHTLC
 */
struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFailHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the UpdateFailHTLC
 */
struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFailMalformedHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The failure code
 */
uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The failure code
 */
void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Creates a copy of the UpdateFailMalformedHTLC
 */
struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentSigned, if is_owned is set and inner is non-NULL.
 */
void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A signature on the commitment transaction
 */
struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the commitment transaction
 */
void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Signatures on the HTLC transactions
 */
void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Constructs a new CommitmentSigned given each field
 */
MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);

/**
 * Creates a copy of the CommitmentSigned
 */
struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);

/**
 * Frees any resources used by the RevokeAndACK, if is_owned is set and inner is non-NULL.
 */
void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);

/**
 * The channel ID
 */
const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The secret corresponding to the per-commitment point
 */
const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The secret corresponding to the per-commitment point
 */
void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new RevokeAndACK given each field
 */
MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the RevokeAndACK
 */
struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);

/**
 * Frees any resources used by the UpdateFee, if is_owned is set and inner is non-NULL.
 */
void UpdateFee_free(struct LDKUpdateFee this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Fee rate per 1000-weight of the transaction
 */
uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);

/**
 * Fee rate per 1000-weight of the transaction
 */
void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new UpdateFee given each field
 */
MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);

/**
 * Creates a copy of the UpdateFee
 */
struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);

/**
 * Frees any resources used by the DataLossProtect, if is_owned is set and inner is non-NULL.
 */
void DataLossProtect_free(struct LDKDataLossProtect this_obj);

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
const uint8_t (*DataLossProtect_get_your_last_per_commitment_secret(const struct LDKDataLossProtect *NONNULL_PTR this_ptr))[32];

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
void DataLossProtect_set_your_last_per_commitment_secret(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
struct LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(const struct LDKDataLossProtect *NONNULL_PTR this_ptr);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
void DataLossProtect_set_my_current_per_commitment_point(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new DataLossProtect given each field
 */
MUST_USE_RES struct LDKDataLossProtect DataLossProtect_new(struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg);

/**
 * Creates a copy of the DataLossProtect
 */
struct LDKDataLossProtect DataLossProtect_clone(const struct LDKDataLossProtect *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelReestablish, if is_owned is set and inner is non-NULL.
 */
void ChannelReestablish_free(struct LDKChannelReestablish this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next commitment number for the sender
 */
uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the sender
 */
void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The next commitment number for the recipient
 */
uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the recipient
 */
void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelReestablish
 */
struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);

/**
 * Frees any resources used by the AnnouncementSignatures, if is_owned is set and inner is non-NULL.
 */
void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);

/**
 * The channel ID
 */
const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature by the node key
 */
struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the node key
 */
void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * A signature by the funding key
 */
struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the funding key
 */
void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Constructs a new AnnouncementSignatures given each field
 */
MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);

/**
 * Creates a copy of the AnnouncementSignatures
 */
struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the NetAddress
 */
void NetAddress_free(struct LDKNetAddress this_ptr);

/**
 * Creates a copy of the NetAddress
 */
struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);

/**
 * Serialize the NetAddress object into a byte array which can be read by NetAddress_read
 */
struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);

/**
 * Read a Result from a byte array, created by Result_write
 */
struct LDKCResult_CResult_NetAddressu8ZDecodeErrorZ Result_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UnsignedNodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);

/**
 * The advertised features
 */
struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised features
 */
void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
struct LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The node_id this announcement originated from (don't rebroadcast the node_announcement back
 * to this node).
 */
void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * An RGB color for UI purposes
 */
const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];

/**
 * An RGB color for UI purposes
 */
void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
const uint8_t (*UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * An alias, for UI purposes.  This should be sanitized before use.  There is no guarantee
 * of uniqueness.
 */
void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * List of addresses on which this node is reachable
 */
void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * Creates a copy of the UnsignedNodeAnnouncement
 */
struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the NodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);

/**
 * The signature by the node key
 */
struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The signature by the node key
 */
void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual content of the announcement
 */
struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual content of the announcement
 */
void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncement given each field
 */
MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);

/**
 * Creates a copy of the NodeAnnouncement
 */
struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the UnsignedChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);

/**
 * The advertised channel features
 */
struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised channel features
 */
void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);

/**
 * One of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * One of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The other of the two node_ids which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the first node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the first node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The funding key for the second node
 */
struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the second node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Creates a copy of the UnsignedChannelAnnouncement
 */
struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);

/**
 * Authentication of the announcement by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the first public node
 */
void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Authentication of the announcement by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the second public node
 */
void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the first public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the first public node
 */
void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * Proof of funding UTXO ownership by the second public node
 */
struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the second public node
 */
void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual announcement
 */
struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual announcement
 */
void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);

/**
 * Constructs a new ChannelAnnouncement given each field
 */
MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);

/**
 * Creates a copy of the ChannelAnnouncement
 */
struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);

/**
 * Frees any resources used by the UnsignedChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Channel flags
 */
uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The number of blocks to subtract from incoming HTLC cltv_expiry values
 */
uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The number of blocks to subtract from incoming HTLC cltv_expiry values
 */
void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the UnsignedChannelUpdate
 */
struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdate_free(struct LDKChannelUpdate this_obj);

/**
 * A signature of the channel update
 */
struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A signature of the channel update
 */
void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * The actual channel update
 */
struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The actual channel update
 */
void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);

/**
 * Constructs a new ChannelUpdate given each field
 */
MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);

/**
 * Creates a copy of the ChannelUpdate
 */
struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the QueryChannelRange, if is_owned is set and inner is non-NULL.
 */
void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block for the channel UTXOs being queried
 */
uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block for the channel UTXOs being queried
 */
void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks to include in the query results
 */
uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks to include in the query results
 */
void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new QueryChannelRange given each field
 */
MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);

/**
 * Creates a copy of the QueryChannelRange
 */
struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReplyChannelRange, if is_owned is set and inner is non-NULL.
 */
void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block in the range of the reply
 */
uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block in the range of the reply
 */
void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks included in the range of the reply
 */
uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks included in the range of the reply
 */
void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * True when this is the final reply for a query
 */
bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * True when this is the final reply for a query
 */
void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);

/**
 * The short_channel_ids in the channel range
 */
void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new ReplyChannelRange given each field
 */
MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the ReplyChannelRange
 */
struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);

/**
 * Frees any resources used by the QueryShortChannelIds, if is_owned is set and inner is non-NULL.
 */
void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short_channel_ids that are being queried
 */
void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new QueryShortChannelIds given each field
 */
MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the QueryShortChannelIds
 */
struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReplyShortChannelIdsEnd, if is_owned is set and inner is non-NULL.
 */
void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);

/**
 * The genesis hash of the blockchain that was queried
 */
const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain that was queried
 */
void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the chain_hash
 */
void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ReplyShortChannelIdsEnd given each field
 */
MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);

/**
 * Creates a copy of the ReplyShortChannelIdsEnd
 */
struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);

/**
 * Frees any resources used by the GossipTimestampFilter, if is_owned is set and inner is non-NULL.
 */
void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);

/**
 * The genesis hash of the blockchain for channel and node information
 */
const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain for channel and node information
 */
void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The starting unix timestamp
 */
uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The starting unix timestamp
 */
void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The range of information in seconds
 */
uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The range of information in seconds
 */
void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new GossipTimestampFilter given each field
 */
MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);

/**
 * Creates a copy of the GossipTimestampFilter
 */
struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErrorAction
 */
void ErrorAction_free(struct LDKErrorAction this_ptr);

/**
 * Creates a copy of the ErrorAction
 */
struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);

/**
 * Frees any resources used by the LightningError, if is_owned is set and inner is non-NULL.
 */
void LightningError_free(struct LDKLightningError this_obj);

/**
 * A human-readable message describing the error
 */
struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * A human-readable message describing the error
 */
void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * The action which should be taken against the offending peer.
 */
struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * The action which should be taken against the offending peer.
 */
void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);

/**
 * Constructs a new LightningError given each field
 */
MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKCVec_u8Z err_arg, struct LDKErrorAction action_arg);

/**
 * Creates a copy of the LightningError
 */
struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentUpdate, if is_owned is set and inner is non-NULL.
 */
void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);

/**
 * update_add_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);

/**
 * update_fulfill_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);

/**
 * update_fail_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);

/**
 * update_fail_malformed_htlc messages which should be sent
 */
void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);

/**
 * An update_fee message which should be sent
 */
struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * An update_fee message which should be sent
 */
void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);

/**
 * Finally, the commitment_signed message which should be sent
 */
struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * Finally, the commitment_signed message which should be sent
 */
void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);

/**
 * Constructs a new CommitmentUpdate given each field
 */
MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);

/**
 * Creates a copy of the CommitmentUpdate
 */
struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);

/**
 * Frees any resources used by the HTLCFailChannelUpdate
 */
void HTLCFailChannelUpdate_free(struct LDKHTLCFailChannelUpdate this_ptr);

/**
 * Creates a copy of the HTLCFailChannelUpdate
 */
struct LDKHTLCFailChannelUpdate HTLCFailChannelUpdate_clone(const struct LDKHTLCFailChannelUpdate *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);

/**
 * Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
 */
struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);

/**
 * Read a AcceptChannel from a byte array, created by AcceptChannel_write
 */
struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);

/**
 * Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
 */
struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);

/**
 * Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
 */
struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);

/**
 * Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
 */
struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);

/**
 * Read a ClosingSigned from a byte array, created by ClosingSigned_write
 */
struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
 */
struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);

/**
 * Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
 */
struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);

/**
 * Read a FundingCreated from a byte array, created by FundingCreated_write
 */
struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);

/**
 * Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
 */
struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);

/**
 * Read a FundingSigned from a byte array, created by FundingSigned_write
 */
struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingLocked object into a byte array which can be read by FundingLocked_read
 */
struct LDKCVec_u8Z FundingLocked_write(const struct LDKFundingLocked *NONNULL_PTR obj);

/**
 * Read a FundingLocked from a byte array, created by FundingLocked_write
 */
struct LDKCResult_FundingLockedDecodeErrorZ FundingLocked_read(struct LDKu8slice ser);

/**
 * Serialize the Init object into a byte array which can be read by Init_read
 */
struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);

/**
 * Read a Init from a byte array, created by Init_write
 */
struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);

/**
 * Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
 */
struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);

/**
 * Read a OpenChannel from a byte array, created by OpenChannel_write
 */
struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);

/**
 * Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
 */
struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);

/**
 * Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);

/**
 * Serialize the Shutdown object into a byte array which can be read by Shutdown_read
 */
struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);

/**
 * Read a Shutdown from a byte array, created by Shutdown_write
 */
struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
 */
struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
 */
struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
 */
struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);

/**
 * Read a UpdateFee from a byte array, created by UpdateFee_write
 */
struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
 */
struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
 */
struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the Ping object into a byte array which can be read by Ping_read
 */
struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);

/**
 * Read a Ping from a byte array, created by Ping_write
 */
struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);

/**
 * Serialize the Pong object into a byte array which can be read by Pong_read
 */
struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);

/**
 * Read a Pong from a byte array, created by Pong_write
 */
struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
 */
struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
 */
struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
 */
struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);

/**
 * Read a ErrorMessage from a byte array, created by ErrorMessage_write
 */
struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
 */
struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);

/**
 * Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
 */
struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);

/**
 * Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
 */
struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);

/**
 * Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
 */
struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);

/**
 * Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
 */
struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);

/**
 * Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);

/**
 * Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
 */
struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);

/**
 * Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);

/**
 * Constructs a new IgnoringMessageHandler given each field
 */
MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);

/**
 * Constructs a new ErroringMessageHandler
 */
MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
 */
void MessageHandler_free(struct LDKMessageHandler this_obj);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * ChannelManager object or a ErroringMessageHandler.
 */
const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * ChannelManager object or a ErroringMessageHandler.
 */
void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a NetGraphMsgHandlerMonitor object or an IgnoringMessageHandler.
 */
const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a NetGraphMsgHandlerMonitor object or an IgnoringMessageHandler.
 */
void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);

/**
 * Constructs a new MessageHandler given each field
 */
MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg);

/**
 * Creates a copy of a SocketDescriptor
 */
struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);

/**
 * Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
 */
void PeerHandleError_free(struct LDKPeerHandleError this_obj);

/**
 * Used to indicate that we probably can't make any future connections to this peer, implying
 * we should go ahead and force-close any channels we have with it.
 */
bool PeerHandleError_get_no_connection_possible(const struct LDKPeerHandleError *NONNULL_PTR this_ptr);

/**
 * Used to indicate that we probably can't make any future connections to this peer, implying
 * we should go ahead and force-close any channels we have with it.
 */
void PeerHandleError_set_no_connection_possible(struct LDKPeerHandleError *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new PeerHandleError given each field
 */
MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);

/**
 * Creates a copy of the PeerHandleError
 */
struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);

/**
 * Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
 */
void PeerManager_free(struct LDKPeerManager this_obj);

/**
 * Constructs a new PeerManager with the given message handlers and node_id secret key
 * ephemeral_random_data is used to derive per-connection ephemeral keys and must be
 * cryptographically secure random bytes.
 */
MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, struct LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger);

/**
 * Get the list of node ids for peers which have completed the initial handshake.
 *
 * For outbound connections, this will be the same as the their_node_id parameter passed in to
 * new_outbound_connection, however entries will only appear once the initial handshake has
 * completed and we are sure the remote peer has the private key for the given node_id.
 */
MUST_USE_RES struct LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates a new outbound connection has been established to a node with the given node_id.
 * Note that if an Err is returned here you MUST NOT call socket_disconnected for the new
 * descriptor but must disconnect the connection immediately.
 *
 * Returns a small number of bytes to send to the remote node (currently always 50).
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet had a
 * socket_disconnected().
 */
MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor);

/**
 * Indicates a new inbound connection has been established.
 *
 * May refuse the connection by returning an Err, but will never write bytes to the remote end
 * (outbound connector always speaks first). Note that if an Err is returned here you MUST NOT
 * call socket_disconnected for the new descriptor but must disconnect the connection
 * immediately.
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet had
 * socket_disconnected called.
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor);

/**
 * Indicates that there is room to write data to the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * Will most likely call send_data on the descriptor passed in (or the descriptor handed into
 * new_*\\_connection) before returning. Thus, be very careful with reentrancy issues! The
 * invariants around calling write_buffer_space_avail in case a write did not fully complete
 * must still hold - be ready to call write_buffer_space_avail again if a write call generated
 * here isn't sufficient! Panics if the descriptor was not previously registered in a
 * new_\\*_connection event.
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Indicates that data was read from the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * Will *not* call back into send_data on any descriptors to avoid reentrancy complexity.
 * Thus, however, you almost certainly want to call process_events() after any read_event to
 * generate send_data calls to handle responses.
 *
 * If Ok(true) is returned, further read_events should not be triggered until a send_data call
 * on this file descriptor has resume_read set (preventing DoS issues in the send buffer).
 *
 * Panics if the descriptor was not previously registered in a new_*_connection event.
 */
MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);

/**
 * Checks for any events generated by our handlers and processes them. Includes sending most
 * response messages as well as messages generated by calls to handler functions directly (eg
 * functions like ChannelManager::process_pending_htlc_forward or send_payment).
 */
void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates that the given socket descriptor's connection is now closed.
 *
 * This must only be called if the socket has been disconnected by the peer or your own
 * decision to disconnect it and must NOT be called in any case where other parts of this
 * library (eg PeerHandleError, explicit disconnect_socket calls) instruct you to disconnect
 * the peer.
 *
 * Panics if the descriptor was not previously registered in a successful new_*_connection event.
 */
void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Disconnect a peer given its node id.
 *
 * Set no_connection_possible to true to prevent any further connection with this peer,
 * force-closing any channels we have with it.
 *
 * If a peer is connected, this will call `disconnect_socket` on the descriptor for the peer,
 * so be careful about reentrancy issues.
 */
void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, bool no_connection_possible);

/**
 * This function should be called roughly once every 30 seconds.
 * It will send pings to each peer and disconnect those which did not respond to the last round of pings.
 * Will most likely call send_data on all of the registered descriptors, thus, be very careful with reentrancy issues!
 */
void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Build the commitment secret from the seed and the commitment number
 */
struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);

/**
 * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
 * from the base secret and the per_commitment_point.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_SecretKeyErrorZ derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);

/**
 * Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
 * from the base point and the per_commitment_key. This is the public equivalent of
 * derive_private_key - using only public keys to derive a public key instead of private keys.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_PublicKeyErrorZ derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);

/**
 * Derives a per-commitment-transaction revocation key from its constituent parts.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_secret always come from cheater
 * and revocation_base_secret always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_SecretKeyErrorZ derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);

/**
 * Derives a per-commitment-transaction revocation public key from its constituent parts. This is
 * the public equivalend of derive_private_revocation_key - using only public keys to derive a
 * public key instead of private keys.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_point always come from cheater
 * and revocation_base_point always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKCResult_PublicKeyErrorZ derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);

/**
 * Frees any resources used by the TxCreationKeys, if is_owned is set and inner is non-NULL.
 */
void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's HTLC Key
 */
void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Countersignatory's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Countersignatory's HTLC Key
 */
void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new TxCreationKeys given each field
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);

/**
 * Creates a copy of the TxCreationKeys
 */
struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);

/**
 * Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
 */
struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);

/**
 * Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelPublicKeys, if is_owned is set and inner is non-NULL.
 */
void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new ChannelPublicKeys given each field
 */
MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);

/**
 * Creates a copy of the ChannelPublicKeys
 */
struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);

/**
 * Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
 */
struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);

/**
 * Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);

/**
 * Create per-state keys from channel base points and the per-commitment point.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);

/**
 * Generate per-state keys from channel static keys.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * A script either spendable by the revocation
 * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
 * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
 */
struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);

/**
 * Frees any resources used by the HTLCOutputInCommitment, if is_owned is set and inner is non-NULL.
 */
void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The hash of the preimage which unlocks this HTLC.
 */
const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];

/**
 * The hash of the preimage which unlocks this HTLC.
 */
void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Creates a copy of the HTLCOutputInCommitment
 */
struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);

/**
 * Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
 */
struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);

/**
 * Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);

/**
 * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
 * does not need to have its previous_output_index filled.
 */
struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, const struct LDKTxCreationKeys *NONNULL_PTR keys);

/**
 * Gets the redeemscript for a funding output from the two funding public keys.
 * Note that the order of funding public keys does not matter.
 */
struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);

/**
 * panics if htlc.transaction_output_index.is_none()!
 */
struct LDKTransaction build_htlc_transaction(const uint8_t (*prev_hash)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);

/**
 * Frees any resources used by the ChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);

/**
 * Holder public keys
 */
struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Holder public keys
 */
void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 */
struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 */
void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);

/**
 * The late-bound funding outpoint
 */
struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound funding outpoint
 */
void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Constructs a new ChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg);

/**
 * Creates a copy of the ChannelTransactionParameters
 */
struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);

/**
 * Counter-party public keys
 */
struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Counter-party public keys
 */
void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);

/**
 * Creates a copy of the CounterpartyChannelTransactionParameters
 */
struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Whether the late bound parameters are populated.
 */
MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the holder is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the counterparty is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
 */
struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
 */
struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);

/**
 * Get the channel pubkeys for the broadcaster
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the channel pubkeys for the countersignatory
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the contest delay applicable to the transactions.
 * Note that the contest delay was selected by the countersignatory.
 */
MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether the channel is outbound from the broadcaster.
 *
 * The boolean representing the side that initiated the channel is
 * an input to the commitment number obscure factor computation.
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * The funding outpoint
 */
MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the HolderCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);

/**
 * Our counterparty's signature for the transaction
 */
struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * Our counterparty's signature for the transaction
 */
void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 */
void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);

/**
 * Creates a copy of the HolderCommitmentTransaction
 */
struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
 */
struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Create a new holder transaction with the given counterparty signatures.
 * The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
 */
MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);

/**
 * Frees any resources used by the BuiltCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);

/**
 * The commitment transaction
 */
struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * The commitment transaction
 */
void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new BuiltCommitmentTransaction given each field
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);

/**
 * Creates a copy of the BuiltCommitmentTransaction
 */
struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
 */
struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the CommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);

/**
 * Creates a copy of the CommitmentTransaction
 */
struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
 */
struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);

/**
 * The backwards-counting commitment number
 */
MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the broadcaster
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The feerate paid per 1000-weight-unit in this commitment transaction.
 */
MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Trust our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * This should only be used if you fully trust the builder of this object.  It should not
 *\tbe used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * Frees any resources used by the TrustedCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);

/**
 * The transaction ID of the built Bitcoin transaction
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-calculated transaction creation public keys.
 */
MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Get a signature for each HTLC which was included in the commitment transaction (ie for
 * which HTLCOutputInCommitment::transaction_output_index.is_some()).
 *
 * The returned Vec has one entry for each HTLC, and in the same order.
 */
MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters);

/**
 * Get the transaction number obscure factor
 */
uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);

/**
 * Creates a copy of the InitFeatures
 */
struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the NodeFeatures
 */
struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelFeatures
 */
struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the InvoiceFeatures
 */
struct LDKInvoiceFeatures InvoiceFeatures_clone(const struct LDKInvoiceFeatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the InitFeatures, if is_owned is set and inner is non-NULL.
 */
void InitFeatures_free(struct LDKInitFeatures this_obj);

/**
 * Frees any resources used by the NodeFeatures, if is_owned is set and inner is non-NULL.
 */
void NodeFeatures_free(struct LDKNodeFeatures this_obj);

/**
 * Frees any resources used by the ChannelFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelFeatures_free(struct LDKChannelFeatures this_obj);

/**
 * Frees any resources used by the InvoiceFeatures, if is_owned is set and inner is non-NULL.
 */
void InvoiceFeatures_free(struct LDKInvoiceFeatures this_obj);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);

/**
 * Creates features known by the implementation as defined by [`T::KNOWN_FEATURE_FLAGS`].
 *
 * [`T::KNOWN_FEATURE_FLAGS`]: sealed/trait.Context.html#associatedconstant.KNOWN_FEATURE_FLAGS
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_known(void);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);

/**
 * Creates features known by the implementation as defined by [`T::KNOWN_FEATURE_FLAGS`].
 *
 * [`T::KNOWN_FEATURE_FLAGS`]: sealed/trait.Context.html#associatedconstant.KNOWN_FEATURE_FLAGS
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_known(void);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);

/**
 * Creates features known by the implementation as defined by [`T::KNOWN_FEATURE_FLAGS`].
 *
 * [`T::KNOWN_FEATURE_FLAGS`]: sealed/trait.Context.html#associatedconstant.KNOWN_FEATURE_FLAGS
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_known(void);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_empty(void);

/**
 * Creates features known by the implementation as defined by [`T::KNOWN_FEATURE_FLAGS`].
 *
 * [`T::KNOWN_FEATURE_FLAGS`]: sealed/trait.Context.html#associatedconstant.KNOWN_FEATURE_FLAGS
 */
MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_known(void);

/**
 * Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
 */
struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);

/**
 * Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
 */
struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);

/**
 * Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
 */
struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);

/**
 * Serialize the InvoiceFeatures object into a byte array which can be read by InvoiceFeatures_read
 */
struct LDKCVec_u8Z InvoiceFeatures_write(const struct LDKInvoiceFeatures *NONNULL_PTR obj);

/**
 * Read a InitFeatures from a byte array, created by InitFeatures_write
 */
struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);

/**
 * Read a NodeFeatures from a byte array, created by NodeFeatures_write
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);

/**
 * Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);

/**
 * Read a InvoiceFeatures from a byte array, created by InvoiceFeatures_write
 */
struct LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHop, if is_owned is set and inner is non-NULL.
 */
void RouteHop_free(struct LDKRouteHop this_obj);

/**
 * The node_id of the node at this hop.
 */
struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the node at this hop.
 */
void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * For the last hop, this should be the full value of the payment (might be more than
 * requested if we had to match htlc_minimum_msat).
 */
void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The CLTV delta added for this hop. For the last hop, this should be the full CLTV value
 * expected at the destination, in excess of the current block height.
 */
void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RouteHop given each field
 */
MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the RouteHop
 */
struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);

/**
 * Frees any resources used by the Route, if is_owned is set and inner is non-NULL.
 */
void Route_free(struct LDKRoute this_obj);

/**
 * The list of routes taken for a single (potentially-)multi-part payment. The pubkey of the
 * last RouteHop in each path must be the same.
 * Each entry represents a list of hops, NOT INCLUDING our own, where the last hop is the
 * destination. Thus, this must always be at least length one. While the maximum length of any
 * given path is variable, keeping the length of any path to less than 20 should currently
 * ensure it is viable.
 */
void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_CVec_RouteHopZZ val);

/**
 * Constructs a new Route given each field
 */
MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_CVec_RouteHopZZ paths_arg);

/**
 * Creates a copy of the Route
 */
struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);

/**
 * Serialize the Route object into a byte array which can be read by Route_read
 */
struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);

/**
 * Read a Route from a byte array, created by Route_write
 */
struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHint, if is_owned is set and inner is non-NULL.
 */
void RouteHint_free(struct LDKRouteHint this_obj);

/**
 * The node_id of the non-target end of the route
 */
struct LDKPublicKey RouteHint_get_src_node_id(const struct LDKRouteHint *NONNULL_PTR this_ptr);

/**
 * The node_id of the non-target end of the route
 */
void RouteHint_set_src_node_id(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The short_channel_id of this channel
 */
uint64_t RouteHint_get_short_channel_id(const struct LDKRouteHint *NONNULL_PTR this_ptr);

/**
 * The short_channel_id of this channel
 */
void RouteHint_set_short_channel_id(struct LDKRouteHint *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The fees which must be paid to use this channel
 */
struct LDKRoutingFees RouteHint_get_fees(const struct LDKRouteHint *NONNULL_PTR this_ptr);

/**
 * The fees which must be paid to use this channel
 */
void RouteHint_set_fees(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * The difference in CLTV values between this node and the next node.
 */
uint16_t RouteHint_get_cltv_expiry_delta(const struct LDKRouteHint *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values between this node and the next node.
 */
void RouteHint_set_cltv_expiry_delta(struct LDKRouteHint *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Creates a copy of the RouteHint
 */
struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);

/**
 * Gets a route from us (payer) to the given target node (payee).
 *
 * If the payee provided features in their invoice, they should be provided via payee_features.
 * Without this, MPP will only be used if the payee's features are available in the network graph.
 *
 * Extra routing hops between known nodes and the target will be used if they are included in
 * last_hops.
 *
 * If some channels aren't announced, it may be useful to fill in a first_hops with the
 * results from a local ChannelManager::list_usable_channels() call. If it is filled in, our
 * view of our local channels (from net_graph_msg_handler) will be ignored, and only those
 * in first_hops will be used.
 *
 * Panics if first_hops contains channels without short_channel_ids
 * (ChannelManager::list_usable_channels will never include such channels).
 *
 * The fees on channels from us to next-hops are ignored (as they are assumed to all be
 * equal), however the enabled/disabled bit on such channels as well as the
 * htlc_minimum_msat/htlc_maximum_msat *are* checked as they may change based on the receiving node.
 */
struct LDKCResult_RouteLightningErrorZ get_route(struct LDKPublicKey our_node_id, const struct LDKNetworkGraph *NONNULL_PTR network, struct LDKPublicKey payee, struct LDKInvoiceFeatures payee_features, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKCVec_RouteHintZ last_hops, uint64_t final_value_msat, uint32_t final_cltv, struct LDKLogger logger);

/**
 * Frees any resources used by the NetworkGraph, if is_owned is set and inner is non-NULL.
 */
void NetworkGraph_free(struct LDKNetworkGraph this_obj);

/**
 * Creates a copy of the NetworkGraph
 */
struct LDKNetworkGraph NetworkGraph_clone(const struct LDKNetworkGraph *NONNULL_PTR orig);

/**
 * Frees any resources used by the LockedNetworkGraph, if is_owned is set and inner is non-NULL.
 */
void LockedNetworkGraph_free(struct LDKLockedNetworkGraph this_obj);

/**
 * Frees any resources used by the NetGraphMsgHandler, if is_owned is set and inner is non-NULL.
 */
void NetGraphMsgHandler_free(struct LDKNetGraphMsgHandler this_obj);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming a fresh network graph.
 * Chain monitor is used to make sure announced channels exist on-chain,
 * channel data is correct, and that the announcement is signed with
 * channel owners' keys.
 */
MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_new(struct LDKThirtyTwoBytes genesis_hash, struct LDKAccess *chain_access, struct LDKLogger logger);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming an existing Network Graph.
 */
MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_from_net_graph(struct LDKAccess *chain_access, struct LDKLogger logger, struct LDKNetworkGraph network_graph);

/**
 * Adds a provider used to check new announcements. Does not affect
 * existing announcements unless they are updated.
 * Add, update or remove the provider would replace the current one.
 */
void NetGraphMsgHandler_add_chain_access(struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg, struct LDKAccess *chain_access);

/**
 * Take a read lock on the network_graph and return it in the C-bindings
 * newtype helper. This is likely only useful when called via the C
 * bindings as you can call `self.network_graph.read().unwrap()` in Rust
 * yourself.
 */
MUST_USE_RES struct LDKLockedNetworkGraph NetGraphMsgHandler_read_locked_graph(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Get a reference to the NetworkGraph which this read-lock contains.
 */
MUST_USE_RES struct LDKNetworkGraph LockedNetworkGraph_graph(const struct LDKLockedNetworkGraph *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler NetGraphMsgHandler_as_RoutingMessageHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider NetGraphMsgHandler_as_MessageSendEventsProvider(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the DirectionalChannelInfo, if is_owned is set and inner is non-NULL.
 */
void DirectionalChannelInfo_free(struct LDKDirectionalChannelInfo this_obj);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t DirectionalChannelInfo_get_last_update(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
void DirectionalChannelInfo_set_last_update(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
bool DirectionalChannelInfo_get_enabled(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
void DirectionalChannelInfo_set_enabled(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, bool val);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
uint16_t DirectionalChannelInfo_get_cltv_expiry_delta(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
void DirectionalChannelInfo_set_cltv_expiry_delta(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
uint64_t DirectionalChannelInfo_get_htlc_minimum_msat(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
void DirectionalChannelInfo_set_htlc_minimum_msat(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Fees charged when the channel is used for routing
 */
struct LDKRoutingFees DirectionalChannelInfo_get_fees(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * Fees charged when the channel is used for routing
 */
void DirectionalChannelInfo_set_fees(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
struct LDKChannelUpdate DirectionalChannelInfo_get_last_update_message(const struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
void DirectionalChannelInfo_set_last_update_message(struct LDKDirectionalChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);

/**
 * Creates a copy of the DirectionalChannelInfo
 */
struct LDKDirectionalChannelInfo DirectionalChannelInfo_clone(const struct LDKDirectionalChannelInfo *NONNULL_PTR orig);

/**
 * Serialize the DirectionalChannelInfo object into a byte array which can be read by DirectionalChannelInfo_read
 */
struct LDKCVec_u8Z DirectionalChannelInfo_write(const struct LDKDirectionalChannelInfo *NONNULL_PTR obj);

/**
 * Read a DirectionalChannelInfo from a byte array, created by DirectionalChannelInfo_write
 */
struct LDKCResult_DirectionalChannelInfoDecodeErrorZ DirectionalChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelInfo_free(struct LDKChannelInfo this_obj);

/**
 * Protocol features of a channel communicated during its announcement
 */
struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features of a channel communicated during its announcement
 */
void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * Source node of the first direction of a channel
 */
struct LDKPublicKey ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the first direction of a channel
 */
void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Details about the first direction of a channel
 */
struct LDKDirectionalChannelInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the first direction of a channel
 */
void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKDirectionalChannelInfo val);

/**
 * Source node of the second direction of a channel
 */
struct LDKPublicKey ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the second direction of a channel
 */
void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Details about the second direction of a channel
 */
struct LDKDirectionalChannelInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the second direction of a channel
 */
void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKDirectionalChannelInfo val);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);

/**
 * Creates a copy of the ChannelInfo
 */
struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);

/**
 * Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
 */
struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);

/**
 * Read a ChannelInfo from a byte array, created by ChannelInfo_write
 */
struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RoutingFees, if is_owned is set and inner is non-NULL.
 */
void RoutingFees_free(struct LDKRoutingFees this_obj);

/**
 * Flat routing fee in satoshis
 */
uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Flat routing fee in satoshis
 */
void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RoutingFees given each field
 */
MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);

/**
 * Creates a copy of the RoutingFees
 */
struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);

/**
 * Read a RoutingFees from a byte array, created by RoutingFees_write
 */
struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);

/**
 * Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
 */
struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);

/**
 * Frees any resources used by the NodeAnnouncementInfo, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);

/**
 * Protocol features the node announced support for
 */
struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features the node announced support for
 */
void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Color assigned to the node
 */
const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];

/**
 * Color assigned to the node
 */
void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
const uint8_t (*NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[32];

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Internet-level addresses via which one can connect to the node
 */
void NodeAnnouncementInfo_set_addresses(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 */
void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncementInfo given each field
 */
MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKThirtyTwoBytes alias_arg, struct LDKCVec_NetAddressZ addresses_arg, struct LDKNodeAnnouncement announcement_message_arg);

/**
 * Creates a copy of the NodeAnnouncementInfo
 */
struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);

/**
 * Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
 */
struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeInfo, if is_owned is set and inner is non-NULL.
 */
void NodeInfo_free(struct LDKNodeInfo this_obj);

/**
 * All valid channels a node has announced
 */
void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 */
struct LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * Lowest fees enabling routing via any of the enabled, known channels to a node.
 * The two fields (flat and proportional fee) are independent,
 * meaning they don't have to refer to the same channel.
 */
void NodeInfo_set_lowest_inbound_channel_fees(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 */
struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 */
void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);

/**
 * Constructs a new NodeInfo given each field
 */
MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKRoutingFees lowest_inbound_channel_fees_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);

/**
 * Creates a copy of the NodeInfo
 */
struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);

/**
 * Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
 */
struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);

/**
 * Read a NodeInfo from a byte array, created by NodeInfo_write
 */
struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);

/**
 * Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
 */
struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);

/**
 * Read a NetworkGraph from a byte array, created by NetworkGraph_write
 */
struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser);

/**
 * Creates a new, empty, network graph.
 */
MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(struct LDKThirtyTwoBytes genesis_hash);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement without verifying the associated signatures. Because we aren't
 * given the associated signatures here we cannot relay the node announcement to any of our
 * peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);

/**
 * Store or update channel info from a channel announcement.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKAccess *chain_access);

/**
 * Store or update channel info from a channel announcement without verifying the associated
 * signatures. Because we aren't given the associated signatures here we cannot relay the
 * channel announcement to any of our peers.
 *
 * If a `chain::Access` object is provided via `chain_access`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKAccess *chain_access);

/**
 * Close a channel if a corresponding HTLC fail was sent.
 * If permanent, removes a channel from the local storage.
 * May cause the removal of nodes too, if this was their last channel.
 * If not permanent, makes channels unavailable for routing.
 */
void NetworkGraph_close_channel_from_update(struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, bool is_permanent);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel.
 *
 * You probably don't want to call this directly, instead relying on a NetGraphMsgHandler's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel without verifying the associated signatures. Because we aren't given the
 * associated signatures here we cannot relay the channel update to any of our peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);

/* Text to put at the end of the generated file */
