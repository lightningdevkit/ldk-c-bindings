// This file is Copyright its original authors, visible in version control
// history and in the source files from which this was generated.
//
// This file is licensed under the license available in the LICENSE or LICENSE.md
// file in the root of this repository or, if no such file exists, the same
// license as that which applies to the original source files from which this
// source was automatically generated.

//! Top level peer message handling and socket handling logic lives here.
//!
//! Instead of actually servicing sockets ourselves we require that you implement the
//! SocketDescriptor interface and use that to receive actions which you should perform on the
//! socket, and call into PeerManager with bytes read from the socket. The PeerManager will then
//! call into the provided message handlers (probably a ChannelManager and P2PGossipSync) with
//! messages they should handle, and encoding/sending response messages.

use alloc::str::FromStr;
use alloc::string::String;
use core::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;
#[cfg(feature="no-std")]
use alloc::{vec::Vec, boxed::Box};

/// A handler provided to [`PeerManager`] for reading and handling custom messages.
///
/// [BOLT 1] specifies a custom message type range for use with experimental or application-specific
/// messages. `CustomMessageHandler` allows for user-defined handling of such types. See the
/// [`lightning_custom_message`] crate for tools useful in composing more than one custom handler.
///
/// [BOLT 1]: https://github.com/lightning/bolts/blob/master/01-messaging.md
/// [`lightning_custom_message`]: https://docs.rs/lightning_custom_message/latest/lightning_custom_message
#[repr(C)]
pub struct CustomMessageHandler {
	/// An opaque pointer which is passed to your function implementations as an argument.
	/// This has no meaning in the LDK, and can be NULL or any other value.
	pub this_arg: *mut c_void,
	/// Handles the given message sent from `sender_node_id`, possibly producing messages for
	/// [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
	/// to send.
	pub handle_custom_message: extern "C" fn (this_arg: *const c_void, msg: crate::lightning::ln::wire::Type, sender_node_id: crate::c_types::PublicKey) -> crate::c_types::derived::CResult_NoneLightningErrorZ,
	/// Returns the list of pending messages that were generated by the handler, clearing the list
	/// in the process. Each message is paired with the node id of the intended recipient. If no
	/// connection to the node exists, then the message is simply not sent.
	pub get_and_clear_pending_msg: extern "C" fn (this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_PublicKeyTypeZZ,
	/// Gets the node feature flags which this handler itself supports. All available handlers are
	/// queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
	/// which are broadcasted in our [`NodeAnnouncement`] message.
	///
	/// [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
	pub provided_node_features: extern "C" fn (this_arg: *const c_void) -> crate::lightning::ln::features::NodeFeatures,
	/// Gets the init feature flags which should be sent to the given peer. All available handlers
	/// are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
	/// which are sent in our [`Init`] message.
	///
	/// [`Init`]: crate::ln::msgs::Init
	pub provided_init_features: extern "C" fn (this_arg: *const c_void, their_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::features::InitFeatures,
	/// Implementation of CustomMessageReader for this object.
	pub CustomMessageReader: crate::lightning::ln::wire::CustomMessageReader,
	/// Frees any resources associated with this object given its this_arg pointer.
	/// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for CustomMessageHandler {}
unsafe impl Sync for CustomMessageHandler {}
pub(crate) fn CustomMessageHandler_clone_fields(orig: &CustomMessageHandler) -> CustomMessageHandler {
	CustomMessageHandler {
		this_arg: orig.this_arg,
		handle_custom_message: Clone::clone(&orig.handle_custom_message),
		get_and_clear_pending_msg: Clone::clone(&orig.get_and_clear_pending_msg),
		provided_node_features: Clone::clone(&orig.provided_node_features),
		provided_init_features: Clone::clone(&orig.provided_init_features),
		CustomMessageReader: crate::lightning::ln::wire::CustomMessageReader_clone_fields(&orig.CustomMessageReader),
		free: Clone::clone(&orig.free),
	}
}
impl lightning::ln::wire::CustomMessageReader for CustomMessageHandler {
	type CustomMessage = crate::lightning::ln::wire::Type;
	fn read<R:crate::c_types::io::Read>(&self, mut message_type: u16, mut buffer: &mut R) -> Result<Option<crate::lightning::ln::wire::Type>, lightning::ln::msgs::DecodeError> {
		let mut ret = (self.CustomMessageReader.read)(self.CustomMessageReader.this_arg, message_type, crate::c_types::u8slice::from_vec(&crate::c_types::reader_to_vec(buffer)));
		let mut local_ret = match ret.result_ok { true => Ok( { let mut local_ret_0 = { /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ let ret_0_opt = (*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) }); if ret_0_opt.is_none() { None } else { Some({ { { ret_0_opt.take() } }})} }; local_ret_0 }), false => Err( { (*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) }).into_native() })};
		local_ret
	}
}

use lightning::ln::peer_handler::CustomMessageHandler as rustCustomMessageHandler;
impl rustCustomMessageHandler for CustomMessageHandler {
	fn handle_custom_message(&self, mut msg: crate::lightning::ln::wire::Type, mut sender_node_id: &bitcoin::secp256k1::PublicKey) -> Result<(), lightning::ln::msgs::LightningError> {
		let mut ret = (self.handle_custom_message)(self.this_arg, Into::into(msg), crate::c_types::PublicKey::from_rust(&sender_node_id));
		let mut local_ret = match ret.result_ok { true => Ok( { () /*(*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.result)) })*/ }), false => Err( { *unsafe { Box::from_raw((*unsafe { Box::from_raw(<*mut _>::take_ptr(&mut ret.contents.err)) }).take_inner()) } })};
		local_ret
	}
	fn get_and_clear_pending_msg(&self) -> Vec<(bitcoin::secp256k1::PublicKey, crate::lightning::ln::wire::Type)> {
		let mut ret = (self.get_and_clear_pending_msg)(self.this_arg);
		let mut local_ret = Vec::new(); for mut item in ret.into_rust().drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item.to_rust(); let mut local_ret_0 = (orig_ret_0_0.into_rust(), orig_ret_0_1); local_ret_0 }); };
		local_ret
	}
	fn provided_node_features(&self) -> lightning::ln::features::NodeFeatures {
		let mut ret = (self.provided_node_features)(self.this_arg);
		*unsafe { Box::from_raw(ret.take_inner()) }
	}
	fn provided_init_features(&self, mut their_node_id: &bitcoin::secp256k1::PublicKey) -> lightning::ln::features::InitFeatures {
		let mut ret = (self.provided_init_features)(self.this_arg, crate::c_types::PublicKey::from_rust(&their_node_id));
		*unsafe { Box::from_raw(ret.take_inner()) }
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl core::ops::Deref for CustomMessageHandler {
	type Target = Self;
	fn deref(&self) -> &Self {
		self
	}
}
impl core::ops::DerefMut for CustomMessageHandler {
	fn deref_mut(&mut self) -> &mut Self {
		self
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn CustomMessageHandler_free(this_ptr: CustomMessageHandler) { }
impl Drop for CustomMessageHandler {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}

use lightning::ln::peer_handler::IgnoringMessageHandler as nativeIgnoringMessageHandlerImport;
pub(crate) type nativeIgnoringMessageHandler = nativeIgnoringMessageHandlerImport;

/// A dummy struct which implements `RoutingMessageHandler` without storing any routing information
/// or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
#[must_use]
#[repr(C)]
pub struct IgnoringMessageHandler {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeIgnoringMessageHandler,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for IgnoringMessageHandler {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeIgnoringMessageHandler>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_free(this_obj: IgnoringMessageHandler) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn IgnoringMessageHandler_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeIgnoringMessageHandler) };
}
#[allow(unused)]
impl IgnoringMessageHandler {
	pub(crate) fn get_native_ref(&self) -> &'static nativeIgnoringMessageHandler {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeIgnoringMessageHandler {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeIgnoringMessageHandler {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
}
/// Constructs a new IgnoringMessageHandler given each field
#[must_use]
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_new() -> IgnoringMessageHandler {
	IgnoringMessageHandler { inner: ObjOps::heap_alloc(nativeIgnoringMessageHandler {
	}), is_owned: true }
}
impl From<nativeIgnoringMessageHandler> for crate::lightning::events::MessageSendEventsProvider {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_MessageSendEventsProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg: &IgnoringMessageHandler) -> crate::lightning::events::MessageSendEventsProvider {
	crate::lightning::events::MessageSendEventsProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		get_and_clear_pending_msg_events: IgnoringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: *const c_void) -> crate::c_types::derived::CVec_MessageSendEventZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::events::MessageSendEventsProvider<>>::get_and_clear_pending_msg_events(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::events::MessageSendEvent::native_into(item) }); };
	local_ret.into()
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::msgs::RoutingMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_RoutingMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_RoutingMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::msgs::RoutingMessageHandler {
	crate::lightning::ln::msgs::RoutingMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_node_announcement: IgnoringMessageHandler_RoutingMessageHandler_handle_node_announcement,
		handle_channel_announcement: IgnoringMessageHandler_RoutingMessageHandler_handle_channel_announcement,
		handle_channel_update: IgnoringMessageHandler_RoutingMessageHandler_handle_channel_update,
		get_next_channel_announcement: IgnoringMessageHandler_RoutingMessageHandler_get_next_channel_announcement,
		get_next_node_announcement: IgnoringMessageHandler_RoutingMessageHandler_get_next_node_announcement,
		peer_connected: IgnoringMessageHandler_RoutingMessageHandler_peer_connected,
		handle_reply_channel_range: IgnoringMessageHandler_RoutingMessageHandler_handle_reply_channel_range,
		handle_reply_short_channel_ids_end: IgnoringMessageHandler_RoutingMessageHandler_handle_reply_short_channel_ids_end,
		handle_query_channel_range: IgnoringMessageHandler_RoutingMessageHandler_handle_query_channel_range,
		handle_query_short_channel_ids: IgnoringMessageHandler_RoutingMessageHandler_handle_query_short_channel_ids,
		processing_queue_high: IgnoringMessageHandler_RoutingMessageHandler_processing_queue_high,
		provided_node_features: IgnoringMessageHandler_RoutingMessageHandler_provided_node_features,
		provided_init_features: IgnoringMessageHandler_RoutingMessageHandler_provided_init_features,
		MessageSendEventsProvider: crate::lightning::events::MessageSendEventsProvider {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			get_and_clear_pending_msg_events: IgnoringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
		},
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_node_announcement(this_arg: *const c_void, msg: &crate::lightning::ln::msgs::NodeAnnouncement) -> crate::c_types::derived::CResult_boolLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_node_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, msg.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_channel_announcement(this_arg: *const c_void, msg: &crate::lightning::ln::msgs::ChannelAnnouncement) -> crate::c_types::derived::CResult_boolLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_channel_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, msg.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_channel_update(this_arg: *const c_void, msg: &crate::lightning::ln::msgs::ChannelUpdate) -> crate::c_types::derived::CResult_boolLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_channel_update(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, msg.get_native_ref());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_get_next_channel_announcement(this_arg: *const c_void, mut starting_point: u64) -> crate::c_types::derived::COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::get_next_channel_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, starting_point);
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::None } else { crate::c_types::derived::COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::Some( { let (mut orig_ret_0_0, mut orig_ret_0_1, mut orig_ret_0_2) = (ret.unwrap()); let mut local_orig_ret_0_1 = crate::lightning::ln::msgs::ChannelUpdate { inner: if orig_ret_0_1.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((orig_ret_0_1.unwrap())) } }, is_owned: true }; let mut local_orig_ret_0_2 = crate::lightning::ln::msgs::ChannelUpdate { inner: if orig_ret_0_2.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((orig_ret_0_2.unwrap())) } }, is_owned: true }; let mut local_ret_0 = (crate::lightning::ln::msgs::ChannelAnnouncement { inner: ObjOps::heap_alloc(orig_ret_0_0), is_owned: true }, local_orig_ret_0_1, local_orig_ret_0_2).into(); local_ret_0 }) };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_get_next_node_announcement(this_arg: *const c_void, mut starting_point: crate::lightning::routing::gossip::NodeId) -> crate::lightning::ln::msgs::NodeAnnouncement {
	let mut local_starting_point = if starting_point.inner.is_null() { None } else { Some( { starting_point.get_native_ref() }) };
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::get_next_node_announcement(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, local_starting_point);
	let mut local_ret = crate::lightning::ln::msgs::NodeAnnouncement { inner: if ret.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((ret.unwrap())) } }, is_owned: true };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, init: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::peer_connected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust(), init.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_reply_channel_range(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::ReplyChannelRange) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_reply_channel_range(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::ReplyShortChannelIdsEnd) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_reply_short_channel_ids_end(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_query_channel_range(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::QueryChannelRange) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_query_channel_range(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_handle_query_short_channel_ids(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, mut msg: crate::lightning::ln::msgs::QueryShortChannelIds) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::handle_query_short_channel_ids(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust(), *unsafe { Box::from_raw(msg.take_inner()) });
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::LightningError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_processing_queue_high(this_arg: *const c_void) -> bool {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::processing_queue_high(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	ret
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning::ln::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning::ln::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_RoutingMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::features::InitFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::RoutingMessageHandler<>>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust());
	crate::lightning::ln::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::events::OnionMessageProvider {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_OnionMessageProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new OnionMessageProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned OnionMessageProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_OnionMessageProvider(this_arg: &IgnoringMessageHandler) -> crate::lightning::events::OnionMessageProvider {
	crate::lightning::events::OnionMessageProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		next_onion_message_for_peer: IgnoringMessageHandler_OnionMessageProvider_next_onion_message_for_peer,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageProvider_next_onion_message_for_peer(this_arg: *const c_void, mut peer_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::msgs::OnionMessage {
	let mut ret = <nativeIgnoringMessageHandler as lightning::events::OnionMessageProvider<>>::next_onion_message_for_peer(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, peer_node_id.into_rust());
	let mut local_ret = crate::lightning::ln::msgs::OnionMessage { inner: if ret.is_none() { core::ptr::null_mut() } else {  { ObjOps::heap_alloc((ret.unwrap())) } }, is_owned: true };
	local_ret
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::msgs::OnionMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_OnionMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new OnionMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned OnionMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_OnionMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::msgs::OnionMessageHandler {
	crate::lightning::ln::msgs::OnionMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_onion_message: IgnoringMessageHandler_OnionMessageHandler_handle_onion_message,
		peer_connected: IgnoringMessageHandler_OnionMessageHandler_peer_connected,
		peer_disconnected: IgnoringMessageHandler_OnionMessageHandler_peer_disconnected,
		provided_node_features: IgnoringMessageHandler_OnionMessageHandler_provided_node_features,
		provided_init_features: IgnoringMessageHandler_OnionMessageHandler_provided_init_features,
		OnionMessageProvider: crate::lightning::events::OnionMessageProvider {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			next_onion_message_for_peer: IgnoringMessageHandler_OnionMessageProvider_next_onion_message_for_peer,
		},
	}
}

extern "C" fn IgnoringMessageHandler_OnionMessageHandler_handle_onion_message(this_arg: *const c_void, mut peer_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OnionMessage) {
	<nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler<>>::handle_onion_message(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &peer_node_id.into_rust(), msg.get_native_ref())
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, init: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler<>>::peer_connected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust(), init.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_peer_disconnected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) {
	<nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler<>>::peer_disconnected(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust())
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning::ln::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler<>>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning::ln::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_OnionMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::features::InitFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::msgs::OnionMessageHandler<>>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust());
	crate::lightning::ln::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::onion_message::offers::OffersMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_OffersMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new OffersMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned OffersMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_OffersMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::onion_message::offers::OffersMessageHandler {
	crate::lightning::onion_message::offers::OffersMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_message: IgnoringMessageHandler_OffersMessageHandler_handle_message,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_OffersMessageHandler_handle_message(this_arg: *const c_void, mut message: crate::lightning::onion_message::offers::OffersMessage) -> crate::c_types::derived::COption_OffersMessageZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::offers::OffersMessageHandler<>>::handle_message(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, message.into_native());
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_OffersMessageZ::None } else { crate::c_types::derived::COption_OffersMessageZ::Some( { crate::lightning::onion_message::offers::OffersMessage::native_into(ret.unwrap()) }) };
	local_ret
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::onion_message::messenger::CustomOnionMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_CustomOnionMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new CustomOnionMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned CustomOnionMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_CustomOnionMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::onion_message::messenger::CustomOnionMessageHandler {
	crate::lightning::onion_message::messenger::CustomOnionMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_custom_message: IgnoringMessageHandler_CustomOnionMessageHandler_handle_custom_message,
		read_custom_message: IgnoringMessageHandler_CustomOnionMessageHandler_read_custom_message,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_CustomOnionMessageHandler_handle_custom_message(this_arg: *const c_void, mut msg: crate::lightning::onion_message::packet::CustomOnionMessageContents) -> crate::c_types::derived::COption_CustomOnionMessageContentsZ {
	unreachable!();
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomOnionMessageHandler_read_custom_message(this_arg: *const c_void, mut message_type: u64, mut buffer: crate::c_types::u8slice) -> crate::c_types::derived::CResult_COption_CustomOnionMessageContentsZDecodeErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::onion_message::messenger::CustomOnionMessageHandler<>>::read_custom_message(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, message_type, &mut buffer.to_reader());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = if o.is_none() { crate::c_types::derived::COption_CustomOnionMessageContentsZ::None } else { crate::c_types::derived::COption_CustomOnionMessageContentsZ::Some( { Into::into(o.unwrap()) }) }; local_ret_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_ret
}

impl From<nativeInfallible> for crate::lightning::onion_message::packet::CustomOnionMessageContents {
	fn from(obj: nativeInfallible) -> Self {
		unreachable!();
	}
}
impl From<nativeInfallible> for crate::lightning::ln::wire::Type {
	fn from(obj: nativeInfallible) -> Self {
		unreachable!();
	}
}
impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::wire::CustomMessageReader {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_CustomMessageReader(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_CustomMessageReader(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::wire::CustomMessageReader {
	crate::lightning::ln::wire::CustomMessageReader {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		read: IgnoringMessageHandler_CustomMessageReader_read,
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageReader_read(this_arg: *const c_void, mut message_type: u16, mut buffer: crate::c_types::u8slice) -> crate::c_types::derived::CResult_COption_TypeZDecodeErrorZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::wire::CustomMessageReader<>>::read(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, message_type, &mut buffer.to_reader());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = if o.is_none() { crate::c_types::derived::COption_TypeZ::None } else { crate::c_types::derived::COption_TypeZ::Some( { Into::into(o.unwrap()) }) }; local_ret_0 }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::msgs::DecodeError::native_into(e) }).into() };
	local_ret
}

impl From<nativeIgnoringMessageHandler> for crate::lightning::ln::peer_handler::CustomMessageHandler {
	fn from(obj: nativeIgnoringMessageHandler) -> Self {
		let mut rust_obj = IgnoringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = IgnoringMessageHandler_as_CustomMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(IgnoringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn IgnoringMessageHandler_as_CustomMessageHandler(this_arg: &IgnoringMessageHandler) -> crate::lightning::ln::peer_handler::CustomMessageHandler {
	crate::lightning::ln::peer_handler::CustomMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_custom_message: IgnoringMessageHandler_CustomMessageHandler_handle_custom_message,
		get_and_clear_pending_msg: IgnoringMessageHandler_CustomMessageHandler_get_and_clear_pending_msg,
		provided_node_features: IgnoringMessageHandler_CustomMessageHandler_provided_node_features,
		provided_init_features: IgnoringMessageHandler_CustomMessageHandler_provided_init_features,
		CustomMessageReader: crate::lightning::ln::wire::CustomMessageReader {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			read: IgnoringMessageHandler_CustomMessageReader_read,
		},
	}
}

#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_handle_custom_message(this_arg: *const c_void, mut msg: crate::lightning::ln::wire::Type, mut sender_node_id: crate::c_types::PublicKey) -> crate::c_types::derived::CResult_NoneLightningErrorZ {
	unreachable!();
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_get_and_clear_pending_msg(this_arg: *const c_void) -> crate::c_types::derived::CVec_C2Tuple_PublicKeyTypeZZ {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler<>>::get_and_clear_pending_msg(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_ret_0 = (crate::c_types::PublicKey::from_rust(&orig_ret_0_0), Into::into(orig_ret_0_1)).into(); local_ret_0 }); };
	local_ret.into()
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning::ln::features::NodeFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler<>>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, );
	crate::lightning::ln::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn IgnoringMessageHandler_CustomMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::features::InitFeatures {
	let mut ret = <nativeIgnoringMessageHandler as lightning::ln::peer_handler::CustomMessageHandler<>>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeIgnoringMessageHandler) }, &their_node_id.into_rust());
	crate::lightning::ln::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}


use lightning::ln::peer_handler::ErroringMessageHandler as nativeErroringMessageHandlerImport;
pub(crate) type nativeErroringMessageHandler = nativeErroringMessageHandlerImport;

/// A dummy struct which implements `ChannelMessageHandler` without having any channels.
/// You can provide one of these as the route_handler in a MessageHandler.
#[must_use]
#[repr(C)]
pub struct ErroringMessageHandler {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeErroringMessageHandler,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for ErroringMessageHandler {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeErroringMessageHandler>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_free(this_obj: ErroringMessageHandler) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn ErroringMessageHandler_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeErroringMessageHandler) };
}
#[allow(unused)]
impl ErroringMessageHandler {
	pub(crate) fn get_native_ref(&self) -> &'static nativeErroringMessageHandler {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeErroringMessageHandler {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeErroringMessageHandler {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
}
/// Constructs a new ErroringMessageHandler
#[must_use]
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_new() -> crate::lightning::ln::peer_handler::ErroringMessageHandler {
	let mut ret = lightning::ln::peer_handler::ErroringMessageHandler::new();
	crate::lightning::ln::peer_handler::ErroringMessageHandler { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

impl From<nativeErroringMessageHandler> for crate::lightning::events::MessageSendEventsProvider {
	fn from(obj: nativeErroringMessageHandler) -> Self {
		let mut rust_obj = ErroringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ErroringMessageHandler_as_MessageSendEventsProvider(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(ErroringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_as_MessageSendEventsProvider(this_arg: &ErroringMessageHandler) -> crate::lightning::events::MessageSendEventsProvider {
	crate::lightning::events::MessageSendEventsProvider {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		get_and_clear_pending_msg_events: ErroringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
	}
}

#[must_use]
extern "C" fn ErroringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: *const c_void) -> crate::c_types::derived::CVec_MessageSendEventZ {
	let mut ret = <nativeErroringMessageHandler as lightning::events::MessageSendEventsProvider<>>::get_and_clear_pending_msg_events(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, );
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { crate::lightning::events::MessageSendEvent::native_into(item) }); };
	local_ret.into()
}

impl From<nativeErroringMessageHandler> for crate::lightning::ln::msgs::ChannelMessageHandler {
	fn from(obj: nativeErroringMessageHandler) -> Self {
		let mut rust_obj = ErroringMessageHandler { inner: ObjOps::heap_alloc(obj), is_owned: true };
		let mut ret = ErroringMessageHandler_as_ChannelMessageHandler(&rust_obj);
		// We want to free rust_obj when ret gets drop()'d, not rust_obj, so wipe rust_obj's pointer and set ret's free() fn
		rust_obj.inner = core::ptr::null_mut();
		ret.free = Some(ErroringMessageHandler_free_void);
		ret
	}
}
/// Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
/// This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
#[no_mangle]
pub extern "C" fn ErroringMessageHandler_as_ChannelMessageHandler(this_arg: &ErroringMessageHandler) -> crate::lightning::ln::msgs::ChannelMessageHandler {
	crate::lightning::ln::msgs::ChannelMessageHandler {
		this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
		free: None,
		handle_open_channel: ErroringMessageHandler_ChannelMessageHandler_handle_open_channel,
		handle_open_channel_v2: ErroringMessageHandler_ChannelMessageHandler_handle_open_channel_v2,
		handle_accept_channel: ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel,
		handle_accept_channel_v2: ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel_v2,
		handle_funding_created: ErroringMessageHandler_ChannelMessageHandler_handle_funding_created,
		handle_funding_signed: ErroringMessageHandler_ChannelMessageHandler_handle_funding_signed,
		handle_channel_ready: ErroringMessageHandler_ChannelMessageHandler_handle_channel_ready,
		handle_shutdown: ErroringMessageHandler_ChannelMessageHandler_handle_shutdown,
		handle_closing_signed: ErroringMessageHandler_ChannelMessageHandler_handle_closing_signed,
		handle_tx_add_input: ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_input,
		handle_tx_add_output: ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_output,
		handle_tx_remove_input: ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_input,
		handle_tx_remove_output: ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_output,
		handle_tx_complete: ErroringMessageHandler_ChannelMessageHandler_handle_tx_complete,
		handle_tx_signatures: ErroringMessageHandler_ChannelMessageHandler_handle_tx_signatures,
		handle_tx_init_rbf: ErroringMessageHandler_ChannelMessageHandler_handle_tx_init_rbf,
		handle_tx_ack_rbf: ErroringMessageHandler_ChannelMessageHandler_handle_tx_ack_rbf,
		handle_tx_abort: ErroringMessageHandler_ChannelMessageHandler_handle_tx_abort,
		handle_update_add_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_add_htlc,
		handle_update_fulfill_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_fulfill_htlc,
		handle_update_fail_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_htlc,
		handle_update_fail_malformed_htlc: ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_malformed_htlc,
		handle_commitment_signed: ErroringMessageHandler_ChannelMessageHandler_handle_commitment_signed,
		handle_revoke_and_ack: ErroringMessageHandler_ChannelMessageHandler_handle_revoke_and_ack,
		handle_update_fee: ErroringMessageHandler_ChannelMessageHandler_handle_update_fee,
		handle_announcement_signatures: ErroringMessageHandler_ChannelMessageHandler_handle_announcement_signatures,
		peer_disconnected: ErroringMessageHandler_ChannelMessageHandler_peer_disconnected,
		peer_connected: ErroringMessageHandler_ChannelMessageHandler_peer_connected,
		handle_channel_reestablish: ErroringMessageHandler_ChannelMessageHandler_handle_channel_reestablish,
		handle_channel_update: ErroringMessageHandler_ChannelMessageHandler_handle_channel_update,
		handle_error: ErroringMessageHandler_ChannelMessageHandler_handle_error,
		provided_node_features: ErroringMessageHandler_ChannelMessageHandler_provided_node_features,
		provided_init_features: ErroringMessageHandler_ChannelMessageHandler_provided_init_features,
		get_genesis_hashes: ErroringMessageHandler_ChannelMessageHandler_get_genesis_hashes,
		MessageSendEventsProvider: crate::lightning::events::MessageSendEventsProvider {
			this_arg: unsafe { ObjOps::untweak_ptr((*this_arg).inner) as *mut c_void },
			free: None,
			get_and_clear_pending_msg_events: ErroringMessageHandler_MessageSendEventsProvider_get_and_clear_pending_msg_events,
		},
	}
}

extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_open_channel(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OpenChannel) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_open_channel(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_open_channel_v2(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::OpenChannelV2) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_open_channel_v2(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AcceptChannel) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_accept_channel(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_accept_channel_v2(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AcceptChannelV2) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_accept_channel_v2(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_funding_created(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::FundingCreated) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_funding_created(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_funding_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::FundingSigned) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_funding_signed(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_channel_ready(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelReady) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_channel_ready(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_shutdown(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Shutdown) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_shutdown(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_closing_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ClosingSigned) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_closing_signed(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_input(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAddInput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_add_input(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_add_output(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAddOutput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_add_output(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_input(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxRemoveInput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_remove_input(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_remove_output(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxRemoveOutput) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_remove_output(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_complete(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxComplete) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_complete(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_signatures(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxSignatures) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_signatures(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_init_rbf(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxInitRbf) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_init_rbf(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_ack_rbf(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAckRbf) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_ack_rbf(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_tx_abort(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::TxAbort) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_tx_abort(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_add_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateAddHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_update_add_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fulfill_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFulfillHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_update_fulfill_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFailHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_update_fail_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFailMalformedHTLC) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_update_fail_malformed_htlc(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_commitment_signed(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::CommitmentSigned) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_commitment_signed(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_revoke_and_ack(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::RevokeAndACK) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_revoke_and_ack(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_update_fee(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::UpdateFee) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_update_fee(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_announcement_signatures(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::AnnouncementSignatures) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_announcement_signatures(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_peer_disconnected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::peer_disconnected(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust())
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_peer_connected(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::Init, mut inbound: bool) -> crate::c_types::derived::CResult_NoneNoneZ {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::peer_connected(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref(), inbound);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { () /*e*/ }).into() };
	local_ret
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_channel_reestablish(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelReestablish) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_channel_reestablish(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_channel_update(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ChannelUpdate) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_channel_update(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_handle_error(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey, msg: &crate::lightning::ln::msgs::ErrorMessage) {
	<nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::handle_error(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust(), msg.get_native_ref())
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_provided_node_features(this_arg: *const c_void) -> crate::lightning::ln::features::NodeFeatures {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::provided_node_features(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, );
	crate::lightning::ln::features::NodeFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_provided_init_features(this_arg: *const c_void, mut their_node_id: crate::c_types::PublicKey) -> crate::lightning::ln::features::InitFeatures {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::provided_init_features(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, &their_node_id.into_rust());
	crate::lightning::ln::features::InitFeatures { inner: ObjOps::heap_alloc(ret), is_owned: true }
}
#[must_use]
extern "C" fn ErroringMessageHandler_ChannelMessageHandler_get_genesis_hashes(this_arg: *const c_void) -> crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ {
	let mut ret = <nativeErroringMessageHandler as lightning::ln::msgs::ChannelMessageHandler<>>::get_genesis_hashes(unsafe { &mut *(this_arg as *mut nativeErroringMessageHandler) }, );
	let mut local_ret = if ret.is_none() { crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ::None } else { crate::c_types::derived::COption_CVec_ThirtyTwoBytesZZ::Some( { let mut local_ret_0 = Vec::new(); for mut item in ret.unwrap().drain(..) { local_ret_0.push( { crate::c_types::ThirtyTwoBytes { data: item.to_bytes() } }); }; local_ret_0.into() }) };
	local_ret
}


use lightning::ln::peer_handler::MessageHandler as nativeMessageHandlerImport;
pub(crate) type nativeMessageHandler = nativeMessageHandlerImport<crate::lightning::ln::msgs::ChannelMessageHandler, crate::lightning::ln::msgs::RoutingMessageHandler, crate::lightning::ln::msgs::OnionMessageHandler, crate::lightning::ln::peer_handler::CustomMessageHandler>;

/// Provides references to trait impls which handle different types of messages.
#[must_use]
#[repr(C)]
pub struct MessageHandler {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativeMessageHandler,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for MessageHandler {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativeMessageHandler>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn MessageHandler_free(this_obj: MessageHandler) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn MessageHandler_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativeMessageHandler) };
}
#[allow(unused)]
impl MessageHandler {
	pub(crate) fn get_native_ref(&self) -> &'static nativeMessageHandler {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativeMessageHandler {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativeMessageHandler {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
}
/// A message handler which handles messages specific to channels. Usually this is just a
/// [`ChannelManager`] object or an [`ErroringMessageHandler`].
///
/// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
#[no_mangle]
pub extern "C" fn MessageHandler_get_chan_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::msgs::ChannelMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().chan_handler;
	inner_val
}
/// A message handler which handles messages specific to channels. Usually this is just a
/// [`ChannelManager`] object or an [`ErroringMessageHandler`].
///
/// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
#[no_mangle]
pub extern "C" fn MessageHandler_set_chan_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::msgs::ChannelMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.chan_handler = val;
}
/// A message handler which handles messages updating our knowledge of the network channel
/// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
///
/// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
#[no_mangle]
pub extern "C" fn MessageHandler_get_route_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::msgs::RoutingMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().route_handler;
	inner_val
}
/// A message handler which handles messages updating our knowledge of the network channel
/// graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
///
/// [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
#[no_mangle]
pub extern "C" fn MessageHandler_set_route_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::msgs::RoutingMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.route_handler = val;
}
/// A message handler which handles onion messages. This should generally be an
/// [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
///
/// [`OnionMessenger`]: crate::onion_message::OnionMessenger
#[no_mangle]
pub extern "C" fn MessageHandler_get_onion_message_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::msgs::OnionMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().onion_message_handler;
	inner_val
}
/// A message handler which handles onion messages. This should generally be an
/// [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
///
/// [`OnionMessenger`]: crate::onion_message::OnionMessenger
#[no_mangle]
pub extern "C" fn MessageHandler_set_onion_message_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::msgs::OnionMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.onion_message_handler = val;
}
/// A message handler which handles custom messages. The only LDK-provided implementation is
/// [`IgnoringMessageHandler`].
#[no_mangle]
pub extern "C" fn MessageHandler_get_custom_message_handler(this_ptr: &MessageHandler) -> *const crate::lightning::ln::peer_handler::CustomMessageHandler {
	let mut inner_val = &mut this_ptr.get_native_mut_ref().custom_message_handler;
	inner_val
}
/// A message handler which handles custom messages. The only LDK-provided implementation is
/// [`IgnoringMessageHandler`].
#[no_mangle]
pub extern "C" fn MessageHandler_set_custom_message_handler(this_ptr: &mut MessageHandler, mut val: crate::lightning::ln::peer_handler::CustomMessageHandler) {
	unsafe { &mut *ObjOps::untweak_ptr(this_ptr.inner) }.custom_message_handler = val;
}
/// Constructs a new MessageHandler given each field
#[must_use]
#[no_mangle]
pub extern "C" fn MessageHandler_new(mut chan_handler_arg: crate::lightning::ln::msgs::ChannelMessageHandler, mut route_handler_arg: crate::lightning::ln::msgs::RoutingMessageHandler, mut onion_message_handler_arg: crate::lightning::ln::msgs::OnionMessageHandler, mut custom_message_handler_arg: crate::lightning::ln::peer_handler::CustomMessageHandler) -> MessageHandler {
	MessageHandler { inner: ObjOps::heap_alloc(nativeMessageHandler {
		chan_handler: chan_handler_arg,
		route_handler: route_handler_arg,
		onion_message_handler: onion_message_handler_arg,
		custom_message_handler: custom_message_handler_arg,
	}), is_owned: true }
}
/// Provides an object which can be used to send data to and which uniquely identifies a connection
/// to a remote host. You will need to be able to generate multiple of these which meet Eq and
/// implement Hash to meet the PeerManager API.
///
/// For efficiency, [`Clone`] should be relatively cheap for this type.
///
/// Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
/// has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
/// having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
/// further calls to the [`PeerManager`] related to the original socket occur. This allows you to
/// use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
/// to simply use another value which is guaranteed to be globally unique instead.
#[repr(C)]
pub struct SocketDescriptor {
	/// An opaque pointer which is passed to your function implementations as an argument.
	/// This has no meaning in the LDK, and can be NULL or any other value.
	pub this_arg: *mut c_void,
	/// Attempts to send some data from the given slice to the peer.
	///
	/// Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
	/// Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
	/// called and further write attempts may occur until that time.
	///
	/// If the returned size is smaller than `data.len()`, a
	/// [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
	/// written. Additionally, until a `send_data` event completes fully, no further
	/// [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
	/// prevent denial-of-service issues, you should not read or buffer any data from the socket
	/// until then.
	///
	/// If a [`PeerManager::read_event`] call on this descriptor had previously returned true
	/// (indicating that read events should be paused to prevent DoS in the send buffer),
	/// `resume_read` may be set indicating that read events on this descriptor should resume. A
	/// `resume_read` of false carries no meaning, and should not cause any action.
	pub send_data: extern "C" fn (this_arg: *mut c_void, data: crate::c_types::u8slice, resume_read: bool) -> usize,
	/// Disconnect the socket pointed to by this SocketDescriptor.
	///
	/// You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
	/// call (doing so is a noop).
	pub disconnect_socket: extern "C" fn (this_arg: *mut c_void),
	/// Checks if two objects are equal given this object's this_arg pointer and another object.
	pub eq: extern "C" fn (this_arg: *const c_void, other_arg: &SocketDescriptor) -> bool,
	/// Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
	/// This is used, for example, for inclusion of this object in a hash map.
	pub hash: extern "C" fn (this_arg: *const c_void) -> u64,
	/// Called, if set, after this SocketDescriptor has been cloned into a duplicate object.
	/// The new SocketDescriptor is provided, and should be mutated as needed to perform a
	/// deep copy of the object pointed to by this_arg or avoid any double-freeing.
	pub cloned: Option<extern "C" fn (new_SocketDescriptor: &mut SocketDescriptor)>,
	/// Frees any resources associated with this object given its this_arg pointer.
	/// Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
	pub free: Option<extern "C" fn(this_arg: *mut c_void)>,
}
unsafe impl Send for SocketDescriptor {}
unsafe impl Sync for SocketDescriptor {}
pub(crate) fn SocketDescriptor_clone_fields(orig: &SocketDescriptor) -> SocketDescriptor {
	SocketDescriptor {
		this_arg: orig.this_arg,
		send_data: Clone::clone(&orig.send_data),
		disconnect_socket: Clone::clone(&orig.disconnect_socket),
		eq: Clone::clone(&orig.eq),
		hash: Clone::clone(&orig.hash),
		cloned: Clone::clone(&orig.cloned),
		free: Clone::clone(&orig.free),
	}
}
impl core::cmp::Eq for SocketDescriptor {}
impl core::cmp::PartialEq for SocketDescriptor {
	fn eq(&self, o: &Self) -> bool { (self.eq)(self.this_arg, o) }
}
impl core::hash::Hash for SocketDescriptor {
	fn hash<H: core::hash::Hasher>(&self, hasher: &mut H) { hasher.write_u64((self.hash)(self.this_arg)) }
}
#[no_mangle]
/// Creates a copy of a SocketDescriptor
pub extern "C" fn SocketDescriptor_clone(orig: &SocketDescriptor) -> SocketDescriptor {
	let mut res = SocketDescriptor_clone_fields(orig);
	if let Some(f) = orig.cloned { (f)(&mut res) };
	res
}
impl Clone for SocketDescriptor {
	fn clone(&self) -> Self {
		SocketDescriptor_clone(self)
	}
}

use lightning::ln::peer_handler::SocketDescriptor as rustSocketDescriptor;
impl rustSocketDescriptor for SocketDescriptor {
	fn send_data(&mut self, mut data: &[u8], mut resume_read: bool) -> usize {
		let mut local_data = crate::c_types::u8slice::from_slice(data);
		let mut ret = (self.send_data)(self.this_arg, local_data, resume_read);
		ret
	}
	fn disconnect_socket(&mut self) {
		(self.disconnect_socket)(self.this_arg)
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl core::ops::Deref for SocketDescriptor {
	type Target = Self;
	fn deref(&self) -> &Self {
		self
	}
}
impl core::ops::DerefMut for SocketDescriptor {
	fn deref_mut(&mut self) -> &mut Self {
		self
	}
}
/// Calls the free function if one is set
#[no_mangle]
pub extern "C" fn SocketDescriptor_free(this_ptr: SocketDescriptor) { }
impl Drop for SocketDescriptor {
	fn drop(&mut self) {
		if let Some(f) = self.free {
			f(self.this_arg);
		}
	}
}

use lightning::ln::peer_handler::PeerHandleError as nativePeerHandleErrorImport;
pub(crate) type nativePeerHandleError = nativePeerHandleErrorImport;

/// Error for PeerManager errors. If you get one of these, you must disconnect the socket and
/// generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
/// descriptor.
#[must_use]
#[repr(C)]
pub struct PeerHandleError {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePeerHandleError,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for PeerHandleError {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePeerHandleError>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PeerHandleError_free(this_obj: PeerHandleError) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerHandleError_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePeerHandleError) };
}
#[allow(unused)]
impl PeerHandleError {
	pub(crate) fn get_native_ref(&self) -> &'static nativePeerHandleError {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePeerHandleError {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePeerHandleError {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
}
/// Constructs a new PeerHandleError given each field
#[must_use]
#[no_mangle]
pub extern "C" fn PeerHandleError_new() -> PeerHandleError {
	PeerHandleError { inner: ObjOps::heap_alloc(nativePeerHandleError {
	}), is_owned: true }
}
impl Clone for PeerHandleError {
	fn clone(&self) -> Self {
		Self {
			inner: if <*mut nativePeerHandleError>::is_null(self.inner) { core::ptr::null_mut() } else {
				ObjOps::heap_alloc(unsafe { &*ObjOps::untweak_ptr(self.inner) }.clone()) },
			is_owned: true,
		}
	}
}
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerHandleError_clone_void(this_ptr: *const c_void) -> *mut c_void {
	Box::into_raw(Box::new(unsafe { (*(this_ptr as *mut nativePeerHandleError)).clone() })) as *mut c_void
}
#[no_mangle]
/// Creates a copy of the PeerHandleError
pub extern "C" fn PeerHandleError_clone(orig: &PeerHandleError) -> PeerHandleError {
	orig.clone()
}

use lightning::ln::peer_handler::PeerManager as nativePeerManagerImport;
pub(crate) type nativePeerManager = nativePeerManagerImport<crate::lightning::ln::peer_handler::SocketDescriptor, crate::lightning::ln::msgs::ChannelMessageHandler, crate::lightning::ln::msgs::RoutingMessageHandler, crate::lightning::ln::msgs::OnionMessageHandler, crate::lightning::util::logger::Logger, crate::lightning::ln::peer_handler::CustomMessageHandler, crate::lightning::sign::NodeSigner>;

/// A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
/// socket events into messages which it passes on to its [`MessageHandler`].
///
/// Locks are taken internally, so you must never assume that reentrancy from a
/// [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
///
/// Calls to [`read_event`] will decode relevant messages and pass them to the
/// [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
/// parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
/// [`PeerManager`] functions related to the same connection must occur only in serial, making new
/// calls only after previous ones have returned.
///
/// Rather than using a plain [`PeerManager`], it is preferable to use either a [`SimpleArcPeerManager`]
/// a [`SimpleRefPeerManager`], for conciseness. See their documentation for more details, but
/// essentially you should default to using a [`SimpleRefPeerManager`], and use a
/// [`SimpleArcPeerManager`] when you require a `PeerManager` with a static lifetime, such as when
/// you're using lightning-net-tokio.
///
/// [`read_event`]: PeerManager::read_event
#[must_use]
#[repr(C)]
pub struct PeerManager {
	/// A pointer to the opaque Rust object.

	/// Nearly everywhere, inner must be non-null, however in places where
	/// the Rust equivalent takes an Option, it may be set to null to indicate None.
	pub inner: *mut nativePeerManager,
	/// Indicates that this is the only struct which contains the same pointer.

	/// Rust functions which take ownership of an object provided via an argument require
	/// this to be true and invalidate the object pointed to by inner.
	pub is_owned: bool,
}

impl Drop for PeerManager {
	fn drop(&mut self) {
		if self.is_owned && !<*mut nativePeerManager>::is_null(self.inner) {
			let _ = unsafe { Box::from_raw(ObjOps::untweak_ptr(self.inner)) };
		}
	}
}
/// Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
#[no_mangle]
pub extern "C" fn PeerManager_free(this_obj: PeerManager) { }
#[allow(unused)]
/// Used only if an object of this type is returned as a trait impl by a method
pub(crate) extern "C" fn PeerManager_free_void(this_ptr: *mut c_void) {
	let _ = unsafe { Box::from_raw(this_ptr as *mut nativePeerManager) };
}
#[allow(unused)]
impl PeerManager {
	pub(crate) fn get_native_ref(&self) -> &'static nativePeerManager {
		unsafe { &*ObjOps::untweak_ptr(self.inner) }
	}
	pub(crate) fn get_native_mut_ref(&self) -> &'static mut nativePeerManager {
		unsafe { &mut *ObjOps::untweak_ptr(self.inner) }
	}
	/// When moving out of the pointer, we have to ensure we aren't a reference, this makes that easy
	pub(crate) fn take_inner(mut self) -> *mut nativePeerManager {
		assert!(self.is_owned);
		let ret = ObjOps::untweak_ptr(self.inner);
		self.inner = core::ptr::null_mut();
		ret
	}
}
/// Constructs a new `PeerManager` with the given message handlers.
///
/// `ephemeral_random_data` is used to derive per-connection ephemeral keys and must be
/// cryptographically secure random bytes.
///
/// `current_time` is used as an always-increasing counter that survives across restarts and is
/// incremented irregularly internally. In general it is best to simply use the current UNIX
/// timestamp, however if it is not available a persistent counter that increases once per
/// minute should suffice.
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_new(mut message_handler: crate::lightning::ln::peer_handler::MessageHandler, mut current_time: u32, ephemeral_random_data: *const [u8; 32], mut logger: crate::lightning::util::logger::Logger, mut node_signer: crate::lightning::sign::NodeSigner) -> crate::lightning::ln::peer_handler::PeerManager {
	let mut ret = lightning::ln::peer_handler::PeerManager::new(*unsafe { Box::from_raw(message_handler.take_inner()) }, current_time, unsafe { &*ephemeral_random_data}, logger, node_signer);
	crate::lightning::ln::peer_handler::PeerManager { inner: ObjOps::heap_alloc(ret), is_owned: true }
}

/// Get a list of tuples mapping from node id to network addresses for peers which have
/// completed the initial handshake.
///
/// For outbound connections, the [`PublicKey`] will be the same as the `their_node_id` parameter
/// passed in to [`Self::new_outbound_connection`], however entries will only appear once the initial
/// handshake has completed and we are sure the remote peer has the private key for the given
/// [`PublicKey`].
///
/// The returned `Option`s will only be `Some` if an address had been previously given via
/// [`Self::new_outbound_connection`] or [`Self::new_inbound_connection`].
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_get_peer_node_ids(this_arg: &crate::lightning::ln::peer_handler::PeerManager) -> crate::c_types::derived::CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.get_peer_node_ids();
	let mut local_ret = Vec::new(); for mut item in ret.drain(..) { local_ret.push( { let (mut orig_ret_0_0, mut orig_ret_0_1) = item; let mut local_orig_ret_0_1 = if orig_ret_0_1.is_none() { crate::c_types::derived::COption_SocketAddressZ::None } else { crate::c_types::derived::COption_SocketAddressZ::Some( { crate::lightning::ln::msgs::SocketAddress::native_into(orig_ret_0_1.unwrap()) }) }; let mut local_ret_0 = (crate::c_types::PublicKey::from_rust(&orig_ret_0_0), local_orig_ret_0_1).into(); local_ret_0 }); };
	local_ret.into()
}

/// Indicates a new outbound connection has been established to a node with the given `node_id`
/// and an optional remote network address.
///
/// The remote network address adds the option to report a remote IP address back to a connecting
/// peer using the init message.
/// The user should pass the remote network address of the host they are connected to.
///
/// If an `Err` is returned here you must disconnect the connection immediately.
///
/// Returns a small number of bytes to send to the remote node (currently always 50).
///
/// Panics if descriptor is duplicative with some other descriptor which has not yet been
/// [`socket_disconnected`].
///
/// [`socket_disconnected`]: PeerManager::socket_disconnected
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_new_outbound_connection(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut their_node_id: crate::c_types::PublicKey, mut descriptor: crate::lightning::ln::peer_handler::SocketDescriptor, mut remote_network_address: crate::c_types::derived::COption_SocketAddressZ) -> crate::c_types::derived::CResult_CVec_u8ZPeerHandleErrorZ {
	let mut local_remote_network_address = { /*remote_network_address*/ let remote_network_address_opt = remote_network_address; if remote_network_address_opt.is_none() { None } else { Some({ { { remote_network_address_opt.take() }.into_native() }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.new_outbound_connection(their_node_id.into_rust(), descriptor, local_remote_network_address);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { let mut local_ret_0 = Vec::new(); for mut item in o.drain(..) { local_ret_0.push( { item }); }; local_ret_0.into() }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Indicates a new inbound connection has been established to a node with an optional remote
/// network address.
///
/// The remote network address adds the option to report a remote IP address back to a connecting
/// peer using the init message.
/// The user should pass the remote network address of the host they are connected to.
///
/// May refuse the connection by returning an Err, but will never write bytes to the remote end
/// (outbound connector always speaks first). If an `Err` is returned here you must disconnect
/// the connection immediately.
///
/// Panics if descriptor is duplicative with some other descriptor which has not yet been
/// [`socket_disconnected`].
///
/// [`socket_disconnected`]: PeerManager::socket_disconnected
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_new_inbound_connection(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut descriptor: crate::lightning::ln::peer_handler::SocketDescriptor, mut remote_network_address: crate::c_types::derived::COption_SocketAddressZ) -> crate::c_types::derived::CResult_NonePeerHandleErrorZ {
	let mut local_remote_network_address = { /*remote_network_address*/ let remote_network_address_opt = remote_network_address; if remote_network_address_opt.is_none() { None } else { Some({ { { remote_network_address_opt.take() }.into_native() }})} };
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.new_inbound_connection(descriptor, local_remote_network_address);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Indicates that there is room to write data to the given socket descriptor.
///
/// May return an Err to indicate that the connection should be closed.
///
/// May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
/// returning. Thus, be very careful with reentrancy issues! The invariants around calling
/// [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
/// ready to call [`write_buffer_space_avail`] again if a write call generated here isn't
/// sufficient!
///
/// [`send_data`]: SocketDescriptor::send_data
/// [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_write_buffer_space_avail(this_arg: &crate::lightning::ln::peer_handler::PeerManager, descriptor: &mut crate::lightning::ln::peer_handler::SocketDescriptor) -> crate::c_types::derived::CResult_NonePeerHandleErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.write_buffer_space_avail(descriptor);
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { () /*o*/ }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Indicates that data was read from the given socket descriptor.
///
/// May return an Err to indicate that the connection should be closed.
///
/// Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
/// Thus, however, you should call [`process_events`] after any `read_event` to generate
/// [`send_data`] calls to handle responses.
///
/// If `Ok(true)` is returned, further read_events should not be triggered until a
/// [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
/// send buffer).
///
/// In order to avoid processing too many messages at once per peer, `data` should be on the
/// order of 4KiB.
///
/// [`send_data`]: SocketDescriptor::send_data
/// [`process_events`]: PeerManager::process_events
#[must_use]
#[no_mangle]
pub extern "C" fn PeerManager_read_event(this_arg: &crate::lightning::ln::peer_handler::PeerManager, peer_descriptor: &mut crate::lightning::ln::peer_handler::SocketDescriptor, mut data: crate::c_types::u8slice) -> crate::c_types::derived::CResult_boolPeerHandleErrorZ {
	let mut ret = unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.read_event(peer_descriptor, data.to_slice());
	let mut local_ret = match ret { Ok(mut o) => crate::c_types::CResultTempl::ok( { o }).into(), Err(mut e) => crate::c_types::CResultTempl::err( { crate::lightning::ln::peer_handler::PeerHandleError { inner: ObjOps::heap_alloc(e), is_owned: true } }).into() };
	local_ret
}

/// Checks for any events generated by our handlers and processes them. Includes sending most
/// response messages as well as messages generated by calls to handler functions directly (eg
/// functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
///
/// May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
/// issues!
///
/// You don't have to call this function explicitly if you are using [`lightning-net-tokio`]
/// or one of the other clients provided in our language bindings.
///
/// Note that if there are any other calls to this function waiting on lock(s) this may return
/// without doing any work. All available events that need handling will be handled before the
/// other calls return.
///
/// [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
/// [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
/// [`send_data`]: SocketDescriptor::send_data
#[no_mangle]
pub extern "C" fn PeerManager_process_events(this_arg: &crate::lightning::ln::peer_handler::PeerManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.process_events()
}

/// Indicates that the given socket descriptor's connection is now closed.
#[no_mangle]
pub extern "C" fn PeerManager_socket_disconnected(this_arg: &crate::lightning::ln::peer_handler::PeerManager, descriptor: &crate::lightning::ln::peer_handler::SocketDescriptor) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.socket_disconnected(descriptor)
}

/// Disconnect a peer given its node id.
///
/// If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
/// peer. Thus, be very careful about reentrancy issues.
///
/// [`disconnect_socket`]: SocketDescriptor::disconnect_socket
#[no_mangle]
pub extern "C" fn PeerManager_disconnect_by_node_id(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut node_id: crate::c_types::PublicKey) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.disconnect_by_node_id(node_id.into_rust())
}

/// Disconnects all currently-connected peers. This is useful on platforms where there may be
/// an indication that TCP sockets have stalled even if we weren't around to time them out
/// using regular ping/pongs.
#[no_mangle]
pub extern "C" fn PeerManager_disconnect_all_peers(this_arg: &crate::lightning::ln::peer_handler::PeerManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.disconnect_all_peers()
}

/// Send pings to each peer and disconnect those which did not respond to the last round of
/// pings.
///
/// This may be called on any timescale you want, however, roughly once every ten seconds is
/// preferred. The call rate determines both how often we send a ping to our peers and how much
/// time they have to respond before we disconnect them.
///
/// May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
/// issues!
///
/// [`send_data`]: SocketDescriptor::send_data
#[no_mangle]
pub extern "C" fn PeerManager_timer_tick_occurred(this_arg: &crate::lightning::ln::peer_handler::PeerManager) {
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.timer_tick_occurred()
}

/// Generates a signed node_announcement from the given arguments, sending it to all connected
/// peers. Note that peers will likely ignore this message unless we have at least one public
/// channel which has at least six confirmations on-chain.
///
/// `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
/// node to humans. They carry no in-protocol meaning.
///
/// `addresses` represent the set (possibly empty) of socket addresses on which this node
/// accepts incoming connections. These will be included in the node_announcement, publicly
/// tying these addresses together and to this node. If you wish to preserve user privacy,
/// addresses should likely contain only Tor Onion addresses.
///
/// Panics if `addresses` is absurdly large (more than 100).
///
/// [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
#[no_mangle]
pub extern "C" fn PeerManager_broadcast_node_announcement(this_arg: &crate::lightning::ln::peer_handler::PeerManager, mut rgb: crate::c_types::ThreeBytes, mut alias: crate::c_types::ThirtyTwoBytes, mut addresses: crate::c_types::derived::CVec_SocketAddressZ) {
	let mut local_addresses = Vec::new(); for mut item in addresses.into_rust().drain(..) { local_addresses.push( { item.into_native() }); };
	unsafe { &*ObjOps::untweak_ptr(this_arg.inner) }.broadcast_node_announcement(rgb.data, alias.data, local_addresses)
}

use core::convert::Infallible as nativeInfallible;
