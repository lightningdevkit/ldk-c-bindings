
use alloc::str::FromStr;
use alloc::string::String;
use core::ffi::c_void;
use core::convert::Infallible;
use bitcoin::hashes::Hash;
use crate::c_types::*;
#[cfg(feature="no-std")]
use alloc::{vec::Vec, boxed::Box};

#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a u64 or not
pub enum COption_u64Z {
	/// When we're in this state, this COption_u64Z contains a u64
	Some(u64),
	/// When we're in this state, this COption_u64Z contains nothing
	None
}
impl COption_u64Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> u64 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_u64Z containing a u64
pub extern "C" fn COption_u64Z_some(o: u64) -> COption_u64Z {
	COption_u64Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_u64Z containing nothing
pub extern "C" fn COption_u64Z_none() -> COption_u64Z {
	COption_u64Z::None
}
#[no_mangle]
/// Frees any resources associated with the u64, if we are in the Some state
pub extern "C" fn COption_u64Z_free(_res: COption_u64Z) { }
#[no_mangle]
/// Creates a new COption_u64Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_u64Z_clone(orig: &COption_u64Z) -> COption_u64Z { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::BlindedPaths of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BlindedPathZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::BlindedPath,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BlindedPathZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::BlindedPath> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::BlindedPath] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::BlindedPath>> for CVec_BlindedPathZ {
	fn from(v: Vec<crate::lightning::blinded_path::BlindedPath>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BlindedPathZ_free(_res: CVec_BlindedPathZ) { }
impl Drop for CVec_BlindedPathZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BlindedPathZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RefundBolt12ParseErrorZ
pub union CResult_RefundBolt12ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::refund::Refund,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12ParseError,
}
#[repr(C)]
/// A CResult_RefundBolt12ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::refund::Refund on success and a crate::lightning::offers::parse::Bolt12ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RefundBolt12ParseErrorZ {
	/// The contents of this CResult_RefundBolt12ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RefundBolt12ParseErrorZPtr,
	/// Whether this CResult_RefundBolt12ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12ParseErrorZ in the success state.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_ok(o: crate::lightning::offers::refund::Refund) -> CResult_RefundBolt12ParseErrorZ {
	CResult_RefundBolt12ParseErrorZ {
		contents: CResult_RefundBolt12ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12ParseErrorZ in the error state.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_err(e: crate::lightning::offers::parse::Bolt12ParseError) -> CResult_RefundBolt12ParseErrorZ {
	CResult_RefundBolt12ParseErrorZ {
		contents: CResult_RefundBolt12ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_is_ok(o: &CResult_RefundBolt12ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RefundBolt12ParseErrorZ.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_free(_res: CResult_RefundBolt12ParseErrorZ) { }
impl Drop for CResult_RefundBolt12ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::offers::parse::Bolt12ParseError>> for CResult_RefundBolt12ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::refund::Refund, crate::lightning::offers::parse::Bolt12ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RefundBolt12ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RefundBolt12ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RefundBolt12ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RefundBolt12ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::refund::Refund>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RefundBolt12ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RefundBolt12ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RefundBolt12ParseErrorZ_clone(orig: &CResult_RefundBolt12ParseErrorZ) -> CResult_RefundBolt12ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RetryDecodeErrorZ
pub union CResult_RetryDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::outbound_payment::Retry,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RetryDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::outbound_payment::Retry on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RetryDecodeErrorZ {
	/// The contents of this CResult_RetryDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RetryDecodeErrorZPtr,
	/// Whether this CResult_RetryDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RetryDecodeErrorZ in the success state.
pub extern "C" fn CResult_RetryDecodeErrorZ_ok(o: crate::lightning::ln::outbound_payment::Retry) -> CResult_RetryDecodeErrorZ {
	CResult_RetryDecodeErrorZ {
		contents: CResult_RetryDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RetryDecodeErrorZ in the error state.
pub extern "C" fn CResult_RetryDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RetryDecodeErrorZ {
	CResult_RetryDecodeErrorZ {
		contents: CResult_RetryDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RetryDecodeErrorZ_is_ok(o: &CResult_RetryDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RetryDecodeErrorZ.
pub extern "C" fn CResult_RetryDecodeErrorZ_free(_res: CResult_RetryDecodeErrorZ) { }
impl Drop for CResult_RetryDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::Retry, crate::lightning::ln::msgs::DecodeError>> for CResult_RetryDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::Retry, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RetryDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RetryDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RetryDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RetryDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::Retry>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RetryDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RetryDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RetryDecodeErrorZ_clone(orig: &CResult_RetryDecodeErrorZ) -> CResult_RetryDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneAPIErrorZ
pub union CResult_NoneAPIErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::util::errors::APIError,
}
#[repr(C)]
/// A CResult_NoneAPIErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneAPIErrorZ {
	/// The contents of this CResult_NoneAPIErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneAPIErrorZPtr,
	/// Whether this CResult_NoneAPIErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneAPIErrorZ in the success state.
pub extern "C" fn CResult_NoneAPIErrorZ_ok() -> CResult_NoneAPIErrorZ {
	CResult_NoneAPIErrorZ {
		contents: CResult_NoneAPIErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneAPIErrorZ in the error state.
pub extern "C" fn CResult_NoneAPIErrorZ_err(e: crate::lightning::util::errors::APIError) -> CResult_NoneAPIErrorZ {
	CResult_NoneAPIErrorZ {
		contents: CResult_NoneAPIErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneAPIErrorZ_is_ok(o: &CResult_NoneAPIErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneAPIErrorZ.
pub extern "C" fn CResult_NoneAPIErrorZ_free(_res: CResult_NoneAPIErrorZ) { }
impl Drop for CResult_NoneAPIErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::util::errors::APIError>> for CResult_NoneAPIErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::util::errors::APIError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneAPIErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneAPIErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneAPIErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneAPIErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneAPIErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::util::errors::APIError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneAPIErrorZ_clone(orig: &CResult_NoneAPIErrorZ) -> CResult_NoneAPIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::CResult_NoneAPIErrorZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_CResult_NoneAPIErrorZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::CResult_NoneAPIErrorZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_CResult_NoneAPIErrorZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::CResult_NoneAPIErrorZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::CResult_NoneAPIErrorZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::CResult_NoneAPIErrorZ>> for CVec_CResult_NoneAPIErrorZZ {
	fn from(v: Vec<crate::c_types::derived::CResult_NoneAPIErrorZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_CResult_NoneAPIErrorZZ_free(_res: CVec_CResult_NoneAPIErrorZZ) { }
impl Drop for CVec_CResult_NoneAPIErrorZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_CResult_NoneAPIErrorZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::util::errors::APIErrors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_APIErrorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::util::errors::APIError,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_APIErrorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::util::errors::APIError> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::util::errors::APIError] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::util::errors::APIError>> for CVec_APIErrorZ {
	fn from(v: Vec<crate::lightning::util::errors::APIError>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_APIErrorZ_free(_res: CVec_APIErrorZ) { }
impl Drop for CVec_APIErrorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_APIErrorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::ThirtyTwoBytes or not
pub enum COption_ThirtyTwoBytesZ {
	/// When we're in this state, this COption_ThirtyTwoBytesZ contains a crate::c_types::ThirtyTwoBytes
	Some(crate::c_types::ThirtyTwoBytes),
	/// When we're in this state, this COption_ThirtyTwoBytesZ contains nothing
	None
}
impl COption_ThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::ThirtyTwoBytes {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ThirtyTwoBytesZ containing a crate::c_types::ThirtyTwoBytes
pub extern "C" fn COption_ThirtyTwoBytesZ_some(o: crate::c_types::ThirtyTwoBytes) -> COption_ThirtyTwoBytesZ {
	COption_ThirtyTwoBytesZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ThirtyTwoBytesZ containing nothing
pub extern "C" fn COption_ThirtyTwoBytesZ_none() -> COption_ThirtyTwoBytesZ {
	COption_ThirtyTwoBytesZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::ThirtyTwoBytes, if we are in the Some state
pub extern "C" fn COption_ThirtyTwoBytesZ_free(_res: COption_ThirtyTwoBytesZ) { }
#[no_mangle]
/// Creates a new COption_ThirtyTwoBytesZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ThirtyTwoBytesZ_clone(orig: &COption_ThirtyTwoBytesZ) -> COption_ThirtyTwoBytesZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of u8s of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_u8Z {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut u8,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_u8Z {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<u8> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[u8] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<u8>> for CVec_u8Z {
	fn from(v: Vec<u8>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_u8Z_free(_res: CVec_u8Z) { }
impl Drop for CVec_u8Z {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_u8Z {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::CVec_u8Z or not
pub enum COption_CVec_u8ZZ {
	/// When we're in this state, this COption_CVec_u8ZZ contains a crate::c_types::derived::CVec_u8Z
	Some(crate::c_types::derived::CVec_u8Z),
	/// When we're in this state, this COption_CVec_u8ZZ contains nothing
	None
}
impl COption_CVec_u8ZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::CVec_u8Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_CVec_u8ZZ containing a crate::c_types::derived::CVec_u8Z
pub extern "C" fn COption_CVec_u8ZZ_some(o: crate::c_types::derived::CVec_u8Z) -> COption_CVec_u8ZZ {
	COption_CVec_u8ZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_CVec_u8ZZ containing nothing
pub extern "C" fn COption_CVec_u8ZZ_none() -> COption_CVec_u8ZZ {
	COption_CVec_u8ZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::CVec_u8Z, if we are in the Some state
pub extern "C" fn COption_CVec_u8ZZ_free(_res: COption_CVec_u8ZZ) { }
#[no_mangle]
/// Creates a new COption_CVec_u8ZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_CVec_u8ZZ_clone(orig: &COption_CVec_u8ZZ) -> COption_CVec_u8ZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RecipientOnionFieldsDecodeErrorZ
pub union CResult_RecipientOnionFieldsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::outbound_payment::RecipientOnionFields,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RecipientOnionFieldsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::outbound_payment::RecipientOnionFields on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RecipientOnionFieldsDecodeErrorZ {
	/// The contents of this CResult_RecipientOnionFieldsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RecipientOnionFieldsDecodeErrorZPtr,
	/// Whether this CResult_RecipientOnionFieldsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsDecodeErrorZ in the success state.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_ok(o: crate::lightning::ln::outbound_payment::RecipientOnionFields) -> CResult_RecipientOnionFieldsDecodeErrorZ {
	CResult_RecipientOnionFieldsDecodeErrorZ {
		contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsDecodeErrorZ in the error state.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RecipientOnionFieldsDecodeErrorZ {
	CResult_RecipientOnionFieldsDecodeErrorZ {
		contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_is_ok(o: &CResult_RecipientOnionFieldsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RecipientOnionFieldsDecodeErrorZ.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_free(_res: CResult_RecipientOnionFieldsDecodeErrorZ) { }
impl Drop for CResult_RecipientOnionFieldsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::ln::msgs::DecodeError>> for CResult_RecipientOnionFieldsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RecipientOnionFieldsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RecipientOnionFieldsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RecipientOnionFieldsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RecipientOnionFields>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RecipientOnionFieldsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RecipientOnionFieldsDecodeErrorZ_clone(orig: &CResult_RecipientOnionFieldsDecodeErrorZ) -> CResult_RecipientOnionFieldsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u64CVec_u8ZZ {
	/// The element at position 0
	pub a: u64,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u8Z,
}
impl From<(u64, crate::c_types::derived::CVec_u8Z)> for C2Tuple_u64CVec_u8ZZ {
	fn from (tup: (u64, crate::c_types::derived::CVec_u8Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u64CVec_u8ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u64, crate::c_types::derived::CVec_u8Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u64CVec_u8ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u64CVec_u8ZZ_clone(orig: &C2Tuple_u64CVec_u8ZZ) -> C2Tuple_u64CVec_u8ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_u64CVec_u8ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u64CVec_u8ZZ_new(a: u64, b: crate::c_types::derived::CVec_u8Z) -> C2Tuple_u64CVec_u8ZZ {
	C2Tuple_u64CVec_u8ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u64CVec_u8ZZ.
pub extern "C" fn C2Tuple_u64CVec_u8ZZ_free(_res: C2Tuple_u64CVec_u8ZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u64CVec_u8ZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_u64CVec_u8ZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_u64CVec_u8ZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_u64CVec_u8ZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_u64CVec_u8ZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_u64CVec_u8ZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_u64CVec_u8ZZ>> for CVec_C2Tuple_u64CVec_u8ZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_u64CVec_u8ZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_u64CVec_u8ZZZ_free(_res: CVec_C2Tuple_u64CVec_u8ZZZ) { }
impl Drop for CVec_C2Tuple_u64CVec_u8ZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_u64CVec_u8ZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RecipientOnionFieldsNoneZ
pub union CResult_RecipientOnionFieldsNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::outbound_payment::RecipientOnionFields,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_RecipientOnionFieldsNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::outbound_payment::RecipientOnionFields on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RecipientOnionFieldsNoneZ {
	/// The contents of this CResult_RecipientOnionFieldsNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RecipientOnionFieldsNoneZPtr,
	/// Whether this CResult_RecipientOnionFieldsNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsNoneZ in the success state.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_ok(o: crate::lightning::ln::outbound_payment::RecipientOnionFields) -> CResult_RecipientOnionFieldsNoneZ {
	CResult_RecipientOnionFieldsNoneZ {
		contents: CResult_RecipientOnionFieldsNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsNoneZ in the error state.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_err() -> CResult_RecipientOnionFieldsNoneZ {
	CResult_RecipientOnionFieldsNoneZ {
		contents: CResult_RecipientOnionFieldsNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_is_ok(o: &CResult_RecipientOnionFieldsNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RecipientOnionFieldsNoneZ.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_free(_res: CResult_RecipientOnionFieldsNoneZ) { }
impl Drop for CResult_RecipientOnionFieldsNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, ()>> for CResult_RecipientOnionFieldsNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::outbound_payment::RecipientOnionFields, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RecipientOnionFieldsNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_RecipientOnionFieldsNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RecipientOnionFieldsNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RecipientOnionFieldsNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RecipientOnionFields>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RecipientOnionFieldsNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RecipientOnionFieldsNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RecipientOnionFieldsNoneZ_clone(orig: &CResult_RecipientOnionFieldsNoneZ) -> CResult_RecipientOnionFieldsNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ThirtyTwoBytesZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::ThirtyTwoBytes,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::ThirtyTwoBytes> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::ThirtyTwoBytes] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::ThirtyTwoBytes>> for CVec_ThirtyTwoBytesZ {
	fn from(v: Vec<crate::c_types::ThirtyTwoBytes>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ThirtyTwoBytesZ_free(_res: CVec_ThirtyTwoBytesZ) { }
impl Drop for CVec_ThirtyTwoBytesZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ThirtyTwoBytesZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::CVec_ThirtyTwoBytesZ or not
pub enum COption_CVec_ThirtyTwoBytesZZ {
	/// When we're in this state, this COption_CVec_ThirtyTwoBytesZZ contains a crate::c_types::derived::CVec_ThirtyTwoBytesZ
	Some(crate::c_types::derived::CVec_ThirtyTwoBytesZ),
	/// When we're in this state, this COption_CVec_ThirtyTwoBytesZZ contains nothing
	None
}
impl COption_CVec_ThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::CVec_ThirtyTwoBytesZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_CVec_ThirtyTwoBytesZZ containing a crate::c_types::derived::CVec_ThirtyTwoBytesZ
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_some(o: crate::c_types::derived::CVec_ThirtyTwoBytesZ) -> COption_CVec_ThirtyTwoBytesZZ {
	COption_CVec_ThirtyTwoBytesZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_CVec_ThirtyTwoBytesZZ containing nothing
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_none() -> COption_CVec_ThirtyTwoBytesZZ {
	COption_CVec_ThirtyTwoBytesZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::CVec_ThirtyTwoBytesZ, if we are in the Some state
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_free(_res: COption_CVec_ThirtyTwoBytesZZ) { }
#[no_mangle]
/// Creates a new COption_CVec_ThirtyTwoBytesZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_CVec_ThirtyTwoBytesZZ_clone(orig: &COption_CVec_ThirtyTwoBytesZZ) -> COption_CVec_ThirtyTwoBytesZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesNoneZ
pub union CResult_ThirtyTwoBytesNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesNoneZ {
	/// The contents of this CResult_ThirtyTwoBytesNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesNoneZPtr,
	/// Whether this CResult_ThirtyTwoBytesNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesNoneZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesNoneZ {
	CResult_ThirtyTwoBytesNoneZ {
		contents: CResult_ThirtyTwoBytesNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesNoneZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_err() -> CResult_ThirtyTwoBytesNoneZ {
	CResult_ThirtyTwoBytesNoneZ {
		contents: CResult_ThirtyTwoBytesNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_is_ok(o: &CResult_ThirtyTwoBytesNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesNoneZ.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_free(_res: CResult_ThirtyTwoBytesNoneZ) { }
impl Drop for CResult_ThirtyTwoBytesNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, ()>> for CResult_ThirtyTwoBytesNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ThirtyTwoBytesNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesNoneZ_clone(orig: &CResult_ThirtyTwoBytesNoneZ) -> CResult_ThirtyTwoBytesNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedPayInfoDecodeErrorZ
pub union CResult_BlindedPayInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice::BlindedPayInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedPayInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice::BlindedPayInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedPayInfoDecodeErrorZ {
	/// The contents of this CResult_BlindedPayInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedPayInfoDecodeErrorZPtr,
	/// Whether this CResult_BlindedPayInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedPayInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_ok(o: crate::lightning::offers::invoice::BlindedPayInfo) -> CResult_BlindedPayInfoDecodeErrorZ {
	CResult_BlindedPayInfoDecodeErrorZ {
		contents: CResult_BlindedPayInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPayInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedPayInfoDecodeErrorZ {
	CResult_BlindedPayInfoDecodeErrorZ {
		contents: CResult_BlindedPayInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_is_ok(o: &CResult_BlindedPayInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedPayInfoDecodeErrorZ.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_free(_res: CResult_BlindedPayInfoDecodeErrorZ) { }
impl Drop for CResult_BlindedPayInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice::BlindedPayInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedPayInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice::BlindedPayInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedPayInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedPayInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedPayInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedPayInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice::BlindedPayInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedPayInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPayInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedPayInfoDecodeErrorZ_clone(orig: &CResult_BlindedPayInfoDecodeErrorZ) -> CResult_BlindedPayInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
pub union CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::DelayedPaymentOutputDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	/// The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr,
	/// Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::DelayedPaymentOutputDescriptor) -> CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o: &CResult_DelayedPaymentOutputDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res: CResult_DelayedPaymentOutputDescriptorDecodeErrorZ) { }
impl Drop for CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::DelayedPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::DelayedPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::DelayedPaymentOutputDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig: &CResult_DelayedPaymentOutputDescriptorDecodeErrorZ) -> CResult_DelayedPaymentOutputDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
pub union CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::StaticPaymentOutputDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	/// The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr,
	/// Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::StaticPaymentOutputDescriptor) -> CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
		contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o: &CResult_StaticPaymentOutputDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res: CResult_StaticPaymentOutputDescriptorDecodeErrorZ) { }
impl Drop for CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::StaticPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::StaticPaymentOutputDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_StaticPaymentOutputDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::StaticPaymentOutputDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig: &CResult_StaticPaymentOutputDescriptorDecodeErrorZ) -> CResult_StaticPaymentOutputDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
pub union CResult_SpendableOutputDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::SpendableOutputDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpendableOutputDescriptorDecodeErrorZ {
	/// The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr,
	/// Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::SpendableOutputDescriptor) -> CResult_SpendableOutputDescriptorDecodeErrorZ {
	CResult_SpendableOutputDescriptorDecodeErrorZ {
		contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpendableOutputDescriptorDecodeErrorZ {
	CResult_SpendableOutputDescriptorDecodeErrorZ {
		contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o: &CResult_SpendableOutputDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res: CResult_SpendableOutputDescriptorDecodeErrorZ) { }
impl Drop for CResult_SpendableOutputDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::SpendableOutputDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_SpendableOutputDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::SpendableOutputDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpendableOutputDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpendableOutputDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpendableOutputDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::SpendableOutputDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpendableOutputDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig: &CResult_SpendableOutputDescriptorDecodeErrorZ) -> CResult_SpendableOutputDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::sign::SpendableOutputDescriptors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_SpendableOutputDescriptorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::sign::SpendableOutputDescriptor,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_SpendableOutputDescriptorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::sign::SpendableOutputDescriptor> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::sign::SpendableOutputDescriptor] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::sign::SpendableOutputDescriptor>> for CVec_SpendableOutputDescriptorZ {
	fn from(v: Vec<crate::lightning::sign::SpendableOutputDescriptor>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_SpendableOutputDescriptorZ_free(_res: CVec_SpendableOutputDescriptorZ) { }
impl Drop for CVec_SpendableOutputDescriptorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_SpendableOutputDescriptorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TxOutZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::TxOut,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TxOutZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::TxOut> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::TxOut] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::TxOut>> for CVec_TxOutZ {
	fn from(v: Vec<crate::c_types::TxOut>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TxOutZ_free(_res: CVec_TxOutZ) { }
impl Drop for CVec_TxOutZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TxOutZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a u32 or not
pub enum COption_u32Z {
	/// When we're in this state, this COption_u32Z contains a u32
	Some(u32),
	/// When we're in this state, this COption_u32Z contains nothing
	None
}
impl COption_u32Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> u32 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_u32Z containing a u32
pub extern "C" fn COption_u32Z_some(o: u32) -> COption_u32Z {
	COption_u32Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_u32Z containing nothing
pub extern "C" fn COption_u32Z_none() -> COption_u32Z {
	COption_u32Z::None
}
#[no_mangle]
/// Frees any resources associated with the u32, if we are in the Some state
pub extern "C" fn COption_u32Z_free(_res: COption_u32Z) { }
#[no_mangle]
/// Creates a new COption_u32Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_u32Z_clone(orig: &COption_u32Z) -> COption_u32Z { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_CVec_u8Zu64Z {
	/// The element at position 0
	pub a: crate::c_types::derived::CVec_u8Z,
	/// The element at position 1
	pub b: u64,
}
impl From<(crate::c_types::derived::CVec_u8Z, u64)> for C2Tuple_CVec_u8Zu64Z {
	fn from (tup: (crate::c_types::derived::CVec_u8Z, u64)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_CVec_u8Zu64Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::derived::CVec_u8Z, u64) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_CVec_u8Zu64Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_CVec_u8Zu64Z_clone(orig: &C2Tuple_CVec_u8Zu64Z) -> C2Tuple_CVec_u8Zu64Z { Clone::clone(&orig) }
/// Creates a new C2Tuple_CVec_u8Zu64Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_CVec_u8Zu64Z_new(a: crate::c_types::derived::CVec_u8Z, b: u64) -> C2Tuple_CVec_u8Zu64Z {
	C2Tuple_CVec_u8Zu64Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_CVec_u8Zu64Z.
pub extern "C" fn C2Tuple_CVec_u8Zu64Z_free(_res: C2Tuple_CVec_u8Zu64Z) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_CVec_u8Zu64ZNoneZ
pub union CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_CVec_u8Zu64Z,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_CVec_u8Zu64ZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_CVec_u8Zu64Z on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	/// The contents of this CResult_C2Tuple_CVec_u8Zu64ZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr,
	/// Whether this CResult_C2Tuple_CVec_u8Zu64ZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_CVec_u8Zu64ZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_ok(o: crate::c_types::derived::C2Tuple_CVec_u8Zu64Z) -> CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
		contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_CVec_u8Zu64ZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_err() -> CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
		contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_is_ok(o: &CResult_C2Tuple_CVec_u8Zu64ZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_CVec_u8Zu64ZNoneZ.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_free(_res: CResult_C2Tuple_CVec_u8Zu64ZNoneZ) { }
impl Drop for CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_CVec_u8Zu64Z, ()>> for CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_CVec_u8Zu64Z, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_CVec_u8Zu64ZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_CVec_u8Zu64Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_CVec_u8Zu64ZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_CVec_u8Zu64ZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_CVec_u8Zu64ZNoneZ_clone(orig: &CResult_C2Tuple_CVec_u8Zu64ZNoneZ) -> CResult_C2Tuple_CVec_u8Zu64ZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelDerivationParametersDecodeErrorZ
pub union CResult_ChannelDerivationParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::ChannelDerivationParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelDerivationParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::ChannelDerivationParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelDerivationParametersDecodeErrorZ {
	/// The contents of this CResult_ChannelDerivationParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelDerivationParametersDecodeErrorZPtr,
	/// Whether this CResult_ChannelDerivationParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelDerivationParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_ok(o: crate::lightning::sign::ChannelDerivationParameters) -> CResult_ChannelDerivationParametersDecodeErrorZ {
	CResult_ChannelDerivationParametersDecodeErrorZ {
		contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDerivationParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelDerivationParametersDecodeErrorZ {
	CResult_ChannelDerivationParametersDecodeErrorZ {
		contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_is_ok(o: &CResult_ChannelDerivationParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelDerivationParametersDecodeErrorZ.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_free(_res: CResult_ChannelDerivationParametersDecodeErrorZ) { }
impl Drop for CResult_ChannelDerivationParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::ChannelDerivationParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelDerivationParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::ChannelDerivationParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelDerivationParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelDerivationParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelDerivationParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::ChannelDerivationParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelDerivationParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDerivationParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelDerivationParametersDecodeErrorZ_clone(orig: &CResult_ChannelDerivationParametersDecodeErrorZ) -> CResult_ChannelDerivationParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HTLCDescriptorDecodeErrorZ
pub union CResult_HTLCDescriptorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::HTLCDescriptor,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HTLCDescriptorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::HTLCDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HTLCDescriptorDecodeErrorZ {
	/// The contents of this CResult_HTLCDescriptorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HTLCDescriptorDecodeErrorZPtr,
	/// Whether this CResult_HTLCDescriptorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HTLCDescriptorDecodeErrorZ in the success state.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_ok(o: crate::lightning::sign::HTLCDescriptor) -> CResult_HTLCDescriptorDecodeErrorZ {
	CResult_HTLCDescriptorDecodeErrorZ {
		contents: CResult_HTLCDescriptorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCDescriptorDecodeErrorZ in the error state.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HTLCDescriptorDecodeErrorZ {
	CResult_HTLCDescriptorDecodeErrorZ {
		contents: CResult_HTLCDescriptorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_is_ok(o: &CResult_HTLCDescriptorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HTLCDescriptorDecodeErrorZ.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_free(_res: CResult_HTLCDescriptorDecodeErrorZ) { }
impl Drop for CResult_HTLCDescriptorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::HTLCDescriptor, crate::lightning::ln::msgs::DecodeError>> for CResult_HTLCDescriptorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::HTLCDescriptor, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HTLCDescriptorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HTLCDescriptorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HTLCDescriptorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HTLCDescriptorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::HTLCDescriptor>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HTLCDescriptorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCDescriptorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HTLCDescriptorDecodeErrorZ_clone(orig: &CResult_HTLCDescriptorDecodeErrorZ) -> CResult_HTLCDescriptorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneNoneZ
pub union CResult_NoneNoneZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_NoneNoneZ represents the result of a fallible operation,
/// containing a () on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneNoneZ {
	/// The contents of this CResult_NoneNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneNoneZPtr,
	/// Whether this CResult_NoneNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneNoneZ in the success state.
pub extern "C" fn CResult_NoneNoneZ_ok() -> CResult_NoneNoneZ {
	CResult_NoneNoneZ {
		contents: CResult_NoneNoneZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneNoneZ in the error state.
pub extern "C" fn CResult_NoneNoneZ_err() -> CResult_NoneNoneZ {
	CResult_NoneNoneZ {
		contents: CResult_NoneNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneNoneZ_is_ok(o: &CResult_NoneNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneNoneZ.
pub extern "C" fn CResult_NoneNoneZ_free(_res: CResult_NoneNoneZ) { }
impl Drop for CResult_NoneNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<(), ()>> for CResult_NoneNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<(), ()>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneNoneZPtr { result: core::ptr::null_mut() }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_NoneNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneNoneZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneNoneZ_clone(orig: &CResult_NoneNoneZ) -> CResult_NoneNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PublicKeyNoneZ
pub union CResult_PublicKeyNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::PublicKey,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_PublicKeyNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::PublicKey on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PublicKeyNoneZ {
	/// The contents of this CResult_PublicKeyNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PublicKeyNoneZPtr,
	/// Whether this CResult_PublicKeyNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PublicKeyNoneZ in the success state.
pub extern "C" fn CResult_PublicKeyNoneZ_ok(o: crate::c_types::PublicKey) -> CResult_PublicKeyNoneZ {
	CResult_PublicKeyNoneZ {
		contents: CResult_PublicKeyNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeyNoneZ in the error state.
pub extern "C" fn CResult_PublicKeyNoneZ_err() -> CResult_PublicKeyNoneZ {
	CResult_PublicKeyNoneZ {
		contents: CResult_PublicKeyNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PublicKeyNoneZ_is_ok(o: &CResult_PublicKeyNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PublicKeyNoneZ.
pub extern "C" fn CResult_PublicKeyNoneZ_free(_res: CResult_PublicKeyNoneZ) { }
impl Drop for CResult_PublicKeyNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::PublicKey, ()>> for CResult_PublicKeyNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::PublicKey, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PublicKeyNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_PublicKeyNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PublicKeyNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PublicKeyNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::PublicKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PublicKeyNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeyNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PublicKeyNoneZ_clone(orig: &CResult_PublicKeyNoneZ) -> CResult_PublicKeyNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::BigEndianScalar or not
pub enum COption_BigEndianScalarZ {
	/// When we're in this state, this COption_BigEndianScalarZ contains a crate::c_types::BigEndianScalar
	Some(crate::c_types::BigEndianScalar),
	/// When we're in this state, this COption_BigEndianScalarZ contains nothing
	None
}
impl COption_BigEndianScalarZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::BigEndianScalar {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_BigEndianScalarZ containing a crate::c_types::BigEndianScalar
pub extern "C" fn COption_BigEndianScalarZ_some(o: crate::c_types::BigEndianScalar) -> COption_BigEndianScalarZ {
	COption_BigEndianScalarZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_BigEndianScalarZ containing nothing
pub extern "C" fn COption_BigEndianScalarZ_none() -> COption_BigEndianScalarZ {
	COption_BigEndianScalarZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::BigEndianScalar, if we are in the Some state
pub extern "C" fn COption_BigEndianScalarZ_free(_res: COption_BigEndianScalarZ) { }
#[no_mangle]
/// Creates a new COption_BigEndianScalarZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_BigEndianScalarZ_clone(orig: &COption_BigEndianScalarZ) -> COption_BigEndianScalarZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::U5s of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_U5Z {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::U5,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_U5Z {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::U5> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::U5] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::U5>> for CVec_U5Z {
	fn from(v: Vec<crate::c_types::U5>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_U5Z_free(_res: CVec_U5Z) { }
impl Drop for CVec_U5Z {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_U5Z {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RecoverableSignatureNoneZ
pub union CResult_RecoverableSignatureNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::RecoverableSignature,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::RecoverableSignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RecoverableSignatureNoneZ {
	/// The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RecoverableSignatureNoneZPtr,
	/// Whether this CResult_RecoverableSignatureNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RecoverableSignatureNoneZ in the success state.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_ok(o: crate::c_types::RecoverableSignature) -> CResult_RecoverableSignatureNoneZ {
	CResult_RecoverableSignatureNoneZ {
		contents: CResult_RecoverableSignatureNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RecoverableSignatureNoneZ in the error state.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_err() -> CResult_RecoverableSignatureNoneZ {
	CResult_RecoverableSignatureNoneZ {
		contents: CResult_RecoverableSignatureNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RecoverableSignatureNoneZ_is_ok(o: &CResult_RecoverableSignatureNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RecoverableSignatureNoneZ.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_free(_res: CResult_RecoverableSignatureNoneZ) { }
impl Drop for CResult_RecoverableSignatureNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::RecoverableSignature, ()>> for CResult_RecoverableSignatureNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::RecoverableSignature, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RecoverableSignatureNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_RecoverableSignatureNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RecoverableSignatureNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RecoverableSignatureNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::RecoverableSignature>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RecoverableSignatureNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RecoverableSignatureNoneZ_clone(orig: &CResult_RecoverableSignatureNoneZ) -> CResult_RecoverableSignatureNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SchnorrSignatureNoneZ
pub union CResult_SchnorrSignatureNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::SchnorrSignature,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_SchnorrSignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::SchnorrSignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SchnorrSignatureNoneZ {
	/// The contents of this CResult_SchnorrSignatureNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SchnorrSignatureNoneZPtr,
	/// Whether this CResult_SchnorrSignatureNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SchnorrSignatureNoneZ in the success state.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_ok(o: crate::c_types::SchnorrSignature) -> CResult_SchnorrSignatureNoneZ {
	CResult_SchnorrSignatureNoneZ {
		contents: CResult_SchnorrSignatureNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SchnorrSignatureNoneZ in the error state.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_err() -> CResult_SchnorrSignatureNoneZ {
	CResult_SchnorrSignatureNoneZ {
		contents: CResult_SchnorrSignatureNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SchnorrSignatureNoneZ_is_ok(o: &CResult_SchnorrSignatureNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SchnorrSignatureNoneZ.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_free(_res: CResult_SchnorrSignatureNoneZ) { }
impl Drop for CResult_SchnorrSignatureNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::SchnorrSignature, ()>> for CResult_SchnorrSignatureNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::SchnorrSignature, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SchnorrSignatureNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_SchnorrSignatureNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SchnorrSignatureNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SchnorrSignatureNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::SchnorrSignature>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SchnorrSignatureNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SchnorrSignatureNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SchnorrSignatureNoneZ_clone(orig: &CResult_SchnorrSignatureNoneZ) -> CResult_SchnorrSignatureNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ECDSASignatureNoneZ
pub union CResult_ECDSASignatureNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ECDSASignature,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ECDSASignatureNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::ECDSASignature on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ECDSASignatureNoneZ {
	/// The contents of this CResult_ECDSASignatureNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ECDSASignatureNoneZPtr,
	/// Whether this CResult_ECDSASignatureNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ECDSASignatureNoneZ in the success state.
pub extern "C" fn CResult_ECDSASignatureNoneZ_ok(o: crate::c_types::ECDSASignature) -> CResult_ECDSASignatureNoneZ {
	CResult_ECDSASignatureNoneZ {
		contents: CResult_ECDSASignatureNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ECDSASignatureNoneZ in the error state.
pub extern "C" fn CResult_ECDSASignatureNoneZ_err() -> CResult_ECDSASignatureNoneZ {
	CResult_ECDSASignatureNoneZ {
		contents: CResult_ECDSASignatureNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ECDSASignatureNoneZ_is_ok(o: &CResult_ECDSASignatureNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ECDSASignatureNoneZ.
pub extern "C" fn CResult_ECDSASignatureNoneZ_free(_res: CResult_ECDSASignatureNoneZ) { }
impl Drop for CResult_ECDSASignatureNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ECDSASignature, ()>> for CResult_ECDSASignatureNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ECDSASignature, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ECDSASignatureNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ECDSASignatureNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ECDSASignatureNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ECDSASignatureNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ECDSASignature>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ECDSASignatureNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ECDSASignatureNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ECDSASignatureNoneZ_clone(orig: &CResult_ECDSASignatureNoneZ) -> CResult_ECDSASignatureNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_WriteableEcdsaChannelSignerDecodeErrorZ
pub union CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::ecdsa::WriteableEcdsaChannelSigner,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_WriteableEcdsaChannelSignerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::ecdsa::WriteableEcdsaChannelSigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
	/// The contents of this CResult_WriteableEcdsaChannelSignerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr,
	/// Whether this CResult_WriteableEcdsaChannelSignerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_WriteableEcdsaChannelSignerDecodeErrorZ in the success state.
pub extern "C" fn CResult_WriteableEcdsaChannelSignerDecodeErrorZ_ok(o: crate::lightning::sign::ecdsa::WriteableEcdsaChannelSigner) -> CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
	CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
		contents: CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_WriteableEcdsaChannelSignerDecodeErrorZ in the error state.
pub extern "C" fn CResult_WriteableEcdsaChannelSignerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
	CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
		contents: CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_WriteableEcdsaChannelSignerDecodeErrorZ_is_ok(o: &CResult_WriteableEcdsaChannelSignerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_WriteableEcdsaChannelSignerDecodeErrorZ.
pub extern "C" fn CResult_WriteableEcdsaChannelSignerDecodeErrorZ_free(_res: CResult_WriteableEcdsaChannelSignerDecodeErrorZ) { }
impl Drop for CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::ecdsa::WriteableEcdsaChannelSigner, crate::lightning::ln::msgs::DecodeError>> for CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::ecdsa::WriteableEcdsaChannelSigner, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_WriteableEcdsaChannelSignerDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::ecdsa::WriteableEcdsaChannelSigner>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_WriteableEcdsaChannelSignerDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_WriteableEcdsaChannelSignerDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone(orig: &CResult_WriteableEcdsaChannelSignerDecodeErrorZ) -> CResult_WriteableEcdsaChannelSignerDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_u8ZNoneZ
pub union CResult_CVec_u8ZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_u8Z,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_u8ZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_u8ZNoneZ {
	/// The contents of this CResult_CVec_u8ZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_u8ZNoneZPtr,
	/// Whether this CResult_CVec_u8ZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZNoneZ in the success state.
pub extern "C" fn CResult_CVec_u8ZNoneZ_ok(o: crate::c_types::derived::CVec_u8Z) -> CResult_CVec_u8ZNoneZ {
	CResult_CVec_u8ZNoneZ {
		contents: CResult_CVec_u8ZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZNoneZ in the error state.
pub extern "C" fn CResult_CVec_u8ZNoneZ_err() -> CResult_CVec_u8ZNoneZ {
	CResult_CVec_u8ZNoneZ {
		contents: CResult_CVec_u8ZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_u8ZNoneZ_is_ok(o: &CResult_CVec_u8ZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_u8ZNoneZ.
pub extern "C" fn CResult_CVec_u8ZNoneZ_free(_res: CResult_CVec_u8ZNoneZ) { }
impl Drop for CResult_CVec_u8ZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, ()>> for CResult_CVec_u8ZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_u8ZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_u8ZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_u8ZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_u8ZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_u8Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_u8ZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_u8ZNoneZ_clone(orig: &CResult_CVec_u8ZNoneZ) -> CResult_CVec_u8ZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownScriptNoneZ
pub union CResult_ShutdownScriptNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::script::ShutdownScript,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ShutdownScriptNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownScriptNoneZ {
	/// The contents of this CResult_ShutdownScriptNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownScriptNoneZPtr,
	/// Whether this CResult_ShutdownScriptNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptNoneZ in the success state.
pub extern "C" fn CResult_ShutdownScriptNoneZ_ok(o: crate::lightning::ln::script::ShutdownScript) -> CResult_ShutdownScriptNoneZ {
	CResult_ShutdownScriptNoneZ {
		contents: CResult_ShutdownScriptNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptNoneZ in the error state.
pub extern "C" fn CResult_ShutdownScriptNoneZ_err() -> CResult_ShutdownScriptNoneZ {
	CResult_ShutdownScriptNoneZ {
		contents: CResult_ShutdownScriptNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownScriptNoneZ_is_ok(o: &CResult_ShutdownScriptNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownScriptNoneZ.
pub extern "C" fn CResult_ShutdownScriptNoneZ_free(_res: CResult_ShutdownScriptNoneZ) { }
impl Drop for CResult_ShutdownScriptNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, ()>> for CResult_ShutdownScriptNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownScriptNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ShutdownScriptNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownScriptNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownScriptNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::script::ShutdownScript>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownScriptNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownScriptNoneZ_clone(orig: &CResult_ShutdownScriptNoneZ) -> CResult_ShutdownScriptNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a u16 or not
pub enum COption_u16Z {
	/// When we're in this state, this COption_u16Z contains a u16
	Some(u16),
	/// When we're in this state, this COption_u16Z contains nothing
	None
}
impl COption_u16Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> u16 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_u16Z containing a u16
pub extern "C" fn COption_u16Z_some(o: u16) -> COption_u16Z {
	COption_u16Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_u16Z containing nothing
pub extern "C" fn COption_u16Z_none() -> COption_u16Z {
	COption_u16Z::None
}
#[no_mangle]
/// Frees any resources associated with the u16, if we are in the Some state
pub extern "C" fn COption_u16Z_free(_res: COption_u16Z) { }
#[no_mangle]
/// Creates a new COption_u16Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_u16Z_clone(orig: &COption_u16Z) -> COption_u16Z { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a bool or not
pub enum COption_boolZ {
	/// When we're in this state, this COption_boolZ contains a bool
	Some(bool),
	/// When we're in this state, this COption_boolZ contains nothing
	None
}
impl COption_boolZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> bool {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_boolZ containing a bool
pub extern "C" fn COption_boolZ_some(o: bool) -> COption_boolZ {
	COption_boolZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_boolZ containing nothing
pub extern "C" fn COption_boolZ_none() -> COption_boolZ {
	COption_boolZ::None
}
#[no_mangle]
/// Frees any resources associated with the bool, if we are in the Some state
pub extern "C" fn COption_boolZ_free(_res: COption_boolZ) { }
#[no_mangle]
/// Creates a new COption_boolZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_boolZ_clone(orig: &COption_boolZ) -> COption_boolZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_WitnessNoneZ
pub union CResult_WitnessNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::Witness,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_WitnessNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::Witness on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_WitnessNoneZ {
	/// The contents of this CResult_WitnessNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_WitnessNoneZPtr,
	/// Whether this CResult_WitnessNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_WitnessNoneZ in the success state.
pub extern "C" fn CResult_WitnessNoneZ_ok(o: crate::c_types::Witness) -> CResult_WitnessNoneZ {
	CResult_WitnessNoneZ {
		contents: CResult_WitnessNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_WitnessNoneZ in the error state.
pub extern "C" fn CResult_WitnessNoneZ_err() -> CResult_WitnessNoneZ {
	CResult_WitnessNoneZ {
		contents: CResult_WitnessNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_WitnessNoneZ_is_ok(o: &CResult_WitnessNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_WitnessNoneZ.
pub extern "C" fn CResult_WitnessNoneZ_free(_res: CResult_WitnessNoneZ) { }
impl Drop for CResult_WitnessNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::Witness, ()>> for CResult_WitnessNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::Witness, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_WitnessNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_WitnessNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_WitnessNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_WitnessNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::Witness>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_WitnessNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_WitnessNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_WitnessNoneZ_clone(orig: &CResult_WitnessNoneZ) -> CResult_WitnessNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::ECDSASignatures of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ECDSASignatureZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::ECDSASignature,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ECDSASignatureZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::ECDSASignature> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::ECDSASignature] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::ECDSASignature>> for CVec_ECDSASignatureZ {
	fn from(v: Vec<crate::c_types::ECDSASignature>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ECDSASignatureZ_free(_res: CVec_ECDSASignatureZ) { }
impl Drop for CVec_ECDSASignatureZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ECDSASignatureZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	/// The element at position 0
	pub a: crate::c_types::ECDSASignature,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_ECDSASignatureZ,
}
impl From<(crate::c_types::ECDSASignature, crate::c_types::derived::CVec_ECDSASignatureZ)> for C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	fn from (tup: (crate::c_types::ECDSASignature, crate::c_types::derived::CVec_ECDSASignatureZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ECDSASignature, crate::c_types::derived::CVec_ECDSASignatureZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_clone(orig: &C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ) -> C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_new(a: crate::c_types::ECDSASignature, b: crate::c_types::derived::CVec_ECDSASignatureZ) -> C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
	C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ.
pub extern "C" fn C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_free(_res: C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ
pub union CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	/// The contents of this CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr,
	/// Whether this CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_ok(o: crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ) -> CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
		contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_err() -> CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
		contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_is_ok(o: &CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_free(_res: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ) { }
impl Drop for CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ, ()>> for CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_clone(orig: &CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ) -> CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InMemorySignerDecodeErrorZ
pub union CResult_InMemorySignerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::sign::InMemorySigner,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::sign::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InMemorySignerDecodeErrorZ {
	/// The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InMemorySignerDecodeErrorZPtr,
	/// Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_ok(o: crate::lightning::sign::InMemorySigner) -> CResult_InMemorySignerDecodeErrorZ {
	CResult_InMemorySignerDecodeErrorZ {
		contents: CResult_InMemorySignerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InMemorySignerDecodeErrorZ {
	CResult_InMemorySignerDecodeErrorZ {
		contents: CResult_InMemorySignerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_is_ok(o: &CResult_InMemorySignerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_free(_res: CResult_InMemorySignerDecodeErrorZ) { }
impl Drop for CResult_InMemorySignerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::sign::InMemorySigner, crate::lightning::ln::msgs::DecodeError>> for CResult_InMemorySignerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::sign::InMemorySigner, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InMemorySignerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InMemorySignerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InMemorySignerDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InMemorySignerDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::sign::InMemorySigner>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InMemorySignerDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InMemorySignerDecodeErrorZ_clone(orig: &CResult_InMemorySignerDecodeErrorZ) -> CResult_InMemorySignerDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TransactionNoneZ
pub union CResult_TransactionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::Transaction,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TransactionNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::Transaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TransactionNoneZ {
	/// The contents of this CResult_TransactionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TransactionNoneZPtr,
	/// Whether this CResult_TransactionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TransactionNoneZ in the success state.
pub extern "C" fn CResult_TransactionNoneZ_ok(o: crate::c_types::Transaction) -> CResult_TransactionNoneZ {
	CResult_TransactionNoneZ {
		contents: CResult_TransactionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionNoneZ in the error state.
pub extern "C" fn CResult_TransactionNoneZ_err() -> CResult_TransactionNoneZ {
	CResult_TransactionNoneZ {
		contents: CResult_TransactionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TransactionNoneZ_is_ok(o: &CResult_TransactionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TransactionNoneZ.
pub extern "C" fn CResult_TransactionNoneZ_free(_res: CResult_TransactionNoneZ) { }
impl Drop for CResult_TransactionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::Transaction, ()>> for CResult_TransactionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::Transaction, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TransactionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TransactionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TransactionNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TransactionNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::Transaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TransactionNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TransactionNoneZ_clone(orig: &CResult_TransactionNoneZ) -> CResult_TransactionNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::routing::scoring::WriteableScore or not
pub enum COption_WriteableScoreZ {
	/// When we're in this state, this COption_WriteableScoreZ contains a crate::lightning::routing::scoring::WriteableScore
	Some(crate::lightning::routing::scoring::WriteableScore),
	/// When we're in this state, this COption_WriteableScoreZ contains nothing
	None
}
impl COption_WriteableScoreZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::scoring::WriteableScore {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_WriteableScoreZ containing a crate::lightning::routing::scoring::WriteableScore
pub extern "C" fn COption_WriteableScoreZ_some(o: crate::lightning::routing::scoring::WriteableScore) -> COption_WriteableScoreZ {
	COption_WriteableScoreZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_WriteableScoreZ containing nothing
pub extern "C" fn COption_WriteableScoreZ_none() -> COption_WriteableScoreZ {
	COption_WriteableScoreZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::scoring::WriteableScore, if we are in the Some state
pub extern "C" fn COption_WriteableScoreZ_free(_res: COption_WriteableScoreZ) { }
#[repr(C)]
/// The contents of CResult_NoneIOErrorZ
pub union CResult_NoneIOErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_NoneIOErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneIOErrorZ {
	/// The contents of this CResult_NoneIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneIOErrorZPtr,
	/// Whether this CResult_NoneIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneIOErrorZ in the success state.
pub extern "C" fn CResult_NoneIOErrorZ_ok() -> CResult_NoneIOErrorZ {
	CResult_NoneIOErrorZ {
		contents: CResult_NoneIOErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneIOErrorZ in the error state.
pub extern "C" fn CResult_NoneIOErrorZ_err(e: crate::c_types::IOError) -> CResult_NoneIOErrorZ {
	CResult_NoneIOErrorZ {
		contents: CResult_NoneIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneIOErrorZ_is_ok(o: &CResult_NoneIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneIOErrorZ.
pub extern "C" fn CResult_NoneIOErrorZ_free(_res: CResult_NoneIOErrorZ) { }
impl Drop for CResult_NoneIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::c_types::IOError>> for CResult_NoneIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneIOErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneIOErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneIOErrorZ_clone(orig: &CResult_NoneIOErrorZ) -> CResult_NoneIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channelmanager::ChannelDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ChannelDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channelmanager::ChannelDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ChannelDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channelmanager::ChannelDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channelmanager::ChannelDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channelmanager::ChannelDetails>> for CVec_ChannelDetailsZ {
	fn from(v: Vec<crate::lightning::ln::channelmanager::ChannelDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ChannelDetailsZ_free(_res: CVec_ChannelDetailsZ) { }
impl Drop for CVec_ChannelDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ChannelDetailsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RouteLightningErrorZ
pub union CResult_RouteLightningErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::Route,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::LightningError,
}
#[repr(C)]
/// A CResult_RouteLightningErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteLightningErrorZ {
	/// The contents of this CResult_RouteLightningErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteLightningErrorZPtr,
	/// Whether this CResult_RouteLightningErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteLightningErrorZ in the success state.
pub extern "C" fn CResult_RouteLightningErrorZ_ok(o: crate::lightning::routing::router::Route) -> CResult_RouteLightningErrorZ {
	CResult_RouteLightningErrorZ {
		contents: CResult_RouteLightningErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteLightningErrorZ in the error state.
pub extern "C" fn CResult_RouteLightningErrorZ_err(e: crate::lightning::ln::msgs::LightningError) -> CResult_RouteLightningErrorZ {
	CResult_RouteLightningErrorZ {
		contents: CResult_RouteLightningErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteLightningErrorZ_is_ok(o: &CResult_RouteLightningErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteLightningErrorZ.
pub extern "C" fn CResult_RouteLightningErrorZ_free(_res: CResult_RouteLightningErrorZ) { }
impl Drop for CResult_RouteLightningErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::LightningError>> for CResult_RouteLightningErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::LightningError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteLightningErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteLightningErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteLightningErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteLightningErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::Route>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteLightningErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::LightningError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteLightningErrorZ_clone(orig: &CResult_RouteLightningErrorZ) -> CResult_RouteLightningErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_BlindedPayInfoBlindedPathZ {
	/// The element at position 0
	pub a: crate::lightning::offers::invoice::BlindedPayInfo,
	/// The element at position 1
	pub b: crate::lightning::blinded_path::BlindedPath,
}
impl From<(crate::lightning::offers::invoice::BlindedPayInfo, crate::lightning::blinded_path::BlindedPath)> for C2Tuple_BlindedPayInfoBlindedPathZ {
	fn from (tup: (crate::lightning::offers::invoice::BlindedPayInfo, crate::lightning::blinded_path::BlindedPath)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_BlindedPayInfoBlindedPathZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::offers::invoice::BlindedPayInfo, crate::lightning::blinded_path::BlindedPath) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_BlindedPayInfoBlindedPathZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_BlindedPayInfoBlindedPathZ_clone(orig: &C2Tuple_BlindedPayInfoBlindedPathZ) -> C2Tuple_BlindedPayInfoBlindedPathZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_BlindedPayInfoBlindedPathZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_BlindedPayInfoBlindedPathZ_new(a: crate::lightning::offers::invoice::BlindedPayInfo, b: crate::lightning::blinded_path::BlindedPath) -> C2Tuple_BlindedPayInfoBlindedPathZ {
	C2Tuple_BlindedPayInfoBlindedPathZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_BlindedPayInfoBlindedPathZ.
pub extern "C" fn C2Tuple_BlindedPayInfoBlindedPathZ_free(_res: C2Tuple_BlindedPayInfoBlindedPathZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_BlindedPayInfoBlindedPathZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_BlindedPayInfoBlindedPathZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ>> for CVec_C2Tuple_BlindedPayInfoBlindedPathZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_BlindedPayInfoBlindedPathZZ_free(_res: CVec_C2Tuple_BlindedPayInfoBlindedPathZZ) { }
impl Drop for CVec_C2Tuple_BlindedPayInfoBlindedPathZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_BlindedPayInfoBlindedPathZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ
pub union CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_C2Tuple_BlindedPayInfoBlindedPathZZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C2Tuple_BlindedPayInfoBlindedPathZZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
	/// The contents of this CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr,
	/// Whether this CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ in the success state.
pub extern "C" fn CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ_ok(o: crate::c_types::derived::CVec_C2Tuple_BlindedPayInfoBlindedPathZZ) -> CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
	CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
		contents: CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ in the error state.
pub extern "C" fn CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ_err() -> CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
	CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
		contents: CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ_is_ok(o: &CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ.
pub extern "C" fn CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ_free(_res: CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ) { }
impl Drop for CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_BlindedPayInfoBlindedPathZZ, ()>> for CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_BlindedPayInfoBlindedPathZZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_C2Tuple_BlindedPayInfoBlindedPathZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ_clone(orig: &CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ) -> CResult_CVec_C2Tuple_BlindedPayInfoBlindedPathZZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PublicKeyZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::PublicKey,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PublicKeyZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::PublicKey> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::PublicKey] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::PublicKey>> for CVec_PublicKeyZ {
	fn from(v: Vec<crate::c_types::PublicKey>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PublicKeyZ_free(_res: CVec_PublicKeyZ) { }
impl Drop for CVec_PublicKeyZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PublicKeyZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_OnionMessagePathNoneZ
pub union CResult_OnionMessagePathNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::OnionMessagePath,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_OnionMessagePathNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::OnionMessagePath on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OnionMessagePathNoneZ {
	/// The contents of this CResult_OnionMessagePathNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OnionMessagePathNoneZPtr,
	/// Whether this CResult_OnionMessagePathNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OnionMessagePathNoneZ in the success state.
pub extern "C" fn CResult_OnionMessagePathNoneZ_ok(o: crate::lightning::onion_message::messenger::OnionMessagePath) -> CResult_OnionMessagePathNoneZ {
	CResult_OnionMessagePathNoneZ {
		contents: CResult_OnionMessagePathNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessagePathNoneZ in the error state.
pub extern "C" fn CResult_OnionMessagePathNoneZ_err() -> CResult_OnionMessagePathNoneZ {
	CResult_OnionMessagePathNoneZ {
		contents: CResult_OnionMessagePathNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OnionMessagePathNoneZ_is_ok(o: &CResult_OnionMessagePathNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OnionMessagePathNoneZ.
pub extern "C" fn CResult_OnionMessagePathNoneZ_free(_res: CResult_OnionMessagePathNoneZ) { }
impl Drop for CResult_OnionMessagePathNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::OnionMessagePath, ()>> for CResult_OnionMessagePathNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::OnionMessagePath, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OnionMessagePathNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_OnionMessagePathNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OnionMessagePathNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OnionMessagePathNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::messenger::OnionMessagePath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OnionMessagePathNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessagePathNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OnionMessagePathNoneZ_clone(orig: &CResult_OnionMessagePathNoneZ) -> CResult_OnionMessagePathNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_BlindedPathZNoneZ
pub union CResult_CVec_BlindedPathZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_BlindedPathZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_BlindedPathZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_BlindedPathZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_BlindedPathZNoneZ {
	/// The contents of this CResult_CVec_BlindedPathZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_BlindedPathZNoneZPtr,
	/// Whether this CResult_CVec_BlindedPathZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedPathZNoneZ in the success state.
pub extern "C" fn CResult_CVec_BlindedPathZNoneZ_ok(o: crate::c_types::derived::CVec_BlindedPathZ) -> CResult_CVec_BlindedPathZNoneZ {
	CResult_CVec_BlindedPathZNoneZ {
		contents: CResult_CVec_BlindedPathZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedPathZNoneZ in the error state.
pub extern "C" fn CResult_CVec_BlindedPathZNoneZ_err() -> CResult_CVec_BlindedPathZNoneZ {
	CResult_CVec_BlindedPathZNoneZ {
		contents: CResult_CVec_BlindedPathZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_BlindedPathZNoneZ_is_ok(o: &CResult_CVec_BlindedPathZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_BlindedPathZNoneZ.
pub extern "C" fn CResult_CVec_BlindedPathZNoneZ_free(_res: CResult_CVec_BlindedPathZNoneZ) { }
impl Drop for CResult_CVec_BlindedPathZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_BlindedPathZ, ()>> for CResult_CVec_BlindedPathZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_BlindedPathZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_BlindedPathZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_BlindedPathZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_BlindedPathZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_BlindedPathZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_BlindedPathZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_BlindedPathZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_BlindedPathZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_BlindedPathZNoneZ_clone(orig: &CResult_CVec_BlindedPathZNoneZ) -> CResult_CVec_BlindedPathZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InFlightHtlcsDecodeErrorZ
pub union CResult_InFlightHtlcsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::InFlightHtlcs,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InFlightHtlcsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::InFlightHtlcs on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InFlightHtlcsDecodeErrorZ {
	/// The contents of this CResult_InFlightHtlcsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InFlightHtlcsDecodeErrorZPtr,
	/// Whether this CResult_InFlightHtlcsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InFlightHtlcsDecodeErrorZ in the success state.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_ok(o: crate::lightning::routing::router::InFlightHtlcs) -> CResult_InFlightHtlcsDecodeErrorZ {
	CResult_InFlightHtlcsDecodeErrorZ {
		contents: CResult_InFlightHtlcsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InFlightHtlcsDecodeErrorZ in the error state.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InFlightHtlcsDecodeErrorZ {
	CResult_InFlightHtlcsDecodeErrorZ {
		contents: CResult_InFlightHtlcsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_is_ok(o: &CResult_InFlightHtlcsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InFlightHtlcsDecodeErrorZ.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_free(_res: CResult_InFlightHtlcsDecodeErrorZ) { }
impl Drop for CResult_InFlightHtlcsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::InFlightHtlcs, crate::lightning::ln::msgs::DecodeError>> for CResult_InFlightHtlcsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::InFlightHtlcs, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InFlightHtlcsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InFlightHtlcsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InFlightHtlcsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InFlightHtlcsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::InFlightHtlcs>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InFlightHtlcsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InFlightHtlcsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InFlightHtlcsDecodeErrorZ_clone(orig: &CResult_InFlightHtlcsDecodeErrorZ) -> CResult_InFlightHtlcsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RouteHopDecodeErrorZ
pub union CResult_RouteHopDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::RouteHop,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteHopDecodeErrorZ {
	/// The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteHopDecodeErrorZPtr,
	/// Whether this CResult_RouteHopDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteHopDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_ok(o: crate::lightning::routing::router::RouteHop) -> CResult_RouteHopDecodeErrorZ {
	CResult_RouteHopDecodeErrorZ {
		contents: CResult_RouteHopDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHopDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteHopDecodeErrorZ {
	CResult_RouteHopDecodeErrorZ {
		contents: CResult_RouteHopDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteHopDecodeErrorZ_is_ok(o: &CResult_RouteHopDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteHopDecodeErrorZ.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_free(_res: CResult_RouteHopDecodeErrorZ) { }
impl Drop for CResult_RouteHopDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHop, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteHopDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHop, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteHopDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteHopDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteHopDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteHopDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::RouteHop>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteHopDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteHopDecodeErrorZ_clone(orig: &CResult_RouteHopDecodeErrorZ) -> CResult_RouteHopDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::BlindedHops of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BlindedHopZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::BlindedHop,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BlindedHopZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::BlindedHop> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::BlindedHop] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::BlindedHop>> for CVec_BlindedHopZ {
	fn from(v: Vec<crate::lightning::blinded_path::BlindedHop>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BlindedHopZ_free(_res: CVec_BlindedHopZ) { }
impl Drop for CVec_BlindedHopZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BlindedHopZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_BlindedTailDecodeErrorZ
pub union CResult_BlindedTailDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::BlindedTail,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedTailDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::BlindedTail on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedTailDecodeErrorZ {
	/// The contents of this CResult_BlindedTailDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedTailDecodeErrorZPtr,
	/// Whether this CResult_BlindedTailDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedTailDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_ok(o: crate::lightning::routing::router::BlindedTail) -> CResult_BlindedTailDecodeErrorZ {
	CResult_BlindedTailDecodeErrorZ {
		contents: CResult_BlindedTailDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedTailDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedTailDecodeErrorZ {
	CResult_BlindedTailDecodeErrorZ {
		contents: CResult_BlindedTailDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_is_ok(o: &CResult_BlindedTailDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedTailDecodeErrorZ.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_free(_res: CResult_BlindedTailDecodeErrorZ) { }
impl Drop for CResult_BlindedTailDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::BlindedTail, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedTailDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::BlindedTail, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedTailDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedTailDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedTailDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedTailDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::BlindedTail>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedTailDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedTailDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedTailDecodeErrorZ_clone(orig: &CResult_BlindedTailDecodeErrorZ) -> CResult_BlindedTailDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RouteHopZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::router::RouteHop,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RouteHopZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::router::RouteHop> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::router::RouteHop] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::router::RouteHop>> for CVec_RouteHopZ {
	fn from(v: Vec<crate::lightning::routing::router::RouteHop>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RouteHopZ_free(_res: CVec_RouteHopZ) { }
impl Drop for CVec_RouteHopZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_RouteHopZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::router::Paths of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PathZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::router::Path,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PathZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::router::Path> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::router::Path] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::router::Path>> for CVec_PathZ {
	fn from(v: Vec<crate::lightning::routing::router::Path>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PathZ_free(_res: CVec_PathZ) { }
impl Drop for CVec_PathZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PathZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RouteDecodeErrorZ
pub union CResult_RouteDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::Route,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteDecodeErrorZ {
	/// The contents of this CResult_RouteDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteDecodeErrorZPtr,
	/// Whether this CResult_RouteDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteDecodeErrorZ_ok(o: crate::lightning::routing::router::Route) -> CResult_RouteDecodeErrorZ {
	CResult_RouteDecodeErrorZ {
		contents: CResult_RouteDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteDecodeErrorZ {
	CResult_RouteDecodeErrorZ {
		contents: CResult_RouteDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteDecodeErrorZ_is_ok(o: &CResult_RouteDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteDecodeErrorZ.
pub extern "C" fn CResult_RouteDecodeErrorZ_free(_res: CResult_RouteDecodeErrorZ) { }
impl Drop for CResult_RouteDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::Route, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::Route>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteDecodeErrorZ_clone(orig: &CResult_RouteDecodeErrorZ) -> CResult_RouteDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RouteParametersDecodeErrorZ
pub union CResult_RouteParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::RouteParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteParametersDecodeErrorZ {
	/// The contents of this CResult_RouteParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteParametersDecodeErrorZPtr,
	/// Whether this CResult_RouteParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_ok(o: crate::lightning::routing::router::RouteParameters) -> CResult_RouteParametersDecodeErrorZ {
	CResult_RouteParametersDecodeErrorZ {
		contents: CResult_RouteParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteParametersDecodeErrorZ {
	CResult_RouteParametersDecodeErrorZ {
		contents: CResult_RouteParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_is_ok(o: &CResult_RouteParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteParametersDecodeErrorZ.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_free(_res: CResult_RouteParametersDecodeErrorZ) { }
impl Drop for CResult_RouteParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::RouteParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::RouteParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::RouteParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteParametersDecodeErrorZ_clone(orig: &CResult_RouteParametersDecodeErrorZ) -> CResult_RouteParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of u64s of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_u64Z {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut u64,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_u64Z {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<u64> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[u64] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<u64>> for CVec_u64Z {
	fn from(v: Vec<u64>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_u64Z_free(_res: CVec_u64Z) { }
impl Drop for CVec_u64Z {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_u64Z {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_PaymentParametersDecodeErrorZ
pub union CResult_PaymentParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::PaymentParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::PaymentParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentParametersDecodeErrorZ {
	/// The contents of this CResult_PaymentParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentParametersDecodeErrorZPtr,
	/// Whether this CResult_PaymentParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_ok(o: crate::lightning::routing::router::PaymentParameters) -> CResult_PaymentParametersDecodeErrorZ {
	CResult_PaymentParametersDecodeErrorZ {
		contents: CResult_PaymentParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentParametersDecodeErrorZ {
	CResult_PaymentParametersDecodeErrorZ {
		contents: CResult_PaymentParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_is_ok(o: &CResult_PaymentParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentParametersDecodeErrorZ.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_free(_res: CResult_PaymentParametersDecodeErrorZ) { }
impl Drop for CResult_PaymentParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::PaymentParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::PaymentParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::PaymentParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentParametersDecodeErrorZ_clone(orig: &CResult_PaymentParametersDecodeErrorZ) -> CResult_PaymentParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::router::RouteHints of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RouteHintZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::router::RouteHint,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RouteHintZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::router::RouteHint> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::router::RouteHint] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::router::RouteHint>> for CVec_RouteHintZ {
	fn from(v: Vec<crate::lightning::routing::router::RouteHint>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RouteHintZ_free(_res: CVec_RouteHintZ) { }
impl Drop for CVec_RouteHintZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_RouteHintZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::router::RouteHintHops of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RouteHintHopZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::router::RouteHintHop,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RouteHintHopZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::router::RouteHintHop> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::router::RouteHintHop] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::router::RouteHintHop>> for CVec_RouteHintHopZ {
	fn from(v: Vec<crate::lightning::routing::router::RouteHintHop>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RouteHintHopZ_free(_res: CVec_RouteHintHopZ) { }
impl Drop for CVec_RouteHintHopZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_RouteHintHopZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_RouteHintDecodeErrorZ
pub union CResult_RouteHintDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::RouteHint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteHintDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteHintDecodeErrorZ {
	/// The contents of this CResult_RouteHintDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteHintDecodeErrorZPtr,
	/// Whether this CResult_RouteHintDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteHintDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_ok(o: crate::lightning::routing::router::RouteHint) -> CResult_RouteHintDecodeErrorZ {
	CResult_RouteHintDecodeErrorZ {
		contents: CResult_RouteHintDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteHintDecodeErrorZ {
	CResult_RouteHintDecodeErrorZ {
		contents: CResult_RouteHintDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteHintDecodeErrorZ_is_ok(o: &CResult_RouteHintDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteHintDecodeErrorZ.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_free(_res: CResult_RouteHintDecodeErrorZ) { }
impl Drop for CResult_RouteHintDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHint, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteHintDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteHintDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteHintDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteHintDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteHintDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::RouteHint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteHintDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteHintDecodeErrorZ_clone(orig: &CResult_RouteHintDecodeErrorZ) -> CResult_RouteHintDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RouteHintHopDecodeErrorZ
pub union CResult_RouteHintHopDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::router::RouteHintHop,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RouteHintHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::router::RouteHintHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RouteHintHopDecodeErrorZ {
	/// The contents of this CResult_RouteHintHopDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RouteHintHopDecodeErrorZPtr,
	/// Whether this CResult_RouteHintHopDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_ok(o: crate::lightning::routing::router::RouteHintHop) -> CResult_RouteHintHopDecodeErrorZ {
	CResult_RouteHintHopDecodeErrorZ {
		contents: CResult_RouteHintHopDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RouteHintHopDecodeErrorZ {
	CResult_RouteHintHopDecodeErrorZ {
		contents: CResult_RouteHintHopDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_is_ok(o: &CResult_RouteHintHopDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RouteHintHopDecodeErrorZ.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_free(_res: CResult_RouteHintHopDecodeErrorZ) { }
impl Drop for CResult_RouteHintHopDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHintHop, crate::lightning::ln::msgs::DecodeError>> for CResult_RouteHintHopDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::router::RouteHintHop, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RouteHintHopDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RouteHintHopDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RouteHintHopDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RouteHintHopDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::router::RouteHintHop>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RouteHintHopDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RouteHintHopDecodeErrorZ_clone(orig: &CResult_RouteHintHopDecodeErrorZ) -> CResult_RouteHintHopDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FixedPenaltyScorerDecodeErrorZ
pub union CResult_FixedPenaltyScorerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::scoring::FixedPenaltyScorer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FixedPenaltyScorerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::scoring::FixedPenaltyScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FixedPenaltyScorerDecodeErrorZ {
	/// The contents of this CResult_FixedPenaltyScorerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FixedPenaltyScorerDecodeErrorZPtr,
	/// Whether this CResult_FixedPenaltyScorerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the success state.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_ok(o: crate::lightning::routing::scoring::FixedPenaltyScorer) -> CResult_FixedPenaltyScorerDecodeErrorZ {
	CResult_FixedPenaltyScorerDecodeErrorZ {
		contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the error state.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FixedPenaltyScorerDecodeErrorZ {
	CResult_FixedPenaltyScorerDecodeErrorZ {
		contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(o: &CResult_FixedPenaltyScorerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FixedPenaltyScorerDecodeErrorZ.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_free(_res: CResult_FixedPenaltyScorerDecodeErrorZ) { }
impl Drop for CResult_FixedPenaltyScorerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::scoring::FixedPenaltyScorer, crate::lightning::ln::msgs::DecodeError>> for CResult_FixedPenaltyScorerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::scoring::FixedPenaltyScorer, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FixedPenaltyScorerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FixedPenaltyScorerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FixedPenaltyScorerDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::scoring::FixedPenaltyScorer>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FixedPenaltyScorerDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FixedPenaltyScorerDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FixedPenaltyScorerDecodeErrorZ_clone(orig: &CResult_FixedPenaltyScorerDecodeErrorZ) -> CResult_FixedPenaltyScorerDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::routing::gossip::NodeIds of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_NodeIdZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::routing::gossip::NodeId,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_NodeIdZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::routing::gossip::NodeId> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::routing::gossip::NodeId] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::routing::gossip::NodeId>> for CVec_NodeIdZ {
	fn from(v: Vec<crate::lightning::routing::gossip::NodeId>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_NodeIdZ_free(_res: CVec_NodeIdZ) { }
impl Drop for CVec_NodeIdZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_NodeIdZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u64u64Z {
	/// The element at position 0
	pub a: u64,
	/// The element at position 1
	pub b: u64,
}
impl From<(u64, u64)> for C2Tuple_u64u64Z {
	fn from (tup: (u64, u64)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u64u64Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u64, u64) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u64u64Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u64u64Z_clone(orig: &C2Tuple_u64u64Z) -> C2Tuple_u64u64Z { Clone::clone(&orig) }
/// Creates a new C2Tuple_u64u64Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u64u64Z_new(a: u64, b: u64) -> C2Tuple_u64u64Z {
	C2Tuple_u64u64Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u64u64Z.
pub extern "C" fn C2Tuple_u64u64Z_free(_res: C2Tuple_u64u64Z) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_u64u64Z or not
pub enum COption_C2Tuple_u64u64ZZ {
	/// When we're in this state, this COption_C2Tuple_u64u64ZZ contains a crate::c_types::derived::C2Tuple_u64u64Z
	Some(crate::c_types::derived::C2Tuple_u64u64Z),
	/// When we're in this state, this COption_C2Tuple_u64u64ZZ contains nothing
	None
}
impl COption_C2Tuple_u64u64ZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_u64u64Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u64ZZ containing a crate::c_types::derived::C2Tuple_u64u64Z
pub extern "C" fn COption_C2Tuple_u64u64ZZ_some(o: crate::c_types::derived::C2Tuple_u64u64Z) -> COption_C2Tuple_u64u64ZZ {
	COption_C2Tuple_u64u64ZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u64ZZ containing nothing
pub extern "C" fn COption_C2Tuple_u64u64ZZ_none() -> COption_C2Tuple_u64u64ZZ {
	COption_C2Tuple_u64u64ZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u64Z, if we are in the Some state
pub extern "C" fn COption_C2Tuple_u64u64ZZ_free(_res: COption_C2Tuple_u64u64ZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_u64u64ZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_u64u64ZZ_clone(orig: &COption_C2Tuple_u64u64ZZ) -> COption_C2Tuple_u64u64ZZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_Z {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoU16s,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoU16s,
}
impl From<(crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)> for C2Tuple_Z {
	fn from (tup: (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple_Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_Z_new(a: crate::c_types::ThirtyTwoU16s, b: crate::c_types::ThirtyTwoU16s) -> C2Tuple_Z {
	C2Tuple_Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_Z.
pub extern "C" fn C2Tuple_Z_free(_res: C2Tuple_Z) { }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple__u1632_u1632Z {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoU16s,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoU16s,
}
impl From<(crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)> for C2Tuple__u1632_u1632Z {
	fn from (tup: (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple__u1632_u1632Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoU16s, crate::c_types::ThirtyTwoU16s) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple__u1632_u1632Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple__u1632_u1632Z_new(a: crate::c_types::ThirtyTwoU16s, b: crate::c_types::ThirtyTwoU16s) -> C2Tuple__u1632_u1632Z {
	C2Tuple__u1632_u1632Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple__u1632_u1632Z.
pub extern "C" fn C2Tuple__u1632_u1632Z_free(_res: C2Tuple__u1632_u1632Z) { }
#[repr(C)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple__u1632_u1632Z or not
pub enum COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	/// When we're in this state, this COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ contains a crate::c_types::derived::C2Tuple__u1632_u1632Z
	Some(crate::c_types::derived::C2Tuple__u1632_u1632Z),
	/// When we're in this state, this COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ contains nothing
	None
}
impl COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple__u1632_u1632Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ containing a crate::c_types::derived::C2Tuple__u1632_u1632Z
pub extern "C" fn COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_some(o: crate::c_types::derived::C2Tuple__u1632_u1632Z) -> COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ containing nothing
pub extern "C" fn COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_none() -> COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
	COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple__u1632_u1632Z, if we are in the Some state
pub extern "C" fn COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_free(_res: COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a f64 or not
pub enum COption_f64Z {
	/// When we're in this state, this COption_f64Z contains a f64
	Some(f64),
	/// When we're in this state, this COption_f64Z contains nothing
	None
}
impl COption_f64Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> f64 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_f64Z containing a f64
pub extern "C" fn COption_f64Z_some(o: f64) -> COption_f64Z {
	COption_f64Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_f64Z containing nothing
pub extern "C" fn COption_f64Z_none() -> COption_f64Z {
	COption_f64Z::None
}
#[no_mangle]
/// Frees any resources associated with the f64, if we are in the Some state
pub extern "C" fn COption_f64Z_free(_res: COption_f64Z) { }
#[no_mangle]
/// Creates a new COption_f64Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_f64Z_clone(orig: &COption_f64Z) -> COption_f64Z { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ProbabilisticScorerDecodeErrorZ
pub union CResult_ProbabilisticScorerDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::scoring::ProbabilisticScorer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ProbabilisticScorerDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::scoring::ProbabilisticScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ProbabilisticScorerDecodeErrorZ {
	/// The contents of this CResult_ProbabilisticScorerDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ProbabilisticScorerDecodeErrorZPtr,
	/// Whether this CResult_ProbabilisticScorerDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the success state.
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_ok(o: crate::lightning::routing::scoring::ProbabilisticScorer) -> CResult_ProbabilisticScorerDecodeErrorZ {
	CResult_ProbabilisticScorerDecodeErrorZ {
		contents: CResult_ProbabilisticScorerDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the error state.
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ProbabilisticScorerDecodeErrorZ {
	CResult_ProbabilisticScorerDecodeErrorZ {
		contents: CResult_ProbabilisticScorerDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_is_ok(o: &CResult_ProbabilisticScorerDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ProbabilisticScorerDecodeErrorZ.
pub extern "C" fn CResult_ProbabilisticScorerDecodeErrorZ_free(_res: CResult_ProbabilisticScorerDecodeErrorZ) { }
impl Drop for CResult_ProbabilisticScorerDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::scoring::ProbabilisticScorer, crate::lightning::ln::msgs::DecodeError>> for CResult_ProbabilisticScorerDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::scoring::ProbabilisticScorer, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ProbabilisticScorerDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ProbabilisticScorerDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_usizeTransactionZ {
	/// The element at position 0
	pub a: usize,
	/// The element at position 1
	pub b: crate::c_types::Transaction,
}
impl From<(usize, crate::c_types::Transaction)> for C2Tuple_usizeTransactionZ {
	fn from (tup: (usize, crate::c_types::Transaction)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_usizeTransactionZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (usize, crate::c_types::Transaction) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_usizeTransactionZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_usizeTransactionZ_clone(orig: &C2Tuple_usizeTransactionZ) -> C2Tuple_usizeTransactionZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_usizeTransactionZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_usizeTransactionZ_new(a: usize, b: crate::c_types::Transaction) -> C2Tuple_usizeTransactionZ {
	C2Tuple_usizeTransactionZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_usizeTransactionZ.
pub extern "C" fn C2Tuple_usizeTransactionZ_free(_res: C2Tuple_usizeTransactionZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_usizeTransactionZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_usizeTransactionZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_usizeTransactionZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_usizeTransactionZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_usizeTransactionZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_usizeTransactionZ>> for CVec_C2Tuple_usizeTransactionZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_usizeTransactionZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_usizeTransactionZZ_free(_res: CVec_C2Tuple_usizeTransactionZZ) { }
impl Drop for CVec_C2Tuple_usizeTransactionZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_usizeTransactionZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: u32,
	/// The element at position 2
	pub c: crate::c_types::derived::COption_ThirtyTwoBytesZ,
}
impl From<(crate::c_types::ThirtyTwoBytes, u32, crate::c_types::derived::COption_ThirtyTwoBytesZ)> for C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, u32, crate::c_types::derived::COption_ThirtyTwoBytesZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, u32, crate::c_types::derived::COption_ThirtyTwoBytesZ) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ_clone(orig: &C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ) -> C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ_new(a: crate::c_types::ThirtyTwoBytes, b: u32, c: crate::c_types::derived::COption_ThirtyTwoBytesZ) -> C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ {
	C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ.
pub extern "C" fn C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ_free(_res: C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ>> for CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	fn from(v: Vec<crate::c_types::derived::C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ_free(_res: CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ) { }
impl Drop for CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C3Tuple_ThirtyTwoBytesu32COption_ThirtyTwoBytesZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_ChannelMonitorUpdateStatusNoneZ
pub union CResult_ChannelMonitorUpdateStatusNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::ChannelMonitorUpdateStatus,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_ChannelMonitorUpdateStatusNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::ChannelMonitorUpdateStatus on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelMonitorUpdateStatusNoneZ {
	/// The contents of this CResult_ChannelMonitorUpdateStatusNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelMonitorUpdateStatusNoneZPtr,
	/// Whether this CResult_ChannelMonitorUpdateStatusNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateStatusNoneZ in the success state.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_ok(o: crate::lightning::chain::ChannelMonitorUpdateStatus) -> CResult_ChannelMonitorUpdateStatusNoneZ {
	CResult_ChannelMonitorUpdateStatusNoneZ {
		contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateStatusNoneZ in the error state.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_err() -> CResult_ChannelMonitorUpdateStatusNoneZ {
	CResult_ChannelMonitorUpdateStatusNoneZ {
		contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_is_ok(o: &CResult_ChannelMonitorUpdateStatusNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelMonitorUpdateStatusNoneZ.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_free(_res: CResult_ChannelMonitorUpdateStatusNoneZ) { }
impl Drop for CResult_ChannelMonitorUpdateStatusNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::ChannelMonitorUpdateStatus, ()>> for CResult_ChannelMonitorUpdateStatusNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::ChannelMonitorUpdateStatus, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelMonitorUpdateStatusNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_ChannelMonitorUpdateStatusNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelMonitorUpdateStatusNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::ChannelMonitorUpdateStatus>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelMonitorUpdateStatusNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateStatusNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelMonitorUpdateStatusNoneZ_clone(orig: &CResult_ChannelMonitorUpdateStatusNoneZ) -> CResult_ChannelMonitorUpdateStatusNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_MonitorEventZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::channelmonitor::MonitorEvent,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_MonitorEventZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::channelmonitor::MonitorEvent> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::channelmonitor::MonitorEvent] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::channelmonitor::MonitorEvent>> for CVec_MonitorEventZ {
	fn from(v: Vec<crate::lightning::chain::channelmonitor::MonitorEvent>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_MonitorEventZ_free(_res: CVec_MonitorEventZ) { }
impl Drop for CVec_MonitorEventZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_MonitorEventZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_MonitorEventZ,
	/// The element at position 2
	pub c: crate::c_types::PublicKey,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_MonitorEventZ, crate::c_types::PublicKey)> for C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_MonitorEventZ, crate::c_types::PublicKey)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_MonitorEventZ, crate::c_types::PublicKey) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(orig: &C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ) -> C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::c_types::derived::CVec_MonitorEventZ, c: crate::c_types::PublicKey) -> C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
	C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ.
pub extern "C" fn C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(_res: C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ>> for CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
	fn from(v: Vec<crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(_res: CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ) { }
impl Drop for CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_InitFeaturesDecodeErrorZ
pub union CResult_InitFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::InitFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InitFeaturesDecodeErrorZ {
	/// The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InitFeaturesDecodeErrorZPtr,
	/// Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::InitFeatures) -> CResult_InitFeaturesDecodeErrorZ {
	CResult_InitFeaturesDecodeErrorZ {
		contents: CResult_InitFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InitFeaturesDecodeErrorZ {
	CResult_InitFeaturesDecodeErrorZ {
		contents: CResult_InitFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_is_ok(o: &CResult_InitFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_free(_res: CResult_InitFeaturesDecodeErrorZ) { }
impl Drop for CResult_InitFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::InitFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_InitFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::InitFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InitFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InitFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InitFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InitFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::InitFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InitFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InitFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InitFeaturesDecodeErrorZ_clone(orig: &CResult_InitFeaturesDecodeErrorZ) -> CResult_InitFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelFeaturesDecodeErrorZ
pub union CResult_ChannelFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::ChannelFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelFeaturesDecodeErrorZ {
	/// The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelFeaturesDecodeErrorZPtr,
	/// Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::ChannelFeatures) -> CResult_ChannelFeaturesDecodeErrorZ {
	CResult_ChannelFeaturesDecodeErrorZ {
		contents: CResult_ChannelFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelFeaturesDecodeErrorZ {
	CResult_ChannelFeaturesDecodeErrorZ {
		contents: CResult_ChannelFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_is_ok(o: &CResult_ChannelFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_free(_res: CResult_ChannelFeaturesDecodeErrorZ) { }
impl Drop for CResult_ChannelFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::ChannelFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::ChannelFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::ChannelFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelFeaturesDecodeErrorZ_clone(orig: &CResult_ChannelFeaturesDecodeErrorZ) -> CResult_ChannelFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeFeaturesDecodeErrorZ
pub union CResult_NodeFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::NodeFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeFeaturesDecodeErrorZ {
	/// The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeFeaturesDecodeErrorZPtr,
	/// Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::NodeFeatures) -> CResult_NodeFeaturesDecodeErrorZ {
	CResult_NodeFeaturesDecodeErrorZ {
		contents: CResult_NodeFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeFeaturesDecodeErrorZ {
	CResult_NodeFeaturesDecodeErrorZ {
		contents: CResult_NodeFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_is_ok(o: &CResult_NodeFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_free(_res: CResult_NodeFeaturesDecodeErrorZ) { }
impl Drop for CResult_NodeFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::NodeFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::NodeFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::NodeFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeFeaturesDecodeErrorZ_clone(orig: &CResult_NodeFeaturesDecodeErrorZ) -> CResult_NodeFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceFeaturesDecodeErrorZ
pub union CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::Bolt11InvoiceFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::Bolt11InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	/// The contents of this CResult_Bolt11InvoiceFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::Bolt11InvoiceFeatures) -> CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_is_ok(o: &CResult_Bolt11InvoiceFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceFeaturesDecodeErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_free(_res: CResult_Bolt11InvoiceFeaturesDecodeErrorZ) { }
impl Drop for CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::Bolt11InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::Bolt11InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::Bolt11InvoiceFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone(orig: &CResult_Bolt11InvoiceFeaturesDecodeErrorZ) -> CResult_Bolt11InvoiceFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt12InvoiceFeaturesDecodeErrorZ
pub union CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::Bolt12InvoiceFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_Bolt12InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::Bolt12InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	/// The contents of this CResult_Bolt12InvoiceFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr,
	/// Whether this CResult_Bolt12InvoiceFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::Bolt12InvoiceFeatures) -> CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
		contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_is_ok(o: &CResult_Bolt12InvoiceFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt12InvoiceFeaturesDecodeErrorZ.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_free(_res: CResult_Bolt12InvoiceFeaturesDecodeErrorZ) { }
impl Drop for CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::Bolt12InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::Bolt12InvoiceFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt12InvoiceFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::Bolt12InvoiceFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone(orig: &CResult_Bolt12InvoiceFeaturesDecodeErrorZ) -> CResult_Bolt12InvoiceFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedHopFeaturesDecodeErrorZ
pub union CResult_BlindedHopFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::BlindedHopFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedHopFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::BlindedHopFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedHopFeaturesDecodeErrorZ {
	/// The contents of this CResult_BlindedHopFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedHopFeaturesDecodeErrorZPtr,
	/// Whether this CResult_BlindedHopFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedHopFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::BlindedHopFeatures) -> CResult_BlindedHopFeaturesDecodeErrorZ {
	CResult_BlindedHopFeaturesDecodeErrorZ {
		contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedHopFeaturesDecodeErrorZ {
	CResult_BlindedHopFeaturesDecodeErrorZ {
		contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_is_ok(o: &CResult_BlindedHopFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedHopFeaturesDecodeErrorZ.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_free(_res: CResult_BlindedHopFeaturesDecodeErrorZ) { }
impl Drop for CResult_BlindedHopFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::BlindedHopFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedHopFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::BlindedHopFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedHopFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedHopFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedHopFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::BlindedHopFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedHopFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedHopFeaturesDecodeErrorZ_clone(orig: &CResult_BlindedHopFeaturesDecodeErrorZ) -> CResult_BlindedHopFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelTypeFeaturesDecodeErrorZ
pub union CResult_ChannelTypeFeaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::features::ChannelTypeFeatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelTypeFeaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::features::ChannelTypeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelTypeFeaturesDecodeErrorZ {
	/// The contents of this CResult_ChannelTypeFeaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr,
	/// Whether this CResult_ChannelTypeFeaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o: crate::lightning::ln::features::ChannelTypeFeatures) -> CResult_ChannelTypeFeaturesDecodeErrorZ {
	CResult_ChannelTypeFeaturesDecodeErrorZ {
		contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelTypeFeaturesDecodeErrorZ {
	CResult_ChannelTypeFeaturesDecodeErrorZ {
		contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o: &CResult_ChannelTypeFeaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelTypeFeaturesDecodeErrorZ.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res: CResult_ChannelTypeFeaturesDecodeErrorZ) { }
impl Drop for CResult_ChannelTypeFeaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::features::ChannelTypeFeatures, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelTypeFeaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::features::ChannelTypeFeatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelTypeFeaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelTypeFeaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelTypeFeaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::features::ChannelTypeFeatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelTypeFeaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelTypeFeaturesDecodeErrorZ_clone(orig: &CResult_ChannelTypeFeaturesDecodeErrorZ) -> CResult_ChannelTypeFeaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OfferBolt12ParseErrorZ
pub union CResult_OfferBolt12ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::offer::Offer,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12ParseError,
}
#[repr(C)]
/// A CResult_OfferBolt12ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::offer::Offer on success and a crate::lightning::offers::parse::Bolt12ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OfferBolt12ParseErrorZ {
	/// The contents of this CResult_OfferBolt12ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OfferBolt12ParseErrorZPtr,
	/// Whether this CResult_OfferBolt12ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12ParseErrorZ in the success state.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_ok(o: crate::lightning::offers::offer::Offer) -> CResult_OfferBolt12ParseErrorZ {
	CResult_OfferBolt12ParseErrorZ {
		contents: CResult_OfferBolt12ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12ParseErrorZ in the error state.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_err(e: crate::lightning::offers::parse::Bolt12ParseError) -> CResult_OfferBolt12ParseErrorZ {
	CResult_OfferBolt12ParseErrorZ {
		contents: CResult_OfferBolt12ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_is_ok(o: &CResult_OfferBolt12ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OfferBolt12ParseErrorZ.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_free(_res: CResult_OfferBolt12ParseErrorZ) { }
impl Drop for CResult_OfferBolt12ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::offers::parse::Bolt12ParseError>> for CResult_OfferBolt12ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::offer::Offer, crate::lightning::offers::parse::Bolt12ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OfferBolt12ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OfferBolt12ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OfferBolt12ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OfferBolt12ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::offer::Offer>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OfferBolt12ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OfferBolt12ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OfferBolt12ParseErrorZ_clone(orig: &CResult_OfferBolt12ParseErrorZ) -> CResult_OfferBolt12ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PublicKeySecp256k1ErrorZ
pub union CResult_PublicKeySecp256k1ErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::PublicKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::Secp256k1Error,
}
#[repr(C)]
/// A CResult_PublicKeySecp256k1ErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PublicKeySecp256k1ErrorZ {
	/// The contents of this CResult_PublicKeySecp256k1ErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PublicKeySecp256k1ErrorZPtr,
	/// Whether this CResult_PublicKeySecp256k1ErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PublicKeySecp256k1ErrorZ in the success state.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_ok(o: crate::c_types::PublicKey) -> CResult_PublicKeySecp256k1ErrorZ {
	CResult_PublicKeySecp256k1ErrorZ {
		contents: CResult_PublicKeySecp256k1ErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeySecp256k1ErrorZ in the error state.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_err(e: crate::c_types::Secp256k1Error) -> CResult_PublicKeySecp256k1ErrorZ {
	CResult_PublicKeySecp256k1ErrorZ {
		contents: CResult_PublicKeySecp256k1ErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_is_ok(o: &CResult_PublicKeySecp256k1ErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PublicKeySecp256k1ErrorZ.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_free(_res: CResult_PublicKeySecp256k1ErrorZ) { }
impl Drop for CResult_PublicKeySecp256k1ErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::PublicKey, crate::c_types::Secp256k1Error>> for CResult_PublicKeySecp256k1ErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::PublicKey, crate::c_types::Secp256k1Error>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PublicKeySecp256k1ErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PublicKeySecp256k1ErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PublicKeySecp256k1ErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PublicKeySecp256k1ErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::PublicKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PublicKeySecp256k1ErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::Secp256k1Error>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PublicKeySecp256k1ErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PublicKeySecp256k1ErrorZ_clone(orig: &CResult_PublicKeySecp256k1ErrorZ) -> CResult_PublicKeySecp256k1ErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeIdDecodeErrorZ
pub union CResult_NodeIdDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeId,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeIdDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeId on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeIdDecodeErrorZ {
	/// The contents of this CResult_NodeIdDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeIdDecodeErrorZPtr,
	/// Whether this CResult_NodeIdDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeIdDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeId) -> CResult_NodeIdDecodeErrorZ {
	CResult_NodeIdDecodeErrorZ {
		contents: CResult_NodeIdDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeIdDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeIdDecodeErrorZ {
	CResult_NodeIdDecodeErrorZ {
		contents: CResult_NodeIdDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeIdDecodeErrorZ_is_ok(o: &CResult_NodeIdDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeIdDecodeErrorZ.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_free(_res: CResult_NodeIdDecodeErrorZ) { }
impl Drop for CResult_NodeIdDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeId, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeIdDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeId, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeIdDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeIdDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeIdDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeIdDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeId>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeIdDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeIdDecodeErrorZ_clone(orig: &CResult_NodeIdDecodeErrorZ) -> CResult_NodeIdDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::routing::gossip::NetworkUpdate or not
pub enum COption_NetworkUpdateZ {
	/// When we're in this state, this COption_NetworkUpdateZ contains a crate::lightning::routing::gossip::NetworkUpdate
	Some(crate::lightning::routing::gossip::NetworkUpdate),
	/// When we're in this state, this COption_NetworkUpdateZ contains nothing
	None
}
impl COption_NetworkUpdateZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::gossip::NetworkUpdate {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::gossip::NetworkUpdate
pub extern "C" fn COption_NetworkUpdateZ_some(o: crate::lightning::routing::gossip::NetworkUpdate) -> COption_NetworkUpdateZ {
	COption_NetworkUpdateZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_NetworkUpdateZ containing nothing
pub extern "C" fn COption_NetworkUpdateZ_none() -> COption_NetworkUpdateZ {
	COption_NetworkUpdateZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::gossip::NetworkUpdate, if we are in the Some state
pub extern "C" fn COption_NetworkUpdateZ_free(_res: COption_NetworkUpdateZ) { }
#[no_mangle]
/// Creates a new COption_NetworkUpdateZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_NetworkUpdateZ_clone(orig: &COption_NetworkUpdateZ) -> COption_NetworkUpdateZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_NetworkUpdateZDecodeErrorZ
pub union CResult_COption_NetworkUpdateZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_NetworkUpdateZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_NetworkUpdateZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_NetworkUpdateZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_NetworkUpdateZDecodeErrorZ {
	/// The contents of this CResult_COption_NetworkUpdateZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr,
	/// Whether this CResult_COption_NetworkUpdateZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o: crate::c_types::derived::COption_NetworkUpdateZ) -> CResult_COption_NetworkUpdateZDecodeErrorZ {
	CResult_COption_NetworkUpdateZDecodeErrorZ {
		contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_NetworkUpdateZDecodeErrorZ {
	CResult_COption_NetworkUpdateZDecodeErrorZ {
		contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o: &CResult_COption_NetworkUpdateZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_NetworkUpdateZDecodeErrorZ.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res: CResult_COption_NetworkUpdateZDecodeErrorZ) { }
impl Drop for CResult_COption_NetworkUpdateZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_NetworkUpdateZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_NetworkUpdateZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_NetworkUpdateZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_NetworkUpdateZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_NetworkUpdateZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_NetworkUpdateZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_NetworkUpdateZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_NetworkUpdateZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig: &CResult_COption_NetworkUpdateZDecodeErrorZ) -> CResult_COption_NetworkUpdateZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::routing::utxo::UtxoLookup or not
pub enum COption_UtxoLookupZ {
	/// When we're in this state, this COption_UtxoLookupZ contains a crate::lightning::routing::utxo::UtxoLookup
	Some(crate::lightning::routing::utxo::UtxoLookup),
	/// When we're in this state, this COption_UtxoLookupZ contains nothing
	None
}
impl COption_UtxoLookupZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::routing::utxo::UtxoLookup {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_UtxoLookupZ containing a crate::lightning::routing::utxo::UtxoLookup
pub extern "C" fn COption_UtxoLookupZ_some(o: crate::lightning::routing::utxo::UtxoLookup) -> COption_UtxoLookupZ {
	COption_UtxoLookupZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_UtxoLookupZ containing nothing
pub extern "C" fn COption_UtxoLookupZ_none() -> COption_UtxoLookupZ {
	COption_UtxoLookupZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::routing::utxo::UtxoLookup, if we are in the Some state
pub extern "C" fn COption_UtxoLookupZ_free(_res: COption_UtxoLookupZ) { }
#[repr(C)]
/// The contents of CResult_NoneLightningErrorZ
pub union CResult_NoneLightningErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::LightningError,
}
#[repr(C)]
/// A CResult_NoneLightningErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneLightningErrorZ {
	/// The contents of this CResult_NoneLightningErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneLightningErrorZPtr,
	/// Whether this CResult_NoneLightningErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneLightningErrorZ in the success state.
pub extern "C" fn CResult_NoneLightningErrorZ_ok() -> CResult_NoneLightningErrorZ {
	CResult_NoneLightningErrorZ {
		contents: CResult_NoneLightningErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneLightningErrorZ in the error state.
pub extern "C" fn CResult_NoneLightningErrorZ_err(e: crate::lightning::ln::msgs::LightningError) -> CResult_NoneLightningErrorZ {
	CResult_NoneLightningErrorZ {
		contents: CResult_NoneLightningErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneLightningErrorZ_is_ok(o: &CResult_NoneLightningErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneLightningErrorZ.
pub extern "C" fn CResult_NoneLightningErrorZ_free(_res: CResult_NoneLightningErrorZ) { }
impl Drop for CResult_NoneLightningErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::msgs::LightningError>> for CResult_NoneLightningErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::msgs::LightningError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneLightningErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneLightningErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneLightningErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneLightningErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneLightningErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::LightningError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneLightningErrorZ_clone(orig: &CResult_NoneLightningErrorZ) -> CResult_NoneLightningErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_boolLightningErrorZ
pub union CResult_boolLightningErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut bool,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::LightningError,
}
#[repr(C)]
/// A CResult_boolLightningErrorZ represents the result of a fallible operation,
/// containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_boolLightningErrorZ {
	/// The contents of this CResult_boolLightningErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_boolLightningErrorZPtr,
	/// Whether this CResult_boolLightningErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_boolLightningErrorZ in the success state.
pub extern "C" fn CResult_boolLightningErrorZ_ok(o: bool) -> CResult_boolLightningErrorZ {
	CResult_boolLightningErrorZ {
		contents: CResult_boolLightningErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_boolLightningErrorZ in the error state.
pub extern "C" fn CResult_boolLightningErrorZ_err(e: crate::lightning::ln::msgs::LightningError) -> CResult_boolLightningErrorZ {
	CResult_boolLightningErrorZ {
		contents: CResult_boolLightningErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_boolLightningErrorZ_is_ok(o: &CResult_boolLightningErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_boolLightningErrorZ.
pub extern "C" fn CResult_boolLightningErrorZ_free(_res: CResult_boolLightningErrorZ) { }
impl Drop for CResult_boolLightningErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<bool, crate::lightning::ln::msgs::LightningError>> for CResult_boolLightningErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<bool, crate::lightning::ln::msgs::LightningError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_boolLightningErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_boolLightningErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_boolLightningErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_boolLightningErrorZPtr {
				result: Box::into_raw(Box::new(<bool>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_boolLightningErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::LightningError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_boolLightningErrorZ_clone(orig: &CResult_boolLightningErrorZ) -> CResult_boolLightningErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	/// The element at position 0
	pub a: crate::lightning::ln::msgs::ChannelAnnouncement,
	/// The element at position 1
	pub b: crate::lightning::ln::msgs::ChannelUpdate,
	/// The element at position 2
	pub c: crate::lightning::ln::msgs::ChannelUpdate,
}
impl From<(crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::ChannelUpdate)> for C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	fn from (tup: (crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::ChannelUpdate)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::ChannelUpdate) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig: &C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) -> C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a: crate::lightning::ln::msgs::ChannelAnnouncement, b: crate::lightning::ln::msgs::ChannelUpdate, c: crate::lightning::ln::msgs::ChannelUpdate) -> C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
	C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
pub extern "C" fn C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res: C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ or not
pub enum COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	/// When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
	Some(crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ),
	/// When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains nothing
	None
}
impl COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(o: crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) -> COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing nothing
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none() -> COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
	COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ, if we are in the Some state
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res: COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ) { }
#[no_mangle]
/// Creates a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(orig: &COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ) -> COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::MessageSendEvents of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_MessageSendEventZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::MessageSendEvent,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_MessageSendEventZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::MessageSendEvent> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::MessageSendEvent] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::MessageSendEvent>> for CVec_MessageSendEventZ {
	fn from(v: Vec<crate::lightning::events::MessageSendEvent>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_MessageSendEventZ_free(_res: CVec_MessageSendEventZ) { }
impl Drop for CVec_MessageSendEventZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_MessageSendEventZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_ChannelUpdateInfoDecodeErrorZ
pub union CResult_ChannelUpdateInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::ChannelUpdateInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelUpdateInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::ChannelUpdateInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelUpdateInfoDecodeErrorZ {
	/// The contents of this CResult_ChannelUpdateInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelUpdateInfoDecodeErrorZPtr,
	/// Whether this CResult_ChannelUpdateInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::ChannelUpdateInfo) -> CResult_ChannelUpdateInfoDecodeErrorZ {
	CResult_ChannelUpdateInfoDecodeErrorZ {
		contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelUpdateInfoDecodeErrorZ {
	CResult_ChannelUpdateInfoDecodeErrorZ {
		contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(o: &CResult_ChannelUpdateInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelUpdateInfoDecodeErrorZ.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_free(_res: CResult_ChannelUpdateInfoDecodeErrorZ) { }
impl Drop for CResult_ChannelUpdateInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelUpdateInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelUpdateInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelUpdateInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelUpdateInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelUpdateInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelUpdateInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::ChannelUpdateInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelUpdateInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelUpdateInfoDecodeErrorZ_clone(orig: &CResult_ChannelUpdateInfoDecodeErrorZ) -> CResult_ChannelUpdateInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelInfoDecodeErrorZ
pub union CResult_ChannelInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::ChannelInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelInfoDecodeErrorZ {
	/// The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelInfoDecodeErrorZPtr,
	/// Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::ChannelInfo) -> CResult_ChannelInfoDecodeErrorZ {
	CResult_ChannelInfoDecodeErrorZ {
		contents: CResult_ChannelInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelInfoDecodeErrorZ {
	CResult_ChannelInfoDecodeErrorZ {
		contents: CResult_ChannelInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_is_ok(o: &CResult_ChannelInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_free(_res: CResult_ChannelInfoDecodeErrorZ) { }
impl Drop for CResult_ChannelInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::ChannelInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::ChannelInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelInfoDecodeErrorZ_clone(orig: &CResult_ChannelInfoDecodeErrorZ) -> CResult_ChannelInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RoutingFeesDecodeErrorZ
pub union CResult_RoutingFeesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::RoutingFees,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RoutingFeesDecodeErrorZ {
	/// The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RoutingFeesDecodeErrorZPtr,
	/// Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_ok(o: crate::lightning::routing::gossip::RoutingFees) -> CResult_RoutingFeesDecodeErrorZ {
	CResult_RoutingFeesDecodeErrorZ {
		contents: CResult_RoutingFeesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RoutingFeesDecodeErrorZ {
	CResult_RoutingFeesDecodeErrorZ {
		contents: CResult_RoutingFeesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_is_ok(o: &CResult_RoutingFeesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_free(_res: CResult_RoutingFeesDecodeErrorZ) { }
impl Drop for CResult_RoutingFeesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::RoutingFees, crate::lightning::ln::msgs::DecodeError>> for CResult_RoutingFeesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::RoutingFees, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RoutingFeesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RoutingFeesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RoutingFeesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RoutingFeesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::RoutingFees>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RoutingFeesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RoutingFeesDecodeErrorZ_clone(orig: &CResult_RoutingFeesDecodeErrorZ) -> CResult_RoutingFeesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::SocketAddresss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_SocketAddressZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::SocketAddress,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_SocketAddressZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::SocketAddress> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::SocketAddress] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::SocketAddress>> for CVec_SocketAddressZ {
	fn from(v: Vec<crate::lightning::ln::msgs::SocketAddress>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_SocketAddressZ_free(_res: CVec_SocketAddressZ) { }
impl Drop for CVec_SocketAddressZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_SocketAddressZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
pub union CResult_NodeAnnouncementInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeAnnouncementInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeAnnouncementInfoDecodeErrorZ {
	/// The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr,
	/// Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeAnnouncementInfo) -> CResult_NodeAnnouncementInfoDecodeErrorZ {
	CResult_NodeAnnouncementInfoDecodeErrorZ {
		contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeAnnouncementInfoDecodeErrorZ {
	CResult_NodeAnnouncementInfoDecodeErrorZ {
		contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o: &CResult_NodeAnnouncementInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res: CResult_NodeAnnouncementInfoDecodeErrorZ) { }
impl Drop for CResult_NodeAnnouncementInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAnnouncementInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeAnnouncementInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAnnouncementInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeAnnouncementInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeAnnouncementInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeAnnouncementInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeAnnouncementInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeAnnouncementInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig: &CResult_NodeAnnouncementInfoDecodeErrorZ) -> CResult_NodeAnnouncementInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeAliasDecodeErrorZ
pub union CResult_NodeAliasDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeAlias,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeAliasDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeAlias on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeAliasDecodeErrorZ {
	/// The contents of this CResult_NodeAliasDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeAliasDecodeErrorZPtr,
	/// Whether this CResult_NodeAliasDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeAliasDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeAlias) -> CResult_NodeAliasDecodeErrorZ {
	CResult_NodeAliasDecodeErrorZ {
		contents: CResult_NodeAliasDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAliasDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeAliasDecodeErrorZ {
	CResult_NodeAliasDecodeErrorZ {
		contents: CResult_NodeAliasDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_is_ok(o: &CResult_NodeAliasDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeAliasDecodeErrorZ.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_free(_res: CResult_NodeAliasDecodeErrorZ) { }
impl Drop for CResult_NodeAliasDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAlias, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeAliasDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeAlias, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeAliasDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeAliasDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeAliasDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeAliasDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeAlias>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeAliasDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAliasDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeAliasDecodeErrorZ_clone(orig: &CResult_NodeAliasDecodeErrorZ) -> CResult_NodeAliasDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeInfoDecodeErrorZ
pub union CResult_NodeInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NodeInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeInfoDecodeErrorZ {
	/// The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeInfoDecodeErrorZPtr,
	/// Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NodeInfo) -> CResult_NodeInfoDecodeErrorZ {
	CResult_NodeInfoDecodeErrorZ {
		contents: CResult_NodeInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeInfoDecodeErrorZ {
	CResult_NodeInfoDecodeErrorZ {
		contents: CResult_NodeInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_is_ok(o: &CResult_NodeInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_free(_res: CResult_NodeInfoDecodeErrorZ) { }
impl Drop for CResult_NodeInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NodeInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::routing::gossip::NodeInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeInfoDecodeErrorZ_clone(orig: &CResult_NodeInfoDecodeErrorZ) -> CResult_NodeInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NetworkGraphDecodeErrorZ
pub union CResult_NetworkGraphDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::routing::gossip::NetworkGraph,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::routing::gossip::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NetworkGraphDecodeErrorZ {
	/// The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NetworkGraphDecodeErrorZPtr,
	/// Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_ok(o: crate::lightning::routing::gossip::NetworkGraph) -> CResult_NetworkGraphDecodeErrorZ {
	CResult_NetworkGraphDecodeErrorZ {
		contents: CResult_NetworkGraphDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NetworkGraphDecodeErrorZ {
	CResult_NetworkGraphDecodeErrorZ {
		contents: CResult_NetworkGraphDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_is_ok(o: &CResult_NetworkGraphDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
pub extern "C" fn CResult_NetworkGraphDecodeErrorZ_free(_res: CResult_NetworkGraphDecodeErrorZ) { }
impl Drop for CResult_NetworkGraphDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::routing::gossip::NetworkGraph, crate::lightning::ln::msgs::DecodeError>> for CResult_NetworkGraphDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::routing::gossip::NetworkGraph, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NetworkGraphDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NetworkGraphDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::CVec_SocketAddressZ or not
pub enum COption_CVec_SocketAddressZZ {
	/// When we're in this state, this COption_CVec_SocketAddressZZ contains a crate::c_types::derived::CVec_SocketAddressZ
	Some(crate::c_types::derived::CVec_SocketAddressZ),
	/// When we're in this state, this COption_CVec_SocketAddressZZ contains nothing
	None
}
impl COption_CVec_SocketAddressZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::CVec_SocketAddressZ {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_CVec_SocketAddressZZ containing a crate::c_types::derived::CVec_SocketAddressZ
pub extern "C" fn COption_CVec_SocketAddressZZ_some(o: crate::c_types::derived::CVec_SocketAddressZ) -> COption_CVec_SocketAddressZZ {
	COption_CVec_SocketAddressZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_CVec_SocketAddressZZ containing nothing
pub extern "C" fn COption_CVec_SocketAddressZZ_none() -> COption_CVec_SocketAddressZZ {
	COption_CVec_SocketAddressZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::CVec_SocketAddressZ, if we are in the Some state
pub extern "C" fn COption_CVec_SocketAddressZZ_free(_res: COption_CVec_SocketAddressZZ) { }
#[no_mangle]
/// Creates a new COption_CVec_SocketAddressZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_CVec_SocketAddressZZ_clone(orig: &COption_CVec_SocketAddressZZ) -> COption_CVec_SocketAddressZZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PendingHTLCInfoInboundHTLCErrZ
pub union CResult_PendingHTLCInfoInboundHTLCErrZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PendingHTLCInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::onion_payment::InboundHTLCErr,
}
#[repr(C)]
/// A CResult_PendingHTLCInfoInboundHTLCErrZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PendingHTLCInfo on success and a crate::lightning::ln::onion_payment::InboundHTLCErr on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PendingHTLCInfoInboundHTLCErrZ {
	/// The contents of this CResult_PendingHTLCInfoInboundHTLCErrZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr,
	/// Whether this CResult_PendingHTLCInfoInboundHTLCErrZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoInboundHTLCErrZ in the success state.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_ok(o: crate::lightning::ln::channelmanager::PendingHTLCInfo) -> CResult_PendingHTLCInfoInboundHTLCErrZ {
	CResult_PendingHTLCInfoInboundHTLCErrZ {
		contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoInboundHTLCErrZ in the error state.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_err(e: crate::lightning::ln::onion_payment::InboundHTLCErr) -> CResult_PendingHTLCInfoInboundHTLCErrZ {
	CResult_PendingHTLCInfoInboundHTLCErrZ {
		contents: CResult_PendingHTLCInfoInboundHTLCErrZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_is_ok(o: &CResult_PendingHTLCInfoInboundHTLCErrZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PendingHTLCInfoInboundHTLCErrZ.
pub extern "C" fn CResult_PendingHTLCInfoInboundHTLCErrZ_free(_res: CResult_PendingHTLCInfoInboundHTLCErrZ) { }
impl Drop for CResult_PendingHTLCInfoInboundHTLCErrZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::onion_payment::InboundHTLCErr>> for CResult_PendingHTLCInfoInboundHTLCErrZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::onion_payment::InboundHTLCErr>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PendingHTLCInfoInboundHTLCErrZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PendingHTLCInfoInboundHTLCErrZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::chan_utils::HTLCOutputInCommitments of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_HTLCOutputInCommitmentZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::chan_utils::HTLCOutputInCommitment,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_HTLCOutputInCommitmentZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::chan_utils::HTLCOutputInCommitment> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::chan_utils::HTLCOutputInCommitment] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::chan_utils::HTLCOutputInCommitment>> for CVec_HTLCOutputInCommitmentZ {
	fn from(v: Vec<crate::lightning::ln::chan_utils::HTLCOutputInCommitment>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_HTLCOutputInCommitmentZ_free(_res: CVec_HTLCOutputInCommitmentZ) { }
impl Drop for CVec_HTLCOutputInCommitmentZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_HTLCOutputInCommitmentZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::sign::HTLCDescriptors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_HTLCDescriptorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::sign::HTLCDescriptor,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_HTLCDescriptorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::sign::HTLCDescriptor> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::sign::HTLCDescriptor] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::sign::HTLCDescriptor>> for CVec_HTLCDescriptorZ {
	fn from(v: Vec<crate::lightning::sign::HTLCDescriptor>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_HTLCDescriptorZ_free(_res: CVec_HTLCDescriptorZ) { }
impl Drop for CVec_HTLCDescriptorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_HTLCDescriptorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::bump_transaction::Utxos of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UtxoZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::bump_transaction::Utxo,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UtxoZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::bump_transaction::Utxo> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::bump_transaction::Utxo] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::bump_transaction::Utxo>> for CVec_UtxoZ {
	fn from(v: Vec<crate::lightning::events::bump_transaction::Utxo>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UtxoZ_free(_res: CVec_UtxoZ) { }
impl Drop for CVec_UtxoZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UtxoZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::TxOut or not
pub enum COption_TxOutZ {
	/// When we're in this state, this COption_TxOutZ contains a crate::c_types::TxOut
	Some(crate::c_types::TxOut),
	/// When we're in this state, this COption_TxOutZ contains nothing
	None
}
impl COption_TxOutZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::TxOut {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_TxOutZ containing a crate::c_types::TxOut
pub extern "C" fn COption_TxOutZ_some(o: crate::c_types::TxOut) -> COption_TxOutZ {
	COption_TxOutZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_TxOutZ containing nothing
pub extern "C" fn COption_TxOutZ_none() -> COption_TxOutZ {
	COption_TxOutZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::TxOut, if we are in the Some state
pub extern "C" fn COption_TxOutZ_free(_res: COption_TxOutZ) { }
#[no_mangle]
/// Creates a new COption_TxOutZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_TxOutZ_clone(orig: &COption_TxOutZ) -> COption_TxOutZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::bump_transaction::Inputs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_InputZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::bump_transaction::Input,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_InputZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::bump_transaction::Input> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::bump_transaction::Input] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::bump_transaction::Input>> for CVec_InputZ {
	fn from(v: Vec<crate::lightning::events::bump_transaction::Input>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_InputZ_free(_res: CVec_InputZ) { }
impl Drop for CVec_InputZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_InputZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CoinSelectionNoneZ
pub union CResult_CoinSelectionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::bump_transaction::CoinSelection,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CoinSelectionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::events::bump_transaction::CoinSelection on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CoinSelectionNoneZ {
	/// The contents of this CResult_CoinSelectionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CoinSelectionNoneZPtr,
	/// Whether this CResult_CoinSelectionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CoinSelectionNoneZ in the success state.
pub extern "C" fn CResult_CoinSelectionNoneZ_ok(o: crate::lightning::events::bump_transaction::CoinSelection) -> CResult_CoinSelectionNoneZ {
	CResult_CoinSelectionNoneZ {
		contents: CResult_CoinSelectionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CoinSelectionNoneZ in the error state.
pub extern "C" fn CResult_CoinSelectionNoneZ_err() -> CResult_CoinSelectionNoneZ {
	CResult_CoinSelectionNoneZ {
		contents: CResult_CoinSelectionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CoinSelectionNoneZ_is_ok(o: &CResult_CoinSelectionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CoinSelectionNoneZ.
pub extern "C" fn CResult_CoinSelectionNoneZ_free(_res: CResult_CoinSelectionNoneZ) { }
impl Drop for CResult_CoinSelectionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::bump_transaction::CoinSelection, ()>> for CResult_CoinSelectionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::bump_transaction::CoinSelection, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CoinSelectionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CoinSelectionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CoinSelectionNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CoinSelectionNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::bump_transaction::CoinSelection>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CoinSelectionNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CoinSelectionNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CoinSelectionNoneZ_clone(orig: &CResult_CoinSelectionNoneZ) -> CResult_CoinSelectionNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CVec_UtxoZNoneZ
pub union CResult_CVec_UtxoZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_UtxoZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_UtxoZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_UtxoZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_UtxoZNoneZ {
	/// The contents of this CResult_CVec_UtxoZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_UtxoZNoneZPtr,
	/// Whether this CResult_CVec_UtxoZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_UtxoZNoneZ in the success state.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_ok(o: crate::c_types::derived::CVec_UtxoZ) -> CResult_CVec_UtxoZNoneZ {
	CResult_CVec_UtxoZNoneZ {
		contents: CResult_CVec_UtxoZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_UtxoZNoneZ in the error state.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_err() -> CResult_CVec_UtxoZNoneZ {
	CResult_CVec_UtxoZNoneZ {
		contents: CResult_CVec_UtxoZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_UtxoZNoneZ_is_ok(o: &CResult_CVec_UtxoZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_UtxoZNoneZ.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_free(_res: CResult_CVec_UtxoZNoneZ) { }
impl Drop for CResult_CVec_UtxoZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_UtxoZ, ()>> for CResult_CVec_UtxoZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_UtxoZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_UtxoZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_UtxoZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_UtxoZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_UtxoZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_UtxoZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_UtxoZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_UtxoZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_UtxoZNoneZ_clone(orig: &CResult_CVec_UtxoZNoneZ) -> CResult_CVec_UtxoZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u64u16Z {
	/// The element at position 0
	pub a: u64,
	/// The element at position 1
	pub b: u16,
}
impl From<(u64, u16)> for C2Tuple_u64u16Z {
	fn from (tup: (u64, u16)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u64u16Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u64, u16) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u64u16Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u64u16Z_clone(orig: &C2Tuple_u64u16Z) -> C2Tuple_u64u16Z { Clone::clone(&orig) }
/// Creates a new C2Tuple_u64u16Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u64u16Z_new(a: u64, b: u16) -> C2Tuple_u64u16Z {
	C2Tuple_u64u16Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u64u16Z.
pub extern "C" fn C2Tuple_u64u16Z_free(_res: C2Tuple_u64u16Z) { }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::derived::C2Tuple_u64u16Z or not
pub enum COption_C2Tuple_u64u16ZZ {
	/// When we're in this state, this COption_C2Tuple_u64u16ZZ contains a crate::c_types::derived::C2Tuple_u64u16Z
	Some(crate::c_types::derived::C2Tuple_u64u16Z),
	/// When we're in this state, this COption_C2Tuple_u64u16ZZ contains nothing
	None
}
impl COption_C2Tuple_u64u16ZZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::derived::C2Tuple_u64u16Z {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u16ZZ containing a crate::c_types::derived::C2Tuple_u64u16Z
pub extern "C" fn COption_C2Tuple_u64u16ZZ_some(o: crate::c_types::derived::C2Tuple_u64u16Z) -> COption_C2Tuple_u64u16ZZ {
	COption_C2Tuple_u64u16ZZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_C2Tuple_u64u16ZZ containing nothing
pub extern "C" fn COption_C2Tuple_u64u16ZZ_none() -> COption_C2Tuple_u64u16ZZ {
	COption_C2Tuple_u64u16ZZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u16Z, if we are in the Some state
pub extern "C" fn COption_C2Tuple_u64u16ZZ_free(_res: COption_C2Tuple_u64u16ZZ) { }
#[no_mangle]
/// Creates a new COption_C2Tuple_u64u16ZZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_C2Tuple_u64u16ZZ_clone(orig: &COption_C2Tuple_u64u16ZZ) -> COption_C2Tuple_u64u16ZZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::channelmanager::ChannelShutdownState or not
pub enum COption_ChannelShutdownStateZ {
	/// When we're in this state, this COption_ChannelShutdownStateZ contains a crate::lightning::ln::channelmanager::ChannelShutdownState
	Some(crate::lightning::ln::channelmanager::ChannelShutdownState),
	/// When we're in this state, this COption_ChannelShutdownStateZ contains nothing
	None
}
impl COption_ChannelShutdownStateZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::channelmanager::ChannelShutdownState {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ChannelShutdownStateZ containing a crate::lightning::ln::channelmanager::ChannelShutdownState
pub extern "C" fn COption_ChannelShutdownStateZ_some(o: crate::lightning::ln::channelmanager::ChannelShutdownState) -> COption_ChannelShutdownStateZ {
	COption_ChannelShutdownStateZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ChannelShutdownStateZ containing nothing
pub extern "C" fn COption_ChannelShutdownStateZ_none() -> COption_ChannelShutdownStateZ {
	COption_ChannelShutdownStateZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::channelmanager::ChannelShutdownState, if we are in the Some state
pub extern "C" fn COption_ChannelShutdownStateZ_free(_res: COption_ChannelShutdownStateZ) { }
#[no_mangle]
/// Creates a new COption_ChannelShutdownStateZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ChannelShutdownStateZ_clone(orig: &COption_ChannelShutdownStateZ) -> COption_ChannelShutdownStateZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesAPIErrorZ
pub union CResult_ThirtyTwoBytesAPIErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::util::errors::APIError,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesAPIErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesAPIErrorZ {
	/// The contents of this CResult_ThirtyTwoBytesAPIErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesAPIErrorZPtr,
	/// Whether this CResult_ThirtyTwoBytesAPIErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesAPIErrorZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesAPIErrorZ {
	CResult_ThirtyTwoBytesAPIErrorZ {
		contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesAPIErrorZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_err(e: crate::lightning::util::errors::APIError) -> CResult_ThirtyTwoBytesAPIErrorZ {
	CResult_ThirtyTwoBytesAPIErrorZ {
		contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_is_ok(o: &CResult_ThirtyTwoBytesAPIErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesAPIErrorZ.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_free(_res: CResult_ThirtyTwoBytesAPIErrorZ) { }
impl Drop for CResult_ThirtyTwoBytesAPIErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::util::errors::APIError>> for CResult_ThirtyTwoBytesAPIErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::util::errors::APIError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesAPIErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ThirtyTwoBytesAPIErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesAPIErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesAPIErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::util::errors::APIError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesAPIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesAPIErrorZ_clone(orig: &CResult_ThirtyTwoBytesAPIErrorZ) -> CResult_ThirtyTwoBytesAPIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channelmanager::RecentPaymentDetailss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_RecentPaymentDetailsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channelmanager::RecentPaymentDetails,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_RecentPaymentDetailsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channelmanager::RecentPaymentDetails> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channelmanager::RecentPaymentDetails] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channelmanager::RecentPaymentDetails>> for CVec_RecentPaymentDetailsZ {
	fn from(v: Vec<crate::lightning::ln::channelmanager::RecentPaymentDetails>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_RecentPaymentDetailsZ_free(_res: CVec_RecentPaymentDetailsZ) { }
impl Drop for CVec_RecentPaymentDetailsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
#[repr(C)]
/// The contents of CResult_NonePaymentSendFailureZ
pub union CResult_NonePaymentSendFailureZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::PaymentSendFailure,
}
#[repr(C)]
/// A CResult_NonePaymentSendFailureZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::outbound_payment::PaymentSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NonePaymentSendFailureZ {
	/// The contents of this CResult_NonePaymentSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NonePaymentSendFailureZPtr,
	/// Whether this CResult_NonePaymentSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NonePaymentSendFailureZ in the success state.
pub extern "C" fn CResult_NonePaymentSendFailureZ_ok() -> CResult_NonePaymentSendFailureZ {
	CResult_NonePaymentSendFailureZ {
		contents: CResult_NonePaymentSendFailureZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NonePaymentSendFailureZ in the error state.
pub extern "C" fn CResult_NonePaymentSendFailureZ_err(e: crate::lightning::ln::outbound_payment::PaymentSendFailure) -> CResult_NonePaymentSendFailureZ {
	CResult_NonePaymentSendFailureZ {
		contents: CResult_NonePaymentSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NonePaymentSendFailureZ_is_ok(o: &CResult_NonePaymentSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NonePaymentSendFailureZ.
pub extern "C" fn CResult_NonePaymentSendFailureZ_free(_res: CResult_NonePaymentSendFailureZ) { }
impl Drop for CResult_NonePaymentSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::PaymentSendFailure>> for CResult_NonePaymentSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::PaymentSendFailure>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NonePaymentSendFailureZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NonePaymentSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NonePaymentSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NonePaymentSendFailureZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NonePaymentSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::PaymentSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NonePaymentSendFailureZ_clone(orig: &CResult_NonePaymentSendFailureZ) -> CResult_NonePaymentSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneRetryableSendFailureZ
pub union CResult_NoneRetryableSendFailureZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::RetryableSendFailure,
}
#[repr(C)]
/// A CResult_NoneRetryableSendFailureZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::outbound_payment::RetryableSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneRetryableSendFailureZ {
	/// The contents of this CResult_NoneRetryableSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneRetryableSendFailureZPtr,
	/// Whether this CResult_NoneRetryableSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneRetryableSendFailureZ in the success state.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_ok() -> CResult_NoneRetryableSendFailureZ {
	CResult_NoneRetryableSendFailureZ {
		contents: CResult_NoneRetryableSendFailureZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneRetryableSendFailureZ in the error state.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_err(e: crate::lightning::ln::outbound_payment::RetryableSendFailure) -> CResult_NoneRetryableSendFailureZ {
	CResult_NoneRetryableSendFailureZ {
		contents: CResult_NoneRetryableSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneRetryableSendFailureZ_is_ok(o: &CResult_NoneRetryableSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneRetryableSendFailureZ.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_free(_res: CResult_NoneRetryableSendFailureZ) { }
impl Drop for CResult_NoneRetryableSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::RetryableSendFailure>> for CResult_NoneRetryableSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::outbound_payment::RetryableSendFailure>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneRetryableSendFailureZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneRetryableSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneRetryableSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneRetryableSendFailureZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneRetryableSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RetryableSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneRetryableSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneRetryableSendFailureZ_clone(orig: &CResult_NoneRetryableSendFailureZ) -> CResult_NoneRetryableSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesPaymentSendFailureZ
pub union CResult_ThirtyTwoBytesPaymentSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::PaymentSendFailure,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesPaymentSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::outbound_payment::PaymentSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesPaymentSendFailureZ {
	/// The contents of this CResult_ThirtyTwoBytesPaymentSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesPaymentSendFailureZPtr,
	/// Whether this CResult_ThirtyTwoBytesPaymentSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesPaymentSendFailureZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesPaymentSendFailureZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesPaymentSendFailureZ {
	CResult_ThirtyTwoBytesPaymentSendFailureZ {
		contents: CResult_ThirtyTwoBytesPaymentSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesPaymentSendFailureZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesPaymentSendFailureZ_err(e: crate::lightning::ln::outbound_payment::PaymentSendFailure) -> CResult_ThirtyTwoBytesPaymentSendFailureZ {
	CResult_ThirtyTwoBytesPaymentSendFailureZ {
		contents: CResult_ThirtyTwoBytesPaymentSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesPaymentSendFailureZ_is_ok(o: &CResult_ThirtyTwoBytesPaymentSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesPaymentSendFailureZ.
pub extern "C" fn CResult_ThirtyTwoBytesPaymentSendFailureZ_free(_res: CResult_ThirtyTwoBytesPaymentSendFailureZ) { }
impl Drop for CResult_ThirtyTwoBytesPaymentSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::PaymentSendFailure>> for CResult_ThirtyTwoBytesPaymentSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::PaymentSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesPaymentSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ThirtyTwoBytesPaymentSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesPaymentSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesPaymentSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesPaymentSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::PaymentSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesPaymentSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesPaymentSendFailureZ_clone(orig: &CResult_ThirtyTwoBytesPaymentSendFailureZ) -> CResult_ThirtyTwoBytesPaymentSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ThirtyTwoBytesRetryableSendFailureZ
pub union CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::ThirtyTwoBytes,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::RetryableSendFailure,
}
#[repr(C)]
/// A CResult_ThirtyTwoBytesRetryableSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::outbound_payment::RetryableSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ThirtyTwoBytesRetryableSendFailureZ {
	/// The contents of this CResult_ThirtyTwoBytesRetryableSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr,
	/// Whether this CResult_ThirtyTwoBytesRetryableSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ in the success state.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_ok(o: crate::c_types::ThirtyTwoBytes) -> CResult_ThirtyTwoBytesRetryableSendFailureZ {
	CResult_ThirtyTwoBytesRetryableSendFailureZ {
		contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ in the error state.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_err(e: crate::lightning::ln::outbound_payment::RetryableSendFailure) -> CResult_ThirtyTwoBytesRetryableSendFailureZ {
	CResult_ThirtyTwoBytesRetryableSendFailureZ {
		contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_is_ok(o: &CResult_ThirtyTwoBytesRetryableSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ThirtyTwoBytesRetryableSendFailureZ.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_free(_res: CResult_ThirtyTwoBytesRetryableSendFailureZ) { }
impl Drop for CResult_ThirtyTwoBytesRetryableSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RetryableSendFailure>> for CResult_ThirtyTwoBytesRetryableSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RetryableSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ThirtyTwoBytesRetryableSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ThirtyTwoBytesRetryableSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ThirtyTwoBytesRetryableSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::ThirtyTwoBytes>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ThirtyTwoBytesRetryableSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::RetryableSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ThirtyTwoBytesRetryableSendFailureZ_clone(orig: &CResult_ThirtyTwoBytesRetryableSendFailureZ) -> CResult_ThirtyTwoBytesRetryableSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoBytes,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::ThirtyTwoBytes)> for C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::ThirtyTwoBytes)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::ThirtyTwoBytes) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_clone(orig: &C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) -> C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::ThirtyTwoBytes) -> C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
	C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_free(_res: C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ
pub union CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::PaymentSendFailure,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ on success and a crate::lightning::ln::outbound_payment::PaymentSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_err(e: crate::lightning::ln::outbound_payment::PaymentSendFailure) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, crate::lightning::ln::outbound_payment::PaymentSendFailure>> for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, crate::lightning::ln::outbound_payment::PaymentSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::PaymentSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>> for CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ
pub union CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::outbound_payment::ProbeSendFailure,
}
#[repr(C)]
/// A CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ on success and a crate::lightning::ln::outbound_payment::ProbeSendFailure on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	/// The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr,
	/// Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ in the success state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_ok(o: crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ in the error state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_err(e: crate::lightning::ln::outbound_payment::ProbeSendFailure) -> CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_is_ok(o: &CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_free(_res: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ) { }
impl Drop for CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ, crate::lightning::ln::outbound_payment::ProbeSendFailure>> for CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ, crate::lightning::ln::outbound_payment::ProbeSendFailure>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::outbound_payment::ProbeSendFailure>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_clone(orig: &CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesPublicKeyZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::PublicKey,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::PublicKey)> for C2Tuple_ThirtyTwoBytesPublicKeyZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::PublicKey)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesPublicKeyZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::PublicKey) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesPublicKeyZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesPublicKeyZ_clone(orig: &C2Tuple_ThirtyTwoBytesPublicKeyZ) -> C2Tuple_ThirtyTwoBytesPublicKeyZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesPublicKeyZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesPublicKeyZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::PublicKey) -> C2Tuple_ThirtyTwoBytesPublicKeyZ {
	C2Tuple_ThirtyTwoBytesPublicKeyZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesPublicKeyZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesPublicKeyZ_free(_res: C2Tuple_ThirtyTwoBytesPublicKeyZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZ>> for CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::Str or not
pub enum COption_StrZ {
	/// When we're in this state, this COption_StrZ contains a crate::c_types::Str
	Some(crate::c_types::Str),
	/// When we're in this state, this COption_StrZ contains nothing
	None
}
impl COption_StrZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::Str {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_StrZ containing a crate::c_types::Str
pub extern "C" fn COption_StrZ_some(o: crate::c_types::Str) -> COption_StrZ {
	COption_StrZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_StrZ containing nothing
pub extern "C" fn COption_StrZ_none() -> COption_StrZ {
	COption_StrZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::Str, if we are in the Some state
pub extern "C" fn COption_StrZ_free(_res: COption_StrZ) { }
#[no_mangle]
/// Creates a new COption_StrZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_StrZ_clone(orig: &COption_StrZ) -> COption_StrZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneBolt12SemanticErrorZ
pub union CResult_NoneBolt12SemanticErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::offers::parse::Bolt12SemanticError,
}
#[repr(C)]
/// A CResult_NoneBolt12SemanticErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::offers::parse::Bolt12SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneBolt12SemanticErrorZ {
	/// The contents of this CResult_NoneBolt12SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneBolt12SemanticErrorZPtr,
	/// Whether this CResult_NoneBolt12SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12SemanticErrorZ in the success state.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_ok() -> CResult_NoneBolt12SemanticErrorZ {
	CResult_NoneBolt12SemanticErrorZ {
		contents: CResult_NoneBolt12SemanticErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12SemanticErrorZ in the error state.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_err(e: crate::lightning::offers::parse::Bolt12SemanticError) -> CResult_NoneBolt12SemanticErrorZ {
	CResult_NoneBolt12SemanticErrorZ {
		contents: CResult_NoneBolt12SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_is_ok(o: &CResult_NoneBolt12SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneBolt12SemanticErrorZ.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_free(_res: CResult_NoneBolt12SemanticErrorZ) { }
impl Drop for CResult_NoneBolt12SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::offers::parse::Bolt12SemanticError>> for CResult_NoneBolt12SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::offers::parse::Bolt12SemanticError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneBolt12SemanticErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneBolt12SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneBolt12SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneBolt12SemanticErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneBolt12SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::offers::parse::Bolt12SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt12SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneBolt12SemanticErrorZ_clone(orig: &CResult_NoneBolt12SemanticErrorZ) -> CResult_NoneBolt12SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ
pub union CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_err() -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, ()>> for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ) -> CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::onion_message::offers::OffersMessage or not
pub enum COption_OffersMessageZ {
	/// When we're in this state, this COption_OffersMessageZ contains a crate::lightning::onion_message::offers::OffersMessage
	Some(crate::lightning::onion_message::offers::OffersMessage),
	/// When we're in this state, this COption_OffersMessageZ contains nothing
	None
}
impl COption_OffersMessageZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::onion_message::offers::OffersMessage {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_OffersMessageZ containing a crate::lightning::onion_message::offers::OffersMessage
pub extern "C" fn COption_OffersMessageZ_some(o: crate::lightning::onion_message::offers::OffersMessage) -> COption_OffersMessageZ {
	COption_OffersMessageZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_OffersMessageZ containing nothing
pub extern "C" fn COption_OffersMessageZ_none() -> COption_OffersMessageZ {
	COption_OffersMessageZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::onion_message::offers::OffersMessage, if we are in the Some state
pub extern "C" fn COption_OffersMessageZ_free(_res: COption_OffersMessageZ) { }
#[no_mangle]
/// Creates a new COption_OffersMessageZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_OffersMessageZ_clone(orig: &COption_OffersMessageZ) -> COption_OffersMessageZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_OffersMessageDestinationBlindedPathZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::offers::OffersMessage,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::Destination,
	/// The element at position 2
	pub c: crate::lightning::blinded_path::BlindedPath,
}
impl From<(crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::Destination, crate::lightning::blinded_path::BlindedPath)> for C3Tuple_OffersMessageDestinationBlindedPathZ {
	fn from (tup: (crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::Destination, crate::lightning::blinded_path::BlindedPath)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_OffersMessageDestinationBlindedPathZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::offers::OffersMessage, crate::lightning::onion_message::messenger::Destination, crate::lightning::blinded_path::BlindedPath) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_OffersMessageDestinationBlindedPathZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_OffersMessageDestinationBlindedPathZ_clone(orig: &C3Tuple_OffersMessageDestinationBlindedPathZ) -> C3Tuple_OffersMessageDestinationBlindedPathZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_OffersMessageDestinationBlindedPathZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_OffersMessageDestinationBlindedPathZ_new(a: crate::lightning::onion_message::offers::OffersMessage, b: crate::lightning::onion_message::messenger::Destination, c: crate::lightning::blinded_path::BlindedPath) -> C3Tuple_OffersMessageDestinationBlindedPathZ {
	C3Tuple_OffersMessageDestinationBlindedPathZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_OffersMessageDestinationBlindedPathZ.
pub extern "C" fn C3Tuple_OffersMessageDestinationBlindedPathZ_free(_res: C3Tuple_OffersMessageDestinationBlindedPathZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_OffersMessageDestinationBlindedPathZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C3Tuple_OffersMessageDestinationBlindedPathZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C3Tuple_OffersMessageDestinationBlindedPathZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C3Tuple_OffersMessageDestinationBlindedPathZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C3Tuple_OffersMessageDestinationBlindedPathZ>> for CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ {
	fn from(v: Vec<crate::c_types::derived::C3Tuple_OffersMessageDestinationBlindedPathZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ_free(_res: CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ) { }
impl Drop for CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C3Tuple_OffersMessageDestinationBlindedPathZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CounterpartyForwardingInfoDecodeErrorZ
pub union CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::CounterpartyForwardingInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CounterpartyForwardingInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::CounterpartyForwardingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CounterpartyForwardingInfoDecodeErrorZ {
	/// The contents of this CResult_CounterpartyForwardingInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr,
	/// Whether this CResult_CounterpartyForwardingInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::CounterpartyForwardingInfo) -> CResult_CounterpartyForwardingInfoDecodeErrorZ {
	CResult_CounterpartyForwardingInfoDecodeErrorZ {
		contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CounterpartyForwardingInfoDecodeErrorZ {
	CResult_CounterpartyForwardingInfoDecodeErrorZ {
		contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(o: &CResult_CounterpartyForwardingInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CounterpartyForwardingInfoDecodeErrorZ.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_free(_res: CResult_CounterpartyForwardingInfoDecodeErrorZ) { }
impl Drop for CResult_CounterpartyForwardingInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::CounterpartyForwardingInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_CounterpartyForwardingInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::CounterpartyForwardingInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CounterpartyForwardingInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CounterpartyForwardingInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CounterpartyForwardingInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::CounterpartyForwardingInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CounterpartyForwardingInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(orig: &CResult_CounterpartyForwardingInfoDecodeErrorZ) -> CResult_CounterpartyForwardingInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelCounterpartyDecodeErrorZ
pub union CResult_ChannelCounterpartyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::ChannelCounterparty,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelCounterpartyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::ChannelCounterparty on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelCounterpartyDecodeErrorZ {
	/// The contents of this CResult_ChannelCounterpartyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelCounterpartyDecodeErrorZPtr,
	/// Whether this CResult_ChannelCounterpartyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::ChannelCounterparty) -> CResult_ChannelCounterpartyDecodeErrorZ {
	CResult_ChannelCounterpartyDecodeErrorZ {
		contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelCounterpartyDecodeErrorZ {
	CResult_ChannelCounterpartyDecodeErrorZ {
		contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_is_ok(o: &CResult_ChannelCounterpartyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelCounterpartyDecodeErrorZ.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_free(_res: CResult_ChannelCounterpartyDecodeErrorZ) { }
impl Drop for CResult_ChannelCounterpartyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::ChannelCounterparty, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelCounterpartyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::ChannelCounterparty, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelCounterpartyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelCounterpartyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelCounterpartyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::ChannelCounterparty>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelCounterpartyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelCounterpartyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelCounterpartyDecodeErrorZ_clone(orig: &CResult_ChannelCounterpartyDecodeErrorZ) -> CResult_ChannelCounterpartyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelDetailsDecodeErrorZ
pub union CResult_ChannelDetailsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::ChannelDetails,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelDetailsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::ChannelDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelDetailsDecodeErrorZ {
	/// The contents of this CResult_ChannelDetailsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelDetailsDecodeErrorZPtr,
	/// Whether this CResult_ChannelDetailsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelDetailsDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::ChannelDetails) -> CResult_ChannelDetailsDecodeErrorZ {
	CResult_ChannelDetailsDecodeErrorZ {
		contents: CResult_ChannelDetailsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDetailsDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelDetailsDecodeErrorZ {
	CResult_ChannelDetailsDecodeErrorZ {
		contents: CResult_ChannelDetailsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_is_ok(o: &CResult_ChannelDetailsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelDetailsDecodeErrorZ.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_free(_res: CResult_ChannelDetailsDecodeErrorZ) { }
impl Drop for CResult_ChannelDetailsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::ChannelDetails, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelDetailsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::ChannelDetails, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelDetailsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelDetailsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelDetailsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelDetailsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::ChannelDetails>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelDetailsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelDetailsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelDetailsDecodeErrorZ_clone(orig: &CResult_ChannelDetailsDecodeErrorZ) -> CResult_ChannelDetailsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PhantomRouteHintsDecodeErrorZ
pub union CResult_PhantomRouteHintsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PhantomRouteHints,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PhantomRouteHintsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PhantomRouteHints on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PhantomRouteHintsDecodeErrorZ {
	/// The contents of this CResult_PhantomRouteHintsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PhantomRouteHintsDecodeErrorZPtr,
	/// Whether this CResult_PhantomRouteHintsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the success state.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::PhantomRouteHints) -> CResult_PhantomRouteHintsDecodeErrorZ {
	CResult_PhantomRouteHintsDecodeErrorZ {
		contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the error state.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PhantomRouteHintsDecodeErrorZ {
	CResult_PhantomRouteHintsDecodeErrorZ {
		contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_is_ok(o: &CResult_PhantomRouteHintsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PhantomRouteHintsDecodeErrorZ.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_free(_res: CResult_PhantomRouteHintsDecodeErrorZ) { }
impl Drop for CResult_PhantomRouteHintsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PhantomRouteHints, crate::lightning::ln::msgs::DecodeError>> for CResult_PhantomRouteHintsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PhantomRouteHints, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PhantomRouteHintsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PhantomRouteHintsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PhantomRouteHintsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PhantomRouteHints>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PhantomRouteHintsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PhantomRouteHintsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PhantomRouteHintsDecodeErrorZ_clone(orig: &CResult_PhantomRouteHintsDecodeErrorZ) -> CResult_PhantomRouteHintsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedForwardDecodeErrorZ
pub union CResult_BlindedForwardDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::BlindedForward,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedForwardDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::BlindedForward on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedForwardDecodeErrorZ {
	/// The contents of this CResult_BlindedForwardDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedForwardDecodeErrorZPtr,
	/// Whether this CResult_BlindedForwardDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedForwardDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::BlindedForward) -> CResult_BlindedForwardDecodeErrorZ {
	CResult_BlindedForwardDecodeErrorZ {
		contents: CResult_BlindedForwardDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedForwardDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedForwardDecodeErrorZ {
	CResult_BlindedForwardDecodeErrorZ {
		contents: CResult_BlindedForwardDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_is_ok(o: &CResult_BlindedForwardDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedForwardDecodeErrorZ.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_free(_res: CResult_BlindedForwardDecodeErrorZ) { }
impl Drop for CResult_BlindedForwardDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedForward, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedForwardDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedForward, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedForwardDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedForwardDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedForwardDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedForwardDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::BlindedForward>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedForwardDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedForwardDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedForwardDecodeErrorZ_clone(orig: &CResult_BlindedForwardDecodeErrorZ) -> CResult_BlindedForwardDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PendingHTLCRoutingDecodeErrorZ
pub union CResult_PendingHTLCRoutingDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PendingHTLCRouting,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PendingHTLCRoutingDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PendingHTLCRouting on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PendingHTLCRoutingDecodeErrorZ {
	/// The contents of this CResult_PendingHTLCRoutingDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PendingHTLCRoutingDecodeErrorZPtr,
	/// Whether this CResult_PendingHTLCRoutingDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCRoutingDecodeErrorZ in the success state.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::PendingHTLCRouting) -> CResult_PendingHTLCRoutingDecodeErrorZ {
	CResult_PendingHTLCRoutingDecodeErrorZ {
		contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCRoutingDecodeErrorZ in the error state.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PendingHTLCRoutingDecodeErrorZ {
	CResult_PendingHTLCRoutingDecodeErrorZ {
		contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_is_ok(o: &CResult_PendingHTLCRoutingDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PendingHTLCRoutingDecodeErrorZ.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_free(_res: CResult_PendingHTLCRoutingDecodeErrorZ) { }
impl Drop for CResult_PendingHTLCRoutingDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCRouting, crate::lightning::ln::msgs::DecodeError>> for CResult_PendingHTLCRoutingDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCRouting, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PendingHTLCRoutingDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PendingHTLCRoutingDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PendingHTLCRoutingDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PendingHTLCRouting>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PendingHTLCRoutingDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCRoutingDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PendingHTLCRoutingDecodeErrorZ_clone(orig: &CResult_PendingHTLCRoutingDecodeErrorZ) -> CResult_PendingHTLCRoutingDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PendingHTLCInfoDecodeErrorZ
pub union CResult_PendingHTLCInfoDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::PendingHTLCInfo,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PendingHTLCInfoDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::PendingHTLCInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PendingHTLCInfoDecodeErrorZ {
	/// The contents of this CResult_PendingHTLCInfoDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PendingHTLCInfoDecodeErrorZPtr,
	/// Whether this CResult_PendingHTLCInfoDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoDecodeErrorZ in the success state.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::PendingHTLCInfo) -> CResult_PendingHTLCInfoDecodeErrorZ {
	CResult_PendingHTLCInfoDecodeErrorZ {
		contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoDecodeErrorZ in the error state.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PendingHTLCInfoDecodeErrorZ {
	CResult_PendingHTLCInfoDecodeErrorZ {
		contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_is_ok(o: &CResult_PendingHTLCInfoDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PendingHTLCInfoDecodeErrorZ.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_free(_res: CResult_PendingHTLCInfoDecodeErrorZ) { }
impl Drop for CResult_PendingHTLCInfoDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::msgs::DecodeError>> for CResult_PendingHTLCInfoDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::PendingHTLCInfo, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PendingHTLCInfoDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PendingHTLCInfoDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PendingHTLCInfoDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::PendingHTLCInfo>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PendingHTLCInfoDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PendingHTLCInfoDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PendingHTLCInfoDecodeErrorZ_clone(orig: &CResult_PendingHTLCInfoDecodeErrorZ) -> CResult_PendingHTLCInfoDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedFailureDecodeErrorZ
pub union CResult_BlindedFailureDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::BlindedFailure,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedFailureDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::BlindedFailure on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedFailureDecodeErrorZ {
	/// The contents of this CResult_BlindedFailureDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedFailureDecodeErrorZPtr,
	/// Whether this CResult_BlindedFailureDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedFailureDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::BlindedFailure) -> CResult_BlindedFailureDecodeErrorZ {
	CResult_BlindedFailureDecodeErrorZ {
		contents: CResult_BlindedFailureDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedFailureDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedFailureDecodeErrorZ {
	CResult_BlindedFailureDecodeErrorZ {
		contents: CResult_BlindedFailureDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_is_ok(o: &CResult_BlindedFailureDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedFailureDecodeErrorZ.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_free(_res: CResult_BlindedFailureDecodeErrorZ) { }
impl Drop for CResult_BlindedFailureDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedFailure, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedFailureDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::BlindedFailure, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedFailureDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedFailureDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedFailureDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedFailureDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::BlindedFailure>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedFailureDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedFailureDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedFailureDecodeErrorZ_clone(orig: &CResult_BlindedFailureDecodeErrorZ) -> CResult_BlindedFailureDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelShutdownStateDecodeErrorZ
pub union CResult_ChannelShutdownStateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channelmanager::ChannelShutdownState,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelShutdownStateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channelmanager::ChannelShutdownState on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelShutdownStateDecodeErrorZ {
	/// The contents of this CResult_ChannelShutdownStateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelShutdownStateDecodeErrorZPtr,
	/// Whether this CResult_ChannelShutdownStateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelShutdownStateDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_ok(o: crate::lightning::ln::channelmanager::ChannelShutdownState) -> CResult_ChannelShutdownStateDecodeErrorZ {
	CResult_ChannelShutdownStateDecodeErrorZ {
		contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelShutdownStateDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelShutdownStateDecodeErrorZ {
	CResult_ChannelShutdownStateDecodeErrorZ {
		contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_is_ok(o: &CResult_ChannelShutdownStateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelShutdownStateDecodeErrorZ.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_free(_res: CResult_ChannelShutdownStateDecodeErrorZ) { }
impl Drop for CResult_ChannelShutdownStateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::ChannelShutdownState, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelShutdownStateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channelmanager::ChannelShutdownState, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelShutdownStateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelShutdownStateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelShutdownStateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channelmanager::ChannelShutdownState>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelShutdownStateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelShutdownStateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelShutdownStateDecodeErrorZ_clone(orig: &CResult_ChannelShutdownStateDecodeErrorZ) -> CResult_ChannelShutdownStateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ChannelMonitorZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::channelmonitor::ChannelMonitor,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ChannelMonitorZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::channelmonitor::ChannelMonitor> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::channelmonitor::ChannelMonitor] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::channelmonitor::ChannelMonitor>> for CVec_ChannelMonitorZ {
	fn from(v: Vec<crate::lightning::chain::channelmonitor::ChannelMonitor>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ChannelMonitorZ_free(_res: CVec_ChannelMonitorZ) { }
impl Drop for CVec_ChannelMonitorZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ChannelMonitorZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesChannelManagerZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::lightning::ln::channelmanager::ChannelManager,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::lightning::ln::channelmanager::ChannelManager)> for C2Tuple_ThirtyTwoBytesChannelManagerZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::channelmanager::ChannelManager)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesChannelManagerZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::channelmanager::ChannelManager) {
		(self.a, self.b)
	}
}
/// Creates a new C2Tuple_ThirtyTwoBytesChannelManagerZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelManagerZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::lightning::ln::channelmanager::ChannelManager) -> C2Tuple_ThirtyTwoBytesChannelManagerZ {
	C2Tuple_ThirtyTwoBytesChannelManagerZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesChannelManagerZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelManagerZ_free(_res: C2Tuple_ThirtyTwoBytesChannelManagerZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ
pub union CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ, crate::lightning::ln::msgs::DecodeError>> for CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_MaxDustHTLCExposureDecodeErrorZ
pub union CResult_MaxDustHTLCExposureDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::config::MaxDustHTLCExposure,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_MaxDustHTLCExposureDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::config::MaxDustHTLCExposure on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_MaxDustHTLCExposureDecodeErrorZ {
	/// The contents of this CResult_MaxDustHTLCExposureDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr,
	/// Whether this CResult_MaxDustHTLCExposureDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ in the success state.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_ok(o: crate::lightning::util::config::MaxDustHTLCExposure) -> CResult_MaxDustHTLCExposureDecodeErrorZ {
	CResult_MaxDustHTLCExposureDecodeErrorZ {
		contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ in the error state.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_MaxDustHTLCExposureDecodeErrorZ {
	CResult_MaxDustHTLCExposureDecodeErrorZ {
		contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_is_ok(o: &CResult_MaxDustHTLCExposureDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_MaxDustHTLCExposureDecodeErrorZ.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_free(_res: CResult_MaxDustHTLCExposureDecodeErrorZ) { }
impl Drop for CResult_MaxDustHTLCExposureDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::config::MaxDustHTLCExposure, crate::lightning::ln::msgs::DecodeError>> for CResult_MaxDustHTLCExposureDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::config::MaxDustHTLCExposure, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_MaxDustHTLCExposureDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_MaxDustHTLCExposureDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_MaxDustHTLCExposureDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::config::MaxDustHTLCExposure>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_MaxDustHTLCExposureDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_MaxDustHTLCExposureDecodeErrorZ_clone(orig: &CResult_MaxDustHTLCExposureDecodeErrorZ) -> CResult_MaxDustHTLCExposureDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelConfigDecodeErrorZ
pub union CResult_ChannelConfigDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::config::ChannelConfig,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelConfigDecodeErrorZ {
	/// The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelConfigDecodeErrorZPtr,
	/// Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_ok(o: crate::lightning::util::config::ChannelConfig) -> CResult_ChannelConfigDecodeErrorZ {
	CResult_ChannelConfigDecodeErrorZ {
		contents: CResult_ChannelConfigDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelConfigDecodeErrorZ {
	CResult_ChannelConfigDecodeErrorZ {
		contents: CResult_ChannelConfigDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_is_ok(o: &CResult_ChannelConfigDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_free(_res: CResult_ChannelConfigDecodeErrorZ) { }
impl Drop for CResult_ChannelConfigDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::config::ChannelConfig, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelConfigDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::config::ChannelConfig, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelConfigDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelConfigDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelConfigDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelConfigDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::config::ChannelConfig>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelConfigDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelConfigDecodeErrorZ_clone(orig: &CResult_ChannelConfigDecodeErrorZ) -> CResult_ChannelConfigDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::util::config::MaxDustHTLCExposure or not
pub enum COption_MaxDustHTLCExposureZ {
	/// When we're in this state, this COption_MaxDustHTLCExposureZ contains a crate::lightning::util::config::MaxDustHTLCExposure
	Some(crate::lightning::util::config::MaxDustHTLCExposure),
	/// When we're in this state, this COption_MaxDustHTLCExposureZ contains nothing
	None
}
impl COption_MaxDustHTLCExposureZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::util::config::MaxDustHTLCExposure {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_MaxDustHTLCExposureZ containing a crate::lightning::util::config::MaxDustHTLCExposure
pub extern "C" fn COption_MaxDustHTLCExposureZ_some(o: crate::lightning::util::config::MaxDustHTLCExposure) -> COption_MaxDustHTLCExposureZ {
	COption_MaxDustHTLCExposureZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_MaxDustHTLCExposureZ containing nothing
pub extern "C" fn COption_MaxDustHTLCExposureZ_none() -> COption_MaxDustHTLCExposureZ {
	COption_MaxDustHTLCExposureZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::util::config::MaxDustHTLCExposure, if we are in the Some state
pub extern "C" fn COption_MaxDustHTLCExposureZ_free(_res: COption_MaxDustHTLCExposureZ) { }
#[no_mangle]
/// Creates a new COption_MaxDustHTLCExposureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_MaxDustHTLCExposureZ_clone(orig: &COption_MaxDustHTLCExposureZ) -> COption_MaxDustHTLCExposureZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::util::errors::APIError or not
pub enum COption_APIErrorZ {
	/// When we're in this state, this COption_APIErrorZ contains a crate::lightning::util::errors::APIError
	Some(crate::lightning::util::errors::APIError),
	/// When we're in this state, this COption_APIErrorZ contains nothing
	None
}
impl COption_APIErrorZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::util::errors::APIError {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_APIErrorZ containing a crate::lightning::util::errors::APIError
pub extern "C" fn COption_APIErrorZ_some(o: crate::lightning::util::errors::APIError) -> COption_APIErrorZ {
	COption_APIErrorZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_APIErrorZ containing nothing
pub extern "C" fn COption_APIErrorZ_none() -> COption_APIErrorZ {
	COption_APIErrorZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::util::errors::APIError, if we are in the Some state
pub extern "C" fn COption_APIErrorZ_free(_res: COption_APIErrorZ) { }
#[no_mangle]
/// Creates a new COption_APIErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_APIErrorZ_clone(orig: &COption_APIErrorZ) -> COption_APIErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_APIErrorZDecodeErrorZ
pub union CResult_COption_APIErrorZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_APIErrorZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_APIErrorZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_APIErrorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_APIErrorZDecodeErrorZ {
	/// The contents of this CResult_COption_APIErrorZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_APIErrorZDecodeErrorZPtr,
	/// Whether this CResult_COption_APIErrorZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_APIErrorZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_ok(o: crate::c_types::derived::COption_APIErrorZ) -> CResult_COption_APIErrorZDecodeErrorZ {
	CResult_COption_APIErrorZDecodeErrorZ {
		contents: CResult_COption_APIErrorZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_APIErrorZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_APIErrorZDecodeErrorZ {
	CResult_COption_APIErrorZDecodeErrorZ {
		contents: CResult_COption_APIErrorZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_is_ok(o: &CResult_COption_APIErrorZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_APIErrorZDecodeErrorZ.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_free(_res: CResult_COption_APIErrorZDecodeErrorZ) { }
impl Drop for CResult_COption_APIErrorZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_APIErrorZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_APIErrorZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_APIErrorZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_APIErrorZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_APIErrorZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_APIErrorZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_APIErrorZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_APIErrorZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_APIErrorZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_APIErrorZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_APIErrorZDecodeErrorZ_clone(orig: &CResult_COption_APIErrorZDecodeErrorZ) -> CResult_COption_APIErrorZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
pub union CResult_ChannelMonitorUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::channelmonitor::ChannelMonitorUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelMonitorUpdateDecodeErrorZ {
	/// The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr,
	/// Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o: crate::lightning::chain::channelmonitor::ChannelMonitorUpdate) -> CResult_ChannelMonitorUpdateDecodeErrorZ {
	CResult_ChannelMonitorUpdateDecodeErrorZ {
		contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelMonitorUpdateDecodeErrorZ {
	CResult_ChannelMonitorUpdateDecodeErrorZ {
		contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o: &CResult_ChannelMonitorUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res: CResult_ChannelMonitorUpdateDecodeErrorZ) { }
impl Drop for CResult_ChannelMonitorUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::ChannelMonitorUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelMonitorUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::ChannelMonitorUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelMonitorUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelMonitorUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelMonitorUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::channelmonitor::ChannelMonitorUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelMonitorUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig: &CResult_ChannelMonitorUpdateDecodeErrorZ) -> CResult_ChannelMonitorUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
pub enum COption_MonitorEventZ {
	/// When we're in this state, this COption_MonitorEventZ contains a crate::lightning::chain::channelmonitor::MonitorEvent
	Some(crate::lightning::chain::channelmonitor::MonitorEvent),
	/// When we're in this state, this COption_MonitorEventZ contains nothing
	None
}
impl COption_MonitorEventZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::chain::channelmonitor::MonitorEvent {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
pub extern "C" fn COption_MonitorEventZ_some(o: crate::lightning::chain::channelmonitor::MonitorEvent) -> COption_MonitorEventZ {
	COption_MonitorEventZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_MonitorEventZ containing nothing
pub extern "C" fn COption_MonitorEventZ_none() -> COption_MonitorEventZ {
	COption_MonitorEventZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::chain::channelmonitor::MonitorEvent, if we are in the Some state
pub extern "C" fn COption_MonitorEventZ_free(_res: COption_MonitorEventZ) { }
#[no_mangle]
/// Creates a new COption_MonitorEventZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_MonitorEventZ_clone(orig: &COption_MonitorEventZ) -> COption_MonitorEventZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_MonitorEventZDecodeErrorZ
pub union CResult_COption_MonitorEventZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_MonitorEventZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_MonitorEventZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_MonitorEventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_MonitorEventZDecodeErrorZ {
	/// The contents of this CResult_COption_MonitorEventZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_MonitorEventZDecodeErrorZPtr,
	/// Whether this CResult_COption_MonitorEventZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_ok(o: crate::c_types::derived::COption_MonitorEventZ) -> CResult_COption_MonitorEventZDecodeErrorZ {
	CResult_COption_MonitorEventZDecodeErrorZ {
		contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_MonitorEventZDecodeErrorZ {
	CResult_COption_MonitorEventZDecodeErrorZ {
		contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o: &CResult_COption_MonitorEventZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_MonitorEventZDecodeErrorZ.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_free(_res: CResult_COption_MonitorEventZDecodeErrorZ) { }
impl Drop for CResult_COption_MonitorEventZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_MonitorEventZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_MonitorEventZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_MonitorEventZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_MonitorEventZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_MonitorEventZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_MonitorEventZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_MonitorEventZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_MonitorEventZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_MonitorEventZDecodeErrorZ_clone(orig: &CResult_COption_MonitorEventZDecodeErrorZ) -> CResult_COption_MonitorEventZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HTLCUpdateDecodeErrorZ
pub union CResult_HTLCUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::channelmonitor::HTLCUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HTLCUpdateDecodeErrorZ {
	/// The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HTLCUpdateDecodeErrorZPtr,
	/// Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_ok(o: crate::lightning::chain::channelmonitor::HTLCUpdate) -> CResult_HTLCUpdateDecodeErrorZ {
	CResult_HTLCUpdateDecodeErrorZ {
		contents: CResult_HTLCUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HTLCUpdateDecodeErrorZ {
	CResult_HTLCUpdateDecodeErrorZ {
		contents: CResult_HTLCUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_is_ok(o: &CResult_HTLCUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_free(_res: CResult_HTLCUpdateDecodeErrorZ) { }
impl Drop for CResult_HTLCUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::HTLCUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_HTLCUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::channelmonitor::HTLCUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HTLCUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HTLCUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HTLCUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HTLCUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::channelmonitor::HTLCUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HTLCUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HTLCUpdateDecodeErrorZ_clone(orig: &CResult_HTLCUpdateDecodeErrorZ) -> CResult_HTLCUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OutPointCVec_u8ZZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u8Z,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u8Z)> for C2Tuple_OutPointCVec_u8ZZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u8Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OutPointCVec_u8ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_u8Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OutPointCVec_u8ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OutPointCVec_u8ZZ_clone(orig: &C2Tuple_OutPointCVec_u8ZZ) -> C2Tuple_OutPointCVec_u8ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OutPointCVec_u8ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OutPointCVec_u8ZZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::c_types::derived::CVec_u8Z) -> C2Tuple_OutPointCVec_u8ZZ {
	C2Tuple_OutPointCVec_u8ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OutPointCVec_u8ZZ.
pub extern "C" fn C2Tuple_OutPointCVec_u8ZZ_free(_res: C2Tuple_OutPointCVec_u8ZZ) { }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u32CVec_u8ZZ {
	/// The element at position 0
	pub a: u32,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_u8Z,
}
impl From<(u32, crate::c_types::derived::CVec_u8Z)> for C2Tuple_u32CVec_u8ZZ {
	fn from (tup: (u32, crate::c_types::derived::CVec_u8Z)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u32CVec_u8ZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u32, crate::c_types::derived::CVec_u8Z) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u32CVec_u8ZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u32CVec_u8ZZ_clone(orig: &C2Tuple_u32CVec_u8ZZ) -> C2Tuple_u32CVec_u8ZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_u32CVec_u8ZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u32CVec_u8ZZ_new(a: u32, b: crate::c_types::derived::CVec_u8Z) -> C2Tuple_u32CVec_u8ZZ {
	C2Tuple_u32CVec_u8ZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u32CVec_u8ZZ.
pub extern "C" fn C2Tuple_u32CVec_u8ZZ_free(_res: C2Tuple_u32CVec_u8ZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32CVec_u8ZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_u32CVec_u8ZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_u32CVec_u8ZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_u32CVec_u8ZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_u32CVec_u8ZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_u32CVec_u8ZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_u32CVec_u8ZZ>> for CVec_C2Tuple_u32CVec_u8ZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_u32CVec_u8ZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_u32CVec_u8ZZZ_free(_res: CVec_C2Tuple_u32CVec_u8ZZZ) { }
impl Drop for CVec_C2Tuple_u32CVec_u8ZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_u32CVec_u8ZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ)> for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_clone(orig: &C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::derived::CVec_C2Tuple_u32CVec_u8ZZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
	C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_free(_res: C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ>> for CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::chan_utils::CommitmentTransactions of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_CommitmentTransactionZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::chan_utils::CommitmentTransaction,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_CommitmentTransactionZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::chan_utils::CommitmentTransaction> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::chan_utils::CommitmentTransaction] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::chan_utils::CommitmentTransaction>> for CVec_CommitmentTransactionZ {
	fn from(v: Vec<crate::lightning::ln::chan_utils::CommitmentTransaction>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_CommitmentTransactionZ_free(_res: CVec_CommitmentTransactionZ) { }
impl Drop for CVec_CommitmentTransactionZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_CommitmentTransactionZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TransactionZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::Transaction,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TransactionZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::Transaction> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::Transaction] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::Transaction>> for CVec_TransactionZ {
	fn from(v: Vec<crate::c_types::Transaction>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TransactionZ_free(_res: CVec_TransactionZ) { }
impl Drop for CVec_TransactionZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TransactionZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_u32TxOutZ {
	/// The element at position 0
	pub a: u32,
	/// The element at position 1
	pub b: crate::c_types::TxOut,
}
impl From<(u32, crate::c_types::TxOut)> for C2Tuple_u32TxOutZ {
	fn from (tup: (u32, crate::c_types::TxOut)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_u32TxOutZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (u32, crate::c_types::TxOut) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_u32TxOutZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_u32TxOutZ_clone(orig: &C2Tuple_u32TxOutZ) -> C2Tuple_u32TxOutZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_u32TxOutZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_u32TxOutZ_new(a: u32, b: crate::c_types::TxOut) -> C2Tuple_u32TxOutZ {
	C2Tuple_u32TxOutZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_u32TxOutZ.
pub extern "C" fn C2Tuple_u32TxOutZ_free(_res: C2Tuple_u32TxOutZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_u32TxOutZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_u32TxOutZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_u32TxOutZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_u32TxOutZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_u32TxOutZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_u32TxOutZ>> for CVec_C2Tuple_u32TxOutZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_u32TxOutZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_u32TxOutZZ_free(_res: CVec_C2Tuple_u32TxOutZZ) { }
impl Drop for CVec_C2Tuple_u32TxOutZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_u32TxOutZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ)> for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_clone(orig: &C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::c_types::derived::CVec_C2Tuple_u32TxOutZZ) -> C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
	C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_free(_res: C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_TransactionOutputsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_TransactionOutputsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ>> for CVec_TransactionOutputsZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_TransactionOutputsZ_free(_res: CVec_TransactionOutputsZ) { }
impl Drop for CVec_TransactionOutputsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_TransactionOutputsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::channelmonitor::Balances of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_BalanceZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::channelmonitor::Balance,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_BalanceZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::channelmonitor::Balance> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::channelmonitor::Balance] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::channelmonitor::Balance>> for CVec_BalanceZ {
	fn from(v: Vec<crate::lightning::chain::channelmonitor::Balance>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_BalanceZ_free(_res: CVec_BalanceZ) { }
impl Drop for CVec_BalanceZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_BalanceZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::lightning::chain::channelmonitor::ChannelMonitor,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::lightning::chain::channelmonitor::ChannelMonitor)> for C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::lightning::chain::channelmonitor::ChannelMonitor)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::lightning::chain::channelmonitor::ChannelMonitor) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_clone(orig: &C2Tuple_ThirtyTwoBytesChannelMonitorZ) -> C2Tuple_ThirtyTwoBytesChannelMonitorZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_ThirtyTwoBytesChannelMonitorZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::lightning::chain::channelmonitor::ChannelMonitor) -> C2Tuple_ThirtyTwoBytesChannelMonitorZ {
	C2Tuple_ThirtyTwoBytesChannelMonitorZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_ThirtyTwoBytesChannelMonitorZ.
pub extern "C" fn C2Tuple_ThirtyTwoBytesChannelMonitorZ_free(_res: C2Tuple_ThirtyTwoBytesChannelMonitorZ) { }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ
pub union CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::lightning::ln::msgs::DecodeError>> for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_PublicKeyTypeZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::lightning::ln::wire::Type,
}
impl From<(crate::c_types::PublicKey, crate::lightning::ln::wire::Type)> for C2Tuple_PublicKeyTypeZ {
	fn from (tup: (crate::c_types::PublicKey, crate::lightning::ln::wire::Type)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_PublicKeyTypeZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::lightning::ln::wire::Type) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_PublicKeyTypeZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_PublicKeyTypeZ_clone(orig: &C2Tuple_PublicKeyTypeZ) -> C2Tuple_PublicKeyTypeZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_PublicKeyTypeZ_new(a: crate::c_types::PublicKey, b: crate::lightning::ln::wire::Type) -> C2Tuple_PublicKeyTypeZ {
	C2Tuple_PublicKeyTypeZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_PublicKeyTypeZ.
pub extern "C" fn C2Tuple_PublicKeyTypeZ_free(_res: C2Tuple_PublicKeyTypeZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyTypeZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_PublicKeyTypeZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_PublicKeyTypeZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_PublicKeyTypeZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_PublicKeyTypeZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_PublicKeyTypeZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_PublicKeyTypeZ>> for CVec_C2Tuple_PublicKeyTypeZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_PublicKeyTypeZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_PublicKeyTypeZZ_free(_res: CVec_C2Tuple_PublicKeyTypeZZ) { }
impl Drop for CVec_C2Tuple_PublicKeyTypeZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_PublicKeyTypeZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_PublicKeyCVec_SocketAddressZZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_SocketAddressZ,
}
impl From<(crate::c_types::PublicKey, crate::c_types::derived::CVec_SocketAddressZ)> for C2Tuple_PublicKeyCVec_SocketAddressZZ {
	fn from (tup: (crate::c_types::PublicKey, crate::c_types::derived::CVec_SocketAddressZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_PublicKeyCVec_SocketAddressZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::c_types::derived::CVec_SocketAddressZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_PublicKeyCVec_SocketAddressZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_PublicKeyCVec_SocketAddressZZ_clone(orig: &C2Tuple_PublicKeyCVec_SocketAddressZZ) -> C2Tuple_PublicKeyCVec_SocketAddressZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_PublicKeyCVec_SocketAddressZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_PublicKeyCVec_SocketAddressZZ_new(a: crate::c_types::PublicKey, b: crate::c_types::derived::CVec_SocketAddressZ) -> C2Tuple_PublicKeyCVec_SocketAddressZZ {
	C2Tuple_PublicKeyCVec_SocketAddressZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_PublicKeyCVec_SocketAddressZZ.
pub extern "C" fn C2Tuple_PublicKeyCVec_SocketAddressZZ_free(_res: C2Tuple_PublicKeyCVec_SocketAddressZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyCVec_SocketAddressZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_PublicKeyCVec_SocketAddressZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_PublicKeyCVec_SocketAddressZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_PublicKeyCVec_SocketAddressZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_PublicKeyCVec_SocketAddressZZ>> for CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_PublicKeyCVec_SocketAddressZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ_free(_res: CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ) { }
impl Drop for CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_PublicKeyCVec_SocketAddressZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::onion_message::packet::OnionMessageContents or not
pub enum COption_OnionMessageContentsZ {
	/// When we're in this state, this COption_OnionMessageContentsZ contains a crate::lightning::onion_message::packet::OnionMessageContents
	Some(crate::lightning::onion_message::packet::OnionMessageContents),
	/// When we're in this state, this COption_OnionMessageContentsZ contains nothing
	None
}
impl COption_OnionMessageContentsZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::onion_message::packet::OnionMessageContents {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_OnionMessageContentsZ containing a crate::lightning::onion_message::packet::OnionMessageContents
pub extern "C" fn COption_OnionMessageContentsZ_some(o: crate::lightning::onion_message::packet::OnionMessageContents) -> COption_OnionMessageContentsZ {
	COption_OnionMessageContentsZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_OnionMessageContentsZ containing nothing
pub extern "C" fn COption_OnionMessageContentsZ_none() -> COption_OnionMessageContentsZ {
	COption_OnionMessageContentsZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::onion_message::packet::OnionMessageContents, if we are in the Some state
pub extern "C" fn COption_OnionMessageContentsZ_free(_res: COption_OnionMessageContentsZ) { }
#[no_mangle]
/// Creates a new COption_OnionMessageContentsZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_OnionMessageContentsZ_clone(orig: &COption_OnionMessageContentsZ) -> COption_OnionMessageContentsZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_OnionMessageContentsZDecodeErrorZ
pub union CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_OnionMessageContentsZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_OnionMessageContentsZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_OnionMessageContentsZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_OnionMessageContentsZDecodeErrorZ {
	/// The contents of this CResult_COption_OnionMessageContentsZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr,
	/// Whether this CResult_COption_OnionMessageContentsZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_OnionMessageContentsZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_ok(o: crate::c_types::derived::COption_OnionMessageContentsZ) -> CResult_COption_OnionMessageContentsZDecodeErrorZ {
	CResult_COption_OnionMessageContentsZDecodeErrorZ {
		contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_OnionMessageContentsZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_OnionMessageContentsZDecodeErrorZ {
	CResult_COption_OnionMessageContentsZDecodeErrorZ {
		contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_is_ok(o: &CResult_COption_OnionMessageContentsZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_OnionMessageContentsZDecodeErrorZ.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_free(_res: CResult_COption_OnionMessageContentsZDecodeErrorZ) { }
impl Drop for CResult_COption_OnionMessageContentsZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_OnionMessageContentsZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_OnionMessageContentsZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_OnionMessageContentsZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_OnionMessageContentsZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_OnionMessageContentsZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_OnionMessageContentsZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_OnionMessageContentsZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_OnionMessageContentsZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_OnionMessageContentsZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_OnionMessageContentsZDecodeErrorZ_clone(orig: &CResult_COption_OnionMessageContentsZDecodeErrorZ) -> CResult_COption_OnionMessageContentsZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_OnionMessageContentsDestinationBlindedPathZ {
	/// The element at position 0
	pub a: crate::lightning::onion_message::packet::OnionMessageContents,
	/// The element at position 1
	pub b: crate::lightning::onion_message::messenger::Destination,
	/// The element at position 2
	pub c: crate::lightning::blinded_path::BlindedPath,
}
impl From<(crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::Destination, crate::lightning::blinded_path::BlindedPath)> for C3Tuple_OnionMessageContentsDestinationBlindedPathZ {
	fn from (tup: (crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::Destination, crate::lightning::blinded_path::BlindedPath)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_OnionMessageContentsDestinationBlindedPathZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::onion_message::packet::OnionMessageContents, crate::lightning::onion_message::messenger::Destination, crate::lightning::blinded_path::BlindedPath) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_OnionMessageContentsDestinationBlindedPathZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_OnionMessageContentsDestinationBlindedPathZ_clone(orig: &C3Tuple_OnionMessageContentsDestinationBlindedPathZ) -> C3Tuple_OnionMessageContentsDestinationBlindedPathZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_OnionMessageContentsDestinationBlindedPathZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_OnionMessageContentsDestinationBlindedPathZ_new(a: crate::lightning::onion_message::packet::OnionMessageContents, b: crate::lightning::onion_message::messenger::Destination, c: crate::lightning::blinded_path::BlindedPath) -> C3Tuple_OnionMessageContentsDestinationBlindedPathZ {
	C3Tuple_OnionMessageContentsDestinationBlindedPathZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_OnionMessageContentsDestinationBlindedPathZ.
pub extern "C" fn C3Tuple_OnionMessageContentsDestinationBlindedPathZ_free(_res: C3Tuple_OnionMessageContentsDestinationBlindedPathZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C3Tuple_OnionMessageContentsDestinationBlindedPathZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C3Tuple_OnionMessageContentsDestinationBlindedPathZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C3Tuple_OnionMessageContentsDestinationBlindedPathZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C3Tuple_OnionMessageContentsDestinationBlindedPathZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C3Tuple_OnionMessageContentsDestinationBlindedPathZ>> for CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ {
	fn from(v: Vec<crate::c_types::derived::C3Tuple_OnionMessageContentsDestinationBlindedPathZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ_free(_res: CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ) { }
impl Drop for CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C3Tuple_OnionMessageContentsDestinationBlindedPathZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::wire::Type or not
pub enum COption_TypeZ {
	/// When we're in this state, this COption_TypeZ contains a crate::lightning::ln::wire::Type
	Some(crate::lightning::ln::wire::Type),
	/// When we're in this state, this COption_TypeZ contains nothing
	None
}
impl COption_TypeZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::wire::Type {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
pub extern "C" fn COption_TypeZ_some(o: crate::lightning::ln::wire::Type) -> COption_TypeZ {
	COption_TypeZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_TypeZ containing nothing
pub extern "C" fn COption_TypeZ_none() -> COption_TypeZ {
	COption_TypeZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::wire::Type, if we are in the Some state
pub extern "C" fn COption_TypeZ_free(_res: COption_TypeZ) { }
#[no_mangle]
/// Creates a new COption_TypeZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_TypeZ_clone(orig: &COption_TypeZ) -> COption_TypeZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_TypeZDecodeErrorZ
pub union CResult_COption_TypeZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_TypeZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_TypeZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_TypeZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_TypeZDecodeErrorZ {
	/// The contents of this CResult_COption_TypeZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_TypeZDecodeErrorZPtr,
	/// Whether this CResult_COption_TypeZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_ok(o: crate::c_types::derived::COption_TypeZ) -> CResult_COption_TypeZDecodeErrorZ {
	CResult_COption_TypeZDecodeErrorZ {
		contents: CResult_COption_TypeZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_TypeZDecodeErrorZ {
	CResult_COption_TypeZDecodeErrorZ {
		contents: CResult_COption_TypeZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_is_ok(o: &CResult_COption_TypeZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_TypeZDecodeErrorZ.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_free(_res: CResult_COption_TypeZDecodeErrorZ) { }
impl Drop for CResult_COption_TypeZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_TypeZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_TypeZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_TypeZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_TypeZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_TypeZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_TypeZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_TypeZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_TypeZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_TypeZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_TypeZDecodeErrorZ_clone(orig: &CResult_COption_TypeZDecodeErrorZ) -> CResult_COption_TypeZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::ln::msgs::SocketAddress or not
pub enum COption_SocketAddressZ {
	/// When we're in this state, this COption_SocketAddressZ contains a crate::lightning::ln::msgs::SocketAddress
	Some(crate::lightning::ln::msgs::SocketAddress),
	/// When we're in this state, this COption_SocketAddressZ contains nothing
	None
}
impl COption_SocketAddressZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::msgs::SocketAddress {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_SocketAddressZ containing a crate::lightning::ln::msgs::SocketAddress
pub extern "C" fn COption_SocketAddressZ_some(o: crate::lightning::ln::msgs::SocketAddress) -> COption_SocketAddressZ {
	COption_SocketAddressZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_SocketAddressZ containing nothing
pub extern "C" fn COption_SocketAddressZ_none() -> COption_SocketAddressZ {
	COption_SocketAddressZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::msgs::SocketAddress, if we are in the Some state
pub extern "C" fn COption_SocketAddressZ_free(_res: COption_SocketAddressZ) { }
#[no_mangle]
/// Creates a new COption_SocketAddressZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_SocketAddressZ_clone(orig: &COption_SocketAddressZ) -> COption_SocketAddressZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_PublicKeyCOption_SocketAddressZZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::c_types::derived::COption_SocketAddressZ,
}
impl From<(crate::c_types::PublicKey, crate::c_types::derived::COption_SocketAddressZ)> for C2Tuple_PublicKeyCOption_SocketAddressZZ {
	fn from (tup: (crate::c_types::PublicKey, crate::c_types::derived::COption_SocketAddressZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_PublicKeyCOption_SocketAddressZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::c_types::derived::COption_SocketAddressZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_PublicKeyCOption_SocketAddressZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_PublicKeyCOption_SocketAddressZZ_clone(orig: &C2Tuple_PublicKeyCOption_SocketAddressZZ) -> C2Tuple_PublicKeyCOption_SocketAddressZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_PublicKeyCOption_SocketAddressZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_PublicKeyCOption_SocketAddressZZ_new(a: crate::c_types::PublicKey, b: crate::c_types::derived::COption_SocketAddressZ) -> C2Tuple_PublicKeyCOption_SocketAddressZZ {
	C2Tuple_PublicKeyCOption_SocketAddressZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_PublicKeyCOption_SocketAddressZZ.
pub extern "C" fn C2Tuple_PublicKeyCOption_SocketAddressZZ_free(_res: C2Tuple_PublicKeyCOption_SocketAddressZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZ>> for CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ_free(_res: CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ) { }
impl Drop for CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_u8ZPeerHandleErrorZ
pub union CResult_CVec_u8ZPeerHandleErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_u8Z,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::peer_handler::PeerHandleError,
}
#[repr(C)]
/// A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_u8ZPeerHandleErrorZ {
	/// The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_u8ZPeerHandleErrorZPtr,
	/// Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_ok(o: crate::c_types::derived::CVec_u8Z) -> CResult_CVec_u8ZPeerHandleErrorZ {
	CResult_CVec_u8ZPeerHandleErrorZ {
		contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_err(e: crate::lightning::ln::peer_handler::PeerHandleError) -> CResult_CVec_u8ZPeerHandleErrorZ {
	CResult_CVec_u8ZPeerHandleErrorZ {
		contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o: &CResult_CVec_u8ZPeerHandleErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_free(_res: CResult_CVec_u8ZPeerHandleErrorZ) { }
impl Drop for CResult_CVec_u8ZPeerHandleErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::lightning::ln::peer_handler::PeerHandleError>> for CResult_CVec_u8ZPeerHandleErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::lightning::ln::peer_handler::PeerHandleError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_u8ZPeerHandleErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_u8ZPeerHandleErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_u8ZPeerHandleErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_u8Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_u8ZPeerHandleErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::peer_handler::PeerHandleError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_u8ZPeerHandleErrorZ_clone(orig: &CResult_CVec_u8ZPeerHandleErrorZ) -> CResult_CVec_u8ZPeerHandleErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NonePeerHandleErrorZ
pub union CResult_NonePeerHandleErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::peer_handler::PeerHandleError,
}
#[repr(C)]
/// A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NonePeerHandleErrorZ {
	/// The contents of this CResult_NonePeerHandleErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NonePeerHandleErrorZPtr,
	/// Whether this CResult_NonePeerHandleErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NonePeerHandleErrorZ in the success state.
pub extern "C" fn CResult_NonePeerHandleErrorZ_ok() -> CResult_NonePeerHandleErrorZ {
	CResult_NonePeerHandleErrorZ {
		contents: CResult_NonePeerHandleErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NonePeerHandleErrorZ in the error state.
pub extern "C" fn CResult_NonePeerHandleErrorZ_err(e: crate::lightning::ln::peer_handler::PeerHandleError) -> CResult_NonePeerHandleErrorZ {
	CResult_NonePeerHandleErrorZ {
		contents: CResult_NonePeerHandleErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NonePeerHandleErrorZ_is_ok(o: &CResult_NonePeerHandleErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NonePeerHandleErrorZ.
pub extern "C" fn CResult_NonePeerHandleErrorZ_free(_res: CResult_NonePeerHandleErrorZ) { }
impl Drop for CResult_NonePeerHandleErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning::ln::peer_handler::PeerHandleError>> for CResult_NonePeerHandleErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning::ln::peer_handler::PeerHandleError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NonePeerHandleErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NonePeerHandleErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NonePeerHandleErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NonePeerHandleErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NonePeerHandleErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::peer_handler::PeerHandleError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NonePeerHandleErrorZ_clone(orig: &CResult_NonePeerHandleErrorZ) -> CResult_NonePeerHandleErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_boolPeerHandleErrorZ
pub union CResult_boolPeerHandleErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut bool,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::peer_handler::PeerHandleError,
}
#[repr(C)]
/// A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
/// containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_boolPeerHandleErrorZ {
	/// The contents of this CResult_boolPeerHandleErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_boolPeerHandleErrorZPtr,
	/// Whether this CResult_boolPeerHandleErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_boolPeerHandleErrorZ in the success state.
pub extern "C" fn CResult_boolPeerHandleErrorZ_ok(o: bool) -> CResult_boolPeerHandleErrorZ {
	CResult_boolPeerHandleErrorZ {
		contents: CResult_boolPeerHandleErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_boolPeerHandleErrorZ in the error state.
pub extern "C" fn CResult_boolPeerHandleErrorZ_err(e: crate::lightning::ln::peer_handler::PeerHandleError) -> CResult_boolPeerHandleErrorZ {
	CResult_boolPeerHandleErrorZ {
		contents: CResult_boolPeerHandleErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_boolPeerHandleErrorZ_is_ok(o: &CResult_boolPeerHandleErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_boolPeerHandleErrorZ.
pub extern "C" fn CResult_boolPeerHandleErrorZ_free(_res: CResult_boolPeerHandleErrorZ) { }
impl Drop for CResult_boolPeerHandleErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<bool, crate::lightning::ln::peer_handler::PeerHandleError>> for CResult_boolPeerHandleErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<bool, crate::lightning::ln::peer_handler::PeerHandleError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_boolPeerHandleErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_boolPeerHandleErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_boolPeerHandleErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_boolPeerHandleErrorZPtr {
				result: Box::into_raw(Box::new(<bool>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_boolPeerHandleErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::peer_handler::PeerHandleError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_boolPeerHandleErrorZ_clone(orig: &CResult_boolPeerHandleErrorZ) -> CResult_boolPeerHandleErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_u32GraphSyncErrorZ
pub union CResult_u32GraphSyncErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut u32,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_rapid_gossip_sync::GraphSyncError,
}
#[repr(C)]
/// A CResult_u32GraphSyncErrorZ represents the result of a fallible operation,
/// containing a u32 on success and a crate::lightning_rapid_gossip_sync::GraphSyncError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_u32GraphSyncErrorZ {
	/// The contents of this CResult_u32GraphSyncErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_u32GraphSyncErrorZPtr,
	/// Whether this CResult_u32GraphSyncErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_u32GraphSyncErrorZ in the success state.
pub extern "C" fn CResult_u32GraphSyncErrorZ_ok(o: u32) -> CResult_u32GraphSyncErrorZ {
	CResult_u32GraphSyncErrorZ {
		contents: CResult_u32GraphSyncErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_u32GraphSyncErrorZ in the error state.
pub extern "C" fn CResult_u32GraphSyncErrorZ_err(e: crate::lightning_rapid_gossip_sync::GraphSyncError) -> CResult_u32GraphSyncErrorZ {
	CResult_u32GraphSyncErrorZ {
		contents: CResult_u32GraphSyncErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_u32GraphSyncErrorZ_is_ok(o: &CResult_u32GraphSyncErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_u32GraphSyncErrorZ.
pub extern "C" fn CResult_u32GraphSyncErrorZ_free(_res: CResult_u32GraphSyncErrorZ) { }
impl Drop for CResult_u32GraphSyncErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<u32, crate::lightning_rapid_gossip_sync::GraphSyncError>> for CResult_u32GraphSyncErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<u32, crate::lightning_rapid_gossip_sync::GraphSyncError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_u32GraphSyncErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_u32GraphSyncErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_CVec_u8ZIOErrorZ
pub union CResult_CVec_u8ZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_u8Z,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_u8ZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_u8Z on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_u8ZIOErrorZ {
	/// The contents of this CResult_CVec_u8ZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_u8ZIOErrorZPtr,
	/// Whether this CResult_CVec_u8ZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_ok(o: crate::c_types::derived::CVec_u8Z) -> CResult_CVec_u8ZIOErrorZ {
	CResult_CVec_u8ZIOErrorZ {
		contents: CResult_CVec_u8ZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_u8ZIOErrorZ {
	CResult_CVec_u8ZIOErrorZ {
		contents: CResult_CVec_u8ZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_is_ok(o: &CResult_CVec_u8ZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_u8ZIOErrorZ.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_free(_res: CResult_CVec_u8ZIOErrorZ) { }
impl Drop for CResult_CVec_u8ZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::c_types::IOError>> for CResult_CVec_u8ZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_u8Z, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_u8ZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_u8ZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_u8ZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_u8ZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_u8Z>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_u8ZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_u8ZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_u8ZIOErrorZ_clone(orig: &CResult_CVec_u8ZIOErrorZ) -> CResult_CVec_u8ZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::Strs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_StrZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::Str,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_StrZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::Str> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::Str] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::Str>> for CVec_StrZ {
	fn from(v: Vec<crate::c_types::Str>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_StrZ_free(_res: CVec_StrZ) { }
impl Drop for CVec_StrZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_StrZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_StrZIOErrorZ
pub union CResult_CVec_StrZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_StrZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_StrZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_StrZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_StrZIOErrorZ {
	/// The contents of this CResult_CVec_StrZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_StrZIOErrorZPtr,
	/// Whether this CResult_CVec_StrZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_StrZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_ok(o: crate::c_types::derived::CVec_StrZ) -> CResult_CVec_StrZIOErrorZ {
	CResult_CVec_StrZIOErrorZ {
		contents: CResult_CVec_StrZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_StrZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_StrZIOErrorZ {
	CResult_CVec_StrZIOErrorZ {
		contents: CResult_CVec_StrZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_StrZIOErrorZ_is_ok(o: &CResult_CVec_StrZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_StrZIOErrorZ.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_free(_res: CResult_CVec_StrZIOErrorZ) { }
impl Drop for CResult_CVec_StrZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_StrZ, crate::c_types::IOError>> for CResult_CVec_StrZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_StrZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_StrZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_StrZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_StrZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_StrZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_StrZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_StrZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_StrZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_StrZIOErrorZ_clone(orig: &CResult_CVec_StrZIOErrorZ) -> CResult_CVec_StrZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>> for CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ_free(_res: CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ) { }
impl Drop for CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ
pub union CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	/// The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr,
	/// Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ in the success state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_ok(o: crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ in the error state.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
		contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_is_ok(o: &CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_free(_res: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ) { }
impl Drop for CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ, crate::c_types::IOError>> for CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_clone(orig: &CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ) -> CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ
pub union CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::IOError,
}
#[repr(C)]
/// A CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ on success and a crate::c_types::IOError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	/// The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr,
	/// Whether this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ in the success state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_ok(o: crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ in the error state.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_err(e: crate::c_types::IOError) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
		contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_is_ok(o: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_free(_res: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ) { }
impl Drop for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::c_types::IOError>> for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ, crate::c_types::IOError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::IOError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_clone(orig: &CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ) -> CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::SecretKey or not
pub enum COption_SecretKeyZ {
	/// When we're in this state, this COption_SecretKeyZ contains a crate::c_types::SecretKey
	Some(crate::c_types::SecretKey),
	/// When we're in this state, this COption_SecretKeyZ contains nothing
	None
}
impl COption_SecretKeyZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::SecretKey {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_SecretKeyZ containing a crate::c_types::SecretKey
pub extern "C" fn COption_SecretKeyZ_some(o: crate::c_types::SecretKey) -> COption_SecretKeyZ {
	COption_SecretKeyZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_SecretKeyZ containing nothing
pub extern "C" fn COption_SecretKeyZ_none() -> COption_SecretKeyZ {
	COption_SecretKeyZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::SecretKey, if we are in the Some state
pub extern "C" fn COption_SecretKeyZ_free(_res: COption_SecretKeyZ) { }
#[no_mangle]
/// Creates a new COption_SecretKeyZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_SecretKeyZ_clone(orig: &COption_SecretKeyZ) -> COption_SecretKeyZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_VerifiedInvoiceRequestNoneZ
pub union CResult_VerifiedInvoiceRequestNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_request::VerifiedInvoiceRequest,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_VerifiedInvoiceRequestNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_request::VerifiedInvoiceRequest on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_VerifiedInvoiceRequestNoneZ {
	/// The contents of this CResult_VerifiedInvoiceRequestNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_VerifiedInvoiceRequestNoneZPtr,
	/// Whether this CResult_VerifiedInvoiceRequestNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_VerifiedInvoiceRequestNoneZ in the success state.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_ok(o: crate::lightning::offers::invoice_request::VerifiedInvoiceRequest) -> CResult_VerifiedInvoiceRequestNoneZ {
	CResult_VerifiedInvoiceRequestNoneZ {
		contents: CResult_VerifiedInvoiceRequestNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_VerifiedInvoiceRequestNoneZ in the error state.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_err() -> CResult_VerifiedInvoiceRequestNoneZ {
	CResult_VerifiedInvoiceRequestNoneZ {
		contents: CResult_VerifiedInvoiceRequestNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_is_ok(o: &CResult_VerifiedInvoiceRequestNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_VerifiedInvoiceRequestNoneZ.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_free(_res: CResult_VerifiedInvoiceRequestNoneZ) { }
impl Drop for CResult_VerifiedInvoiceRequestNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::VerifiedInvoiceRequest, ()>> for CResult_VerifiedInvoiceRequestNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_request::VerifiedInvoiceRequest, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_VerifiedInvoiceRequestNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_VerifiedInvoiceRequestNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_VerifiedInvoiceRequestNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_VerifiedInvoiceRequestNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_request::VerifiedInvoiceRequest>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_VerifiedInvoiceRequestNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_VerifiedInvoiceRequestNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_VerifiedInvoiceRequestNoneZ_clone(orig: &CResult_VerifiedInvoiceRequestNoneZ) -> CResult_VerifiedInvoiceRequestNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a  or not
pub enum COption_NoneZ {
	/// When we're in this state, this COption_NoneZ contains a 
	Some,
	/// When we're in this state, this COption_NoneZ contains nothing
	None
}
impl COption_NoneZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
}
#[no_mangle]
/// Constructs a new COption_NoneZ containing a 
pub extern "C" fn COption_NoneZ_some() -> COption_NoneZ {
	COption_NoneZ::Some
}
#[no_mangle]
/// Constructs a new COption_NoneZ containing nothing
pub extern "C" fn COption_NoneZ_none() -> COption_NoneZ {
	COption_NoneZ::None
}
#[no_mangle]
/// Frees any resources associated with the , if we are in the Some state
pub extern "C" fn COption_NoneZ_free(_res: COption_NoneZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::Witnesss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_WitnessZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::Witness,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_WitnessZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::Witness> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::Witness] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::Witness>> for CVec_WitnessZ {
	fn from(v: Vec<crate::c_types::Witness>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_WitnessZ_free(_res: CVec_WitnessZ) { }
impl Drop for CVec_WitnessZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_WitnessZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a i64 or not
pub enum COption_i64Z {
	/// When we're in this state, this COption_i64Z contains a i64
	Some(i64),
	/// When we're in this state, this COption_i64Z contains nothing
	None
}
impl COption_i64Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> i64 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_i64Z containing a i64
pub extern "C" fn COption_i64Z_some(o: i64) -> COption_i64Z {
	COption_i64Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_i64Z containing nothing
pub extern "C" fn COption_i64Z_none() -> COption_i64Z {
	COption_i64Z::None
}
#[no_mangle]
/// Frees any resources associated with the i64, if we are in the Some state
pub extern "C" fn COption_i64Z_free(_res: COption_i64Z) { }
#[no_mangle]
/// Creates a new COption_i64Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_i64Z_clone(orig: &COption_i64Z) -> COption_i64Z { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SocketAddressDecodeErrorZ
pub union CResult_SocketAddressDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SocketAddress,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SocketAddressDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SocketAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SocketAddressDecodeErrorZ {
	/// The contents of this CResult_SocketAddressDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SocketAddressDecodeErrorZPtr,
	/// Whether this CResult_SocketAddressDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SocketAddressDecodeErrorZ in the success state.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SocketAddress) -> CResult_SocketAddressDecodeErrorZ {
	CResult_SocketAddressDecodeErrorZ {
		contents: CResult_SocketAddressDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressDecodeErrorZ in the error state.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SocketAddressDecodeErrorZ {
	CResult_SocketAddressDecodeErrorZ {
		contents: CResult_SocketAddressDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_is_ok(o: &CResult_SocketAddressDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SocketAddressDecodeErrorZ.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_free(_res: CResult_SocketAddressDecodeErrorZ) { }
impl Drop for CResult_SocketAddressDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::DecodeError>> for CResult_SocketAddressDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SocketAddressDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SocketAddressDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SocketAddressDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SocketAddressDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SocketAddress>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SocketAddressDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SocketAddressDecodeErrorZ_clone(orig: &CResult_SocketAddressDecodeErrorZ) -> CResult_SocketAddressDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SocketAddressSocketAddressParseErrorZ
pub union CResult_SocketAddressSocketAddressParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SocketAddress,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::SocketAddressParseError,
}
#[repr(C)]
/// A CResult_SocketAddressSocketAddressParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SocketAddress on success and a crate::lightning::ln::msgs::SocketAddressParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SocketAddressSocketAddressParseErrorZ {
	/// The contents of this CResult_SocketAddressSocketAddressParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SocketAddressSocketAddressParseErrorZPtr,
	/// Whether this CResult_SocketAddressSocketAddressParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SocketAddressSocketAddressParseErrorZ in the success state.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_ok(o: crate::lightning::ln::msgs::SocketAddress) -> CResult_SocketAddressSocketAddressParseErrorZ {
	CResult_SocketAddressSocketAddressParseErrorZ {
		contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressSocketAddressParseErrorZ in the error state.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_err(e: crate::lightning::ln::msgs::SocketAddressParseError) -> CResult_SocketAddressSocketAddressParseErrorZ {
	CResult_SocketAddressSocketAddressParseErrorZ {
		contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_is_ok(o: &CResult_SocketAddressSocketAddressParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SocketAddressSocketAddressParseErrorZ.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_free(_res: CResult_SocketAddressSocketAddressParseErrorZ) { }
impl Drop for CResult_SocketAddressSocketAddressParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::SocketAddressParseError>> for CResult_SocketAddressSocketAddressParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SocketAddress, crate::lightning::ln::msgs::SocketAddressParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SocketAddressSocketAddressParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SocketAddressSocketAddressParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SocketAddressSocketAddressParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SocketAddress>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SocketAddressSocketAddressParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SocketAddressParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SocketAddressSocketAddressParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SocketAddressSocketAddressParseErrorZ_clone(orig: &CResult_SocketAddressSocketAddressParseErrorZ) -> CResult_SocketAddressSocketAddressParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateAddHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateAddHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateAddHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateAddHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateAddHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateAddHTLC>> for CVec_UpdateAddHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateAddHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateAddHTLCZ_free(_res: CVec_UpdateAddHTLCZ) { }
impl Drop for CVec_UpdateAddHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateAddHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateFulfillHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateFulfillHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateFulfillHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateFulfillHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateFulfillHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateFulfillHTLC>> for CVec_UpdateFulfillHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateFulfillHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateFulfillHTLCZ_free(_res: CVec_UpdateFulfillHTLCZ) { }
impl Drop for CVec_UpdateFulfillHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateFulfillHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateFailHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateFailHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateFailHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateFailHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateFailHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateFailHTLC>> for CVec_UpdateFailHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateFailHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateFailHTLCZ_free(_res: CVec_UpdateFailHTLCZ) { }
impl Drop for CVec_UpdateFailHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateFailHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_UpdateFailMalformedHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::msgs::UpdateFailMalformedHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_UpdateFailMalformedHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::msgs::UpdateFailMalformedHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::msgs::UpdateFailMalformedHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::msgs::UpdateFailMalformedHTLC>> for CVec_UpdateFailMalformedHTLCZ {
	fn from(v: Vec<crate::lightning::ln::msgs::UpdateFailMalformedHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_UpdateFailMalformedHTLCZ_free(_res: CVec_UpdateFailMalformedHTLCZ) { }
impl Drop for CVec_UpdateFailMalformedHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_UpdateFailMalformedHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_AcceptChannelDecodeErrorZ
pub union CResult_AcceptChannelDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::AcceptChannel,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AcceptChannelDecodeErrorZ {
	/// The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AcceptChannelDecodeErrorZPtr,
	/// Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_ok(o: crate::lightning::ln::msgs::AcceptChannel) -> CResult_AcceptChannelDecodeErrorZ {
	CResult_AcceptChannelDecodeErrorZ {
		contents: CResult_AcceptChannelDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AcceptChannelDecodeErrorZ {
	CResult_AcceptChannelDecodeErrorZ {
		contents: CResult_AcceptChannelDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_is_ok(o: &CResult_AcceptChannelDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_free(_res: CResult_AcceptChannelDecodeErrorZ) { }
impl Drop for CResult_AcceptChannelDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannel, crate::lightning::ln::msgs::DecodeError>> for CResult_AcceptChannelDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannel, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AcceptChannelDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AcceptChannelDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AcceptChannelDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AcceptChannelDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::AcceptChannel>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AcceptChannelDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AcceptChannelDecodeErrorZ_clone(orig: &CResult_AcceptChannelDecodeErrorZ) -> CResult_AcceptChannelDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_AcceptChannelV2DecodeErrorZ
pub union CResult_AcceptChannelV2DecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::AcceptChannelV2,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AcceptChannelV2DecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AcceptChannelV2 on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AcceptChannelV2DecodeErrorZ {
	/// The contents of this CResult_AcceptChannelV2DecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AcceptChannelV2DecodeErrorZPtr,
	/// Whether this CResult_AcceptChannelV2DecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelV2DecodeErrorZ in the success state.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_ok(o: crate::lightning::ln::msgs::AcceptChannelV2) -> CResult_AcceptChannelV2DecodeErrorZ {
	CResult_AcceptChannelV2DecodeErrorZ {
		contents: CResult_AcceptChannelV2DecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelV2DecodeErrorZ in the error state.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AcceptChannelV2DecodeErrorZ {
	CResult_AcceptChannelV2DecodeErrorZ {
		contents: CResult_AcceptChannelV2DecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_is_ok(o: &CResult_AcceptChannelV2DecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AcceptChannelV2DecodeErrorZ.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_free(_res: CResult_AcceptChannelV2DecodeErrorZ) { }
impl Drop for CResult_AcceptChannelV2DecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannelV2, crate::lightning::ln::msgs::DecodeError>> for CResult_AcceptChannelV2DecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::AcceptChannelV2, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AcceptChannelV2DecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AcceptChannelV2DecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AcceptChannelV2DecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AcceptChannelV2DecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::AcceptChannelV2>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AcceptChannelV2DecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AcceptChannelV2DecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AcceptChannelV2DecodeErrorZ_clone(orig: &CResult_AcceptChannelV2DecodeErrorZ) -> CResult_AcceptChannelV2DecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_StfuDecodeErrorZ
pub union CResult_StfuDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Stfu,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_StfuDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Stfu on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_StfuDecodeErrorZ {
	/// The contents of this CResult_StfuDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_StfuDecodeErrorZPtr,
	/// Whether this CResult_StfuDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_StfuDecodeErrorZ in the success state.
pub extern "C" fn CResult_StfuDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Stfu) -> CResult_StfuDecodeErrorZ {
	CResult_StfuDecodeErrorZ {
		contents: CResult_StfuDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_StfuDecodeErrorZ in the error state.
pub extern "C" fn CResult_StfuDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_StfuDecodeErrorZ {
	CResult_StfuDecodeErrorZ {
		contents: CResult_StfuDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_StfuDecodeErrorZ_is_ok(o: &CResult_StfuDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_StfuDecodeErrorZ.
pub extern "C" fn CResult_StfuDecodeErrorZ_free(_res: CResult_StfuDecodeErrorZ) { }
impl Drop for CResult_StfuDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Stfu, crate::lightning::ln::msgs::DecodeError>> for CResult_StfuDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Stfu, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_StfuDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_StfuDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_StfuDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_StfuDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Stfu>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_StfuDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_StfuDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_StfuDecodeErrorZ_clone(orig: &CResult_StfuDecodeErrorZ) -> CResult_StfuDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpliceDecodeErrorZ
pub union CResult_SpliceDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Splice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpliceDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Splice on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpliceDecodeErrorZ {
	/// The contents of this CResult_SpliceDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpliceDecodeErrorZPtr,
	/// Whether this CResult_SpliceDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpliceDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpliceDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Splice) -> CResult_SpliceDecodeErrorZ {
	CResult_SpliceDecodeErrorZ {
		contents: CResult_SpliceDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpliceDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpliceDecodeErrorZ {
	CResult_SpliceDecodeErrorZ {
		contents: CResult_SpliceDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpliceDecodeErrorZ_is_ok(o: &CResult_SpliceDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpliceDecodeErrorZ.
pub extern "C" fn CResult_SpliceDecodeErrorZ_free(_res: CResult_SpliceDecodeErrorZ) { }
impl Drop for CResult_SpliceDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Splice, crate::lightning::ln::msgs::DecodeError>> for CResult_SpliceDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Splice, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpliceDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpliceDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpliceDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpliceDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Splice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpliceDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpliceDecodeErrorZ_clone(orig: &CResult_SpliceDecodeErrorZ) -> CResult_SpliceDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpliceAckDecodeErrorZ
pub union CResult_SpliceAckDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SpliceAck,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpliceAckDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SpliceAck on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpliceAckDecodeErrorZ {
	/// The contents of this CResult_SpliceAckDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpliceAckDecodeErrorZPtr,
	/// Whether this CResult_SpliceAckDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpliceAckDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SpliceAck) -> CResult_SpliceAckDecodeErrorZ {
	CResult_SpliceAckDecodeErrorZ {
		contents: CResult_SpliceAckDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceAckDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpliceAckDecodeErrorZ {
	CResult_SpliceAckDecodeErrorZ {
		contents: CResult_SpliceAckDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_is_ok(o: &CResult_SpliceAckDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpliceAckDecodeErrorZ.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_free(_res: CResult_SpliceAckDecodeErrorZ) { }
impl Drop for CResult_SpliceAckDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceAck, crate::lightning::ln::msgs::DecodeError>> for CResult_SpliceAckDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceAck, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpliceAckDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpliceAckDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpliceAckDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpliceAckDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SpliceAck>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpliceAckDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceAckDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpliceAckDecodeErrorZ_clone(orig: &CResult_SpliceAckDecodeErrorZ) -> CResult_SpliceAckDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SpliceLockedDecodeErrorZ
pub union CResult_SpliceLockedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::SpliceLocked,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_SpliceLockedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::SpliceLocked on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SpliceLockedDecodeErrorZ {
	/// The contents of this CResult_SpliceLockedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SpliceLockedDecodeErrorZPtr,
	/// Whether this CResult_SpliceLockedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SpliceLockedDecodeErrorZ in the success state.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::SpliceLocked) -> CResult_SpliceLockedDecodeErrorZ {
	CResult_SpliceLockedDecodeErrorZ {
		contents: CResult_SpliceLockedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceLockedDecodeErrorZ in the error state.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_SpliceLockedDecodeErrorZ {
	CResult_SpliceLockedDecodeErrorZ {
		contents: CResult_SpliceLockedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_is_ok(o: &CResult_SpliceLockedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SpliceLockedDecodeErrorZ.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_free(_res: CResult_SpliceLockedDecodeErrorZ) { }
impl Drop for CResult_SpliceLockedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceLocked, crate::lightning::ln::msgs::DecodeError>> for CResult_SpliceLockedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::SpliceLocked, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SpliceLockedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SpliceLockedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SpliceLockedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SpliceLockedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::SpliceLocked>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SpliceLockedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SpliceLockedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SpliceLockedDecodeErrorZ_clone(orig: &CResult_SpliceLockedDecodeErrorZ) -> CResult_SpliceLockedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAddInputDecodeErrorZ
pub union CResult_TxAddInputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAddInput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAddInputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAddInput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAddInputDecodeErrorZ {
	/// The contents of this CResult_TxAddInputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAddInputDecodeErrorZPtr,
	/// Whether this CResult_TxAddInputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAddInputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAddInput) -> CResult_TxAddInputDecodeErrorZ {
	CResult_TxAddInputDecodeErrorZ {
		contents: CResult_TxAddInputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddInputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAddInputDecodeErrorZ {
	CResult_TxAddInputDecodeErrorZ {
		contents: CResult_TxAddInputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_is_ok(o: &CResult_TxAddInputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAddInputDecodeErrorZ.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_free(_res: CResult_TxAddInputDecodeErrorZ) { }
impl Drop for CResult_TxAddInputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddInput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAddInputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddInput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAddInputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAddInputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAddInputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAddInputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAddInput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAddInputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddInputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAddInputDecodeErrorZ_clone(orig: &CResult_TxAddInputDecodeErrorZ) -> CResult_TxAddInputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAddOutputDecodeErrorZ
pub union CResult_TxAddOutputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAddOutput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAddOutputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAddOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAddOutputDecodeErrorZ {
	/// The contents of this CResult_TxAddOutputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAddOutputDecodeErrorZPtr,
	/// Whether this CResult_TxAddOutputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAddOutputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAddOutput) -> CResult_TxAddOutputDecodeErrorZ {
	CResult_TxAddOutputDecodeErrorZ {
		contents: CResult_TxAddOutputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddOutputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAddOutputDecodeErrorZ {
	CResult_TxAddOutputDecodeErrorZ {
		contents: CResult_TxAddOutputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_is_ok(o: &CResult_TxAddOutputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAddOutputDecodeErrorZ.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_free(_res: CResult_TxAddOutputDecodeErrorZ) { }
impl Drop for CResult_TxAddOutputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddOutput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAddOutputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAddOutput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAddOutputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAddOutputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAddOutputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAddOutputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAddOutput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAddOutputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAddOutputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAddOutputDecodeErrorZ_clone(orig: &CResult_TxAddOutputDecodeErrorZ) -> CResult_TxAddOutputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxRemoveInputDecodeErrorZ
pub union CResult_TxRemoveInputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxRemoveInput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxRemoveInputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxRemoveInput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxRemoveInputDecodeErrorZ {
	/// The contents of this CResult_TxRemoveInputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxRemoveInputDecodeErrorZPtr,
	/// Whether this CResult_TxRemoveInputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxRemoveInputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxRemoveInput) -> CResult_TxRemoveInputDecodeErrorZ {
	CResult_TxRemoveInputDecodeErrorZ {
		contents: CResult_TxRemoveInputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveInputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxRemoveInputDecodeErrorZ {
	CResult_TxRemoveInputDecodeErrorZ {
		contents: CResult_TxRemoveInputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_is_ok(o: &CResult_TxRemoveInputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxRemoveInputDecodeErrorZ.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_free(_res: CResult_TxRemoveInputDecodeErrorZ) { }
impl Drop for CResult_TxRemoveInputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveInput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxRemoveInputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveInput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxRemoveInputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxRemoveInputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxRemoveInputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxRemoveInputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxRemoveInput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxRemoveInputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveInputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxRemoveInputDecodeErrorZ_clone(orig: &CResult_TxRemoveInputDecodeErrorZ) -> CResult_TxRemoveInputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxRemoveOutputDecodeErrorZ
pub union CResult_TxRemoveOutputDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxRemoveOutput,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxRemoveOutputDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxRemoveOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxRemoveOutputDecodeErrorZ {
	/// The contents of this CResult_TxRemoveOutputDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxRemoveOutputDecodeErrorZPtr,
	/// Whether this CResult_TxRemoveOutputDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxRemoveOutputDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxRemoveOutput) -> CResult_TxRemoveOutputDecodeErrorZ {
	CResult_TxRemoveOutputDecodeErrorZ {
		contents: CResult_TxRemoveOutputDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveOutputDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxRemoveOutputDecodeErrorZ {
	CResult_TxRemoveOutputDecodeErrorZ {
		contents: CResult_TxRemoveOutputDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_is_ok(o: &CResult_TxRemoveOutputDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxRemoveOutputDecodeErrorZ.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_free(_res: CResult_TxRemoveOutputDecodeErrorZ) { }
impl Drop for CResult_TxRemoveOutputDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveOutput, crate::lightning::ln::msgs::DecodeError>> for CResult_TxRemoveOutputDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxRemoveOutput, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxRemoveOutputDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxRemoveOutputDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxRemoveOutputDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxRemoveOutputDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxRemoveOutput>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxRemoveOutputDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxRemoveOutputDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxRemoveOutputDecodeErrorZ_clone(orig: &CResult_TxRemoveOutputDecodeErrorZ) -> CResult_TxRemoveOutputDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxCompleteDecodeErrorZ
pub union CResult_TxCompleteDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxComplete,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxCompleteDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxComplete on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxCompleteDecodeErrorZ {
	/// The contents of this CResult_TxCompleteDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxCompleteDecodeErrorZPtr,
	/// Whether this CResult_TxCompleteDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxCompleteDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxComplete) -> CResult_TxCompleteDecodeErrorZ {
	CResult_TxCompleteDecodeErrorZ {
		contents: CResult_TxCompleteDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxCompleteDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxCompleteDecodeErrorZ {
	CResult_TxCompleteDecodeErrorZ {
		contents: CResult_TxCompleteDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_is_ok(o: &CResult_TxCompleteDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxCompleteDecodeErrorZ.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_free(_res: CResult_TxCompleteDecodeErrorZ) { }
impl Drop for CResult_TxCompleteDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxComplete, crate::lightning::ln::msgs::DecodeError>> for CResult_TxCompleteDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxComplete, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxCompleteDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxCompleteDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxCompleteDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxCompleteDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxComplete>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxCompleteDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxCompleteDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxCompleteDecodeErrorZ_clone(orig: &CResult_TxCompleteDecodeErrorZ) -> CResult_TxCompleteDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxSignaturesDecodeErrorZ
pub union CResult_TxSignaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxSignatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxSignaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxSignaturesDecodeErrorZ {
	/// The contents of this CResult_TxSignaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxSignaturesDecodeErrorZPtr,
	/// Whether this CResult_TxSignaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxSignaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxSignatures) -> CResult_TxSignaturesDecodeErrorZ {
	CResult_TxSignaturesDecodeErrorZ {
		contents: CResult_TxSignaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxSignaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxSignaturesDecodeErrorZ {
	CResult_TxSignaturesDecodeErrorZ {
		contents: CResult_TxSignaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_is_ok(o: &CResult_TxSignaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxSignaturesDecodeErrorZ.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_free(_res: CResult_TxSignaturesDecodeErrorZ) { }
impl Drop for CResult_TxSignaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxSignatures, crate::lightning::ln::msgs::DecodeError>> for CResult_TxSignaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxSignatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxSignaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxSignaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxSignaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxSignaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxSignatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxSignaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxSignaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxSignaturesDecodeErrorZ_clone(orig: &CResult_TxSignaturesDecodeErrorZ) -> CResult_TxSignaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxInitRbfDecodeErrorZ
pub union CResult_TxInitRbfDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxInitRbf,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxInitRbfDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxInitRbf on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxInitRbfDecodeErrorZ {
	/// The contents of this CResult_TxInitRbfDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxInitRbfDecodeErrorZPtr,
	/// Whether this CResult_TxInitRbfDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxInitRbfDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxInitRbf) -> CResult_TxInitRbfDecodeErrorZ {
	CResult_TxInitRbfDecodeErrorZ {
		contents: CResult_TxInitRbfDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxInitRbfDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxInitRbfDecodeErrorZ {
	CResult_TxInitRbfDecodeErrorZ {
		contents: CResult_TxInitRbfDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_is_ok(o: &CResult_TxInitRbfDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxInitRbfDecodeErrorZ.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_free(_res: CResult_TxInitRbfDecodeErrorZ) { }
impl Drop for CResult_TxInitRbfDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxInitRbf, crate::lightning::ln::msgs::DecodeError>> for CResult_TxInitRbfDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxInitRbf, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxInitRbfDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxInitRbfDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxInitRbfDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxInitRbfDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxInitRbf>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxInitRbfDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxInitRbfDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxInitRbfDecodeErrorZ_clone(orig: &CResult_TxInitRbfDecodeErrorZ) -> CResult_TxInitRbfDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAckRbfDecodeErrorZ
pub union CResult_TxAckRbfDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAckRbf,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAckRbfDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAckRbf on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAckRbfDecodeErrorZ {
	/// The contents of this CResult_TxAckRbfDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAckRbfDecodeErrorZPtr,
	/// Whether this CResult_TxAckRbfDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAckRbfDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAckRbf) -> CResult_TxAckRbfDecodeErrorZ {
	CResult_TxAckRbfDecodeErrorZ {
		contents: CResult_TxAckRbfDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAckRbfDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAckRbfDecodeErrorZ {
	CResult_TxAckRbfDecodeErrorZ {
		contents: CResult_TxAckRbfDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_is_ok(o: &CResult_TxAckRbfDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAckRbfDecodeErrorZ.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_free(_res: CResult_TxAckRbfDecodeErrorZ) { }
impl Drop for CResult_TxAckRbfDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAckRbf, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAckRbfDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAckRbf, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAckRbfDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAckRbfDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAckRbfDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAckRbfDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAckRbf>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAckRbfDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAckRbfDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAckRbfDecodeErrorZ_clone(orig: &CResult_TxAckRbfDecodeErrorZ) -> CResult_TxAckRbfDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxAbortDecodeErrorZ
pub union CResult_TxAbortDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::TxAbort,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxAbortDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::TxAbort on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxAbortDecodeErrorZ {
	/// The contents of this CResult_TxAbortDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxAbortDecodeErrorZPtr,
	/// Whether this CResult_TxAbortDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxAbortDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_ok(o: crate::lightning::ln::msgs::TxAbort) -> CResult_TxAbortDecodeErrorZ {
	CResult_TxAbortDecodeErrorZ {
		contents: CResult_TxAbortDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxAbortDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxAbortDecodeErrorZ {
	CResult_TxAbortDecodeErrorZ {
		contents: CResult_TxAbortDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxAbortDecodeErrorZ_is_ok(o: &CResult_TxAbortDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxAbortDecodeErrorZ.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_free(_res: CResult_TxAbortDecodeErrorZ) { }
impl Drop for CResult_TxAbortDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAbort, crate::lightning::ln::msgs::DecodeError>> for CResult_TxAbortDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::TxAbort, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxAbortDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxAbortDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxAbortDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxAbortDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::TxAbort>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxAbortDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxAbortDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxAbortDecodeErrorZ_clone(orig: &CResult_TxAbortDecodeErrorZ) -> CResult_TxAbortDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_AnnouncementSignaturesDecodeErrorZ
pub union CResult_AnnouncementSignaturesDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::AnnouncementSignatures,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_AnnouncementSignaturesDecodeErrorZ {
	/// The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_AnnouncementSignaturesDecodeErrorZPtr,
	/// Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_ok(o: crate::lightning::ln::msgs::AnnouncementSignatures) -> CResult_AnnouncementSignaturesDecodeErrorZ {
	CResult_AnnouncementSignaturesDecodeErrorZ {
		contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_AnnouncementSignaturesDecodeErrorZ {
	CResult_AnnouncementSignaturesDecodeErrorZ {
		contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o: &CResult_AnnouncementSignaturesDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_free(_res: CResult_AnnouncementSignaturesDecodeErrorZ) { }
impl Drop for CResult_AnnouncementSignaturesDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::AnnouncementSignatures, crate::lightning::ln::msgs::DecodeError>> for CResult_AnnouncementSignaturesDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::AnnouncementSignatures, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_AnnouncementSignaturesDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_AnnouncementSignaturesDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_AnnouncementSignaturesDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::AnnouncementSignatures>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_AnnouncementSignaturesDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig: &CResult_AnnouncementSignaturesDecodeErrorZ) -> CResult_AnnouncementSignaturesDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelReestablishDecodeErrorZ
pub union CResult_ChannelReestablishDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelReestablish,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelReestablishDecodeErrorZ {
	/// The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelReestablishDecodeErrorZPtr,
	/// Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelReestablish) -> CResult_ChannelReestablishDecodeErrorZ {
	CResult_ChannelReestablishDecodeErrorZ {
		contents: CResult_ChannelReestablishDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelReestablishDecodeErrorZ {
	CResult_ChannelReestablishDecodeErrorZ {
		contents: CResult_ChannelReestablishDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_is_ok(o: &CResult_ChannelReestablishDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_free(_res: CResult_ChannelReestablishDecodeErrorZ) { }
impl Drop for CResult_ChannelReestablishDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReestablish, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelReestablishDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReestablish, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelReestablishDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelReestablishDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelReestablishDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelReestablishDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelReestablish>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelReestablishDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelReestablishDecodeErrorZ_clone(orig: &CResult_ChannelReestablishDecodeErrorZ) -> CResult_ChannelReestablishDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ClosingSignedDecodeErrorZ
pub union CResult_ClosingSignedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ClosingSigned,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ClosingSignedDecodeErrorZ {
	/// The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ClosingSignedDecodeErrorZPtr,
	/// Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ClosingSigned) -> CResult_ClosingSignedDecodeErrorZ {
	CResult_ClosingSignedDecodeErrorZ {
		contents: CResult_ClosingSignedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ClosingSignedDecodeErrorZ {
	CResult_ClosingSignedDecodeErrorZ {
		contents: CResult_ClosingSignedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_is_ok(o: &CResult_ClosingSignedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_free(_res: CResult_ClosingSignedDecodeErrorZ) { }
impl Drop for CResult_ClosingSignedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSigned, crate::lightning::ln::msgs::DecodeError>> for CResult_ClosingSignedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSigned, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ClosingSignedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ClosingSignedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ClosingSignedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ClosingSignedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ClosingSigned>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ClosingSignedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ClosingSignedDecodeErrorZ_clone(orig: &CResult_ClosingSignedDecodeErrorZ) -> CResult_ClosingSignedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ClosingSignedFeeRangeDecodeErrorZ
pub union CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ClosingSignedFeeRange,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ClosingSignedFeeRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ClosingSignedFeeRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ClosingSignedFeeRangeDecodeErrorZ {
	/// The contents of this CResult_ClosingSignedFeeRangeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr,
	/// Whether this CResult_ClosingSignedFeeRangeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ClosingSignedFeeRange) -> CResult_ClosingSignedFeeRangeDecodeErrorZ {
	CResult_ClosingSignedFeeRangeDecodeErrorZ {
		contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ClosingSignedFeeRangeDecodeErrorZ {
	CResult_ClosingSignedFeeRangeDecodeErrorZ {
		contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o: &CResult_ClosingSignedFeeRangeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ClosingSignedFeeRangeDecodeErrorZ.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res: CResult_ClosingSignedFeeRangeDecodeErrorZ) { }
impl Drop for CResult_ClosingSignedFeeRangeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSignedFeeRange, crate::lightning::ln::msgs::DecodeError>> for CResult_ClosingSignedFeeRangeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ClosingSignedFeeRange, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ClosingSignedFeeRangeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ClosingSignedFeeRangeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ClosingSignedFeeRangeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ClosingSignedFeeRange>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ClosingSignedFeeRangeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig: &CResult_ClosingSignedFeeRangeDecodeErrorZ) -> CResult_ClosingSignedFeeRangeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CommitmentSignedDecodeErrorZ
pub union CResult_CommitmentSignedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::CommitmentSigned,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CommitmentSignedDecodeErrorZ {
	/// The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CommitmentSignedDecodeErrorZPtr,
	/// Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::CommitmentSigned) -> CResult_CommitmentSignedDecodeErrorZ {
	CResult_CommitmentSignedDecodeErrorZ {
		contents: CResult_CommitmentSignedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CommitmentSignedDecodeErrorZ {
	CResult_CommitmentSignedDecodeErrorZ {
		contents: CResult_CommitmentSignedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_is_ok(o: &CResult_CommitmentSignedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_free(_res: CResult_CommitmentSignedDecodeErrorZ) { }
impl Drop for CResult_CommitmentSignedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::CommitmentSigned, crate::lightning::ln::msgs::DecodeError>> for CResult_CommitmentSignedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::CommitmentSigned, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CommitmentSignedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CommitmentSignedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CommitmentSignedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CommitmentSignedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::CommitmentSigned>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CommitmentSignedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CommitmentSignedDecodeErrorZ_clone(orig: &CResult_CommitmentSignedDecodeErrorZ) -> CResult_CommitmentSignedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FundingCreatedDecodeErrorZ
pub union CResult_FundingCreatedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::FundingCreated,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FundingCreatedDecodeErrorZ {
	/// The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FundingCreatedDecodeErrorZPtr,
	/// Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::FundingCreated) -> CResult_FundingCreatedDecodeErrorZ {
	CResult_FundingCreatedDecodeErrorZ {
		contents: CResult_FundingCreatedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FundingCreatedDecodeErrorZ {
	CResult_FundingCreatedDecodeErrorZ {
		contents: CResult_FundingCreatedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_is_ok(o: &CResult_FundingCreatedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_free(_res: CResult_FundingCreatedDecodeErrorZ) { }
impl Drop for CResult_FundingCreatedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingCreated, crate::lightning::ln::msgs::DecodeError>> for CResult_FundingCreatedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingCreated, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FundingCreatedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FundingCreatedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FundingCreatedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FundingCreatedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::FundingCreated>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FundingCreatedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FundingCreatedDecodeErrorZ_clone(orig: &CResult_FundingCreatedDecodeErrorZ) -> CResult_FundingCreatedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FundingSignedDecodeErrorZ
pub union CResult_FundingSignedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::FundingSigned,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FundingSignedDecodeErrorZ {
	/// The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FundingSignedDecodeErrorZPtr,
	/// Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_ok(o: crate::lightning::ln::msgs::FundingSigned) -> CResult_FundingSignedDecodeErrorZ {
	CResult_FundingSignedDecodeErrorZ {
		contents: CResult_FundingSignedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FundingSignedDecodeErrorZ {
	CResult_FundingSignedDecodeErrorZ {
		contents: CResult_FundingSignedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_is_ok(o: &CResult_FundingSignedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_free(_res: CResult_FundingSignedDecodeErrorZ) { }
impl Drop for CResult_FundingSignedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingSigned, crate::lightning::ln::msgs::DecodeError>> for CResult_FundingSignedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::FundingSigned, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FundingSignedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FundingSignedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FundingSignedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FundingSignedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::FundingSigned>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FundingSignedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FundingSignedDecodeErrorZ_clone(orig: &CResult_FundingSignedDecodeErrorZ) -> CResult_FundingSignedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelReadyDecodeErrorZ
pub union CResult_ChannelReadyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelReady,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelReadyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelReady on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelReadyDecodeErrorZ {
	/// The contents of this CResult_ChannelReadyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelReadyDecodeErrorZPtr,
	/// Whether this CResult_ChannelReadyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelReadyDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelReady) -> CResult_ChannelReadyDecodeErrorZ {
	CResult_ChannelReadyDecodeErrorZ {
		contents: CResult_ChannelReadyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReadyDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelReadyDecodeErrorZ {
	CResult_ChannelReadyDecodeErrorZ {
		contents: CResult_ChannelReadyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_is_ok(o: &CResult_ChannelReadyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelReadyDecodeErrorZ.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_free(_res: CResult_ChannelReadyDecodeErrorZ) { }
impl Drop for CResult_ChannelReadyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReady, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelReadyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelReady, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelReadyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelReadyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelReadyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelReadyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelReady>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelReadyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelReadyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelReadyDecodeErrorZ_clone(orig: &CResult_ChannelReadyDecodeErrorZ) -> CResult_ChannelReadyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InitDecodeErrorZ
pub union CResult_InitDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Init,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InitDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InitDecodeErrorZ {
	/// The contents of this CResult_InitDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InitDecodeErrorZPtr,
	/// Whether this CResult_InitDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InitDecodeErrorZ in the success state.
pub extern "C" fn CResult_InitDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Init) -> CResult_InitDecodeErrorZ {
	CResult_InitDecodeErrorZ {
		contents: CResult_InitDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InitDecodeErrorZ in the error state.
pub extern "C" fn CResult_InitDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InitDecodeErrorZ {
	CResult_InitDecodeErrorZ {
		contents: CResult_InitDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InitDecodeErrorZ_is_ok(o: &CResult_InitDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InitDecodeErrorZ.
pub extern "C" fn CResult_InitDecodeErrorZ_free(_res: CResult_InitDecodeErrorZ) { }
impl Drop for CResult_InitDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Init, crate::lightning::ln::msgs::DecodeError>> for CResult_InitDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Init, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InitDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InitDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InitDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InitDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Init>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InitDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InitDecodeErrorZ_clone(orig: &CResult_InitDecodeErrorZ) -> CResult_InitDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OpenChannelDecodeErrorZ
pub union CResult_OpenChannelDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OpenChannel,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OpenChannelDecodeErrorZ {
	/// The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OpenChannelDecodeErrorZPtr,
	/// Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_ok(o: crate::lightning::ln::msgs::OpenChannel) -> CResult_OpenChannelDecodeErrorZ {
	CResult_OpenChannelDecodeErrorZ {
		contents: CResult_OpenChannelDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OpenChannelDecodeErrorZ {
	CResult_OpenChannelDecodeErrorZ {
		contents: CResult_OpenChannelDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_is_ok(o: &CResult_OpenChannelDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_free(_res: CResult_OpenChannelDecodeErrorZ) { }
impl Drop for CResult_OpenChannelDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannel, crate::lightning::ln::msgs::DecodeError>> for CResult_OpenChannelDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannel, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OpenChannelDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OpenChannelDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OpenChannelDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OpenChannelDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OpenChannel>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OpenChannelDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OpenChannelDecodeErrorZ_clone(orig: &CResult_OpenChannelDecodeErrorZ) -> CResult_OpenChannelDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OpenChannelV2DecodeErrorZ
pub union CResult_OpenChannelV2DecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OpenChannelV2,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OpenChannelV2DecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OpenChannelV2 on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OpenChannelV2DecodeErrorZ {
	/// The contents of this CResult_OpenChannelV2DecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OpenChannelV2DecodeErrorZPtr,
	/// Whether this CResult_OpenChannelV2DecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OpenChannelV2DecodeErrorZ in the success state.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_ok(o: crate::lightning::ln::msgs::OpenChannelV2) -> CResult_OpenChannelV2DecodeErrorZ {
	CResult_OpenChannelV2DecodeErrorZ {
		contents: CResult_OpenChannelV2DecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelV2DecodeErrorZ in the error state.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OpenChannelV2DecodeErrorZ {
	CResult_OpenChannelV2DecodeErrorZ {
		contents: CResult_OpenChannelV2DecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_is_ok(o: &CResult_OpenChannelV2DecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OpenChannelV2DecodeErrorZ.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_free(_res: CResult_OpenChannelV2DecodeErrorZ) { }
impl Drop for CResult_OpenChannelV2DecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannelV2, crate::lightning::ln::msgs::DecodeError>> for CResult_OpenChannelV2DecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OpenChannelV2, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OpenChannelV2DecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OpenChannelV2DecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OpenChannelV2DecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OpenChannelV2DecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OpenChannelV2>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OpenChannelV2DecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OpenChannelV2DecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OpenChannelV2DecodeErrorZ_clone(orig: &CResult_OpenChannelV2DecodeErrorZ) -> CResult_OpenChannelV2DecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RevokeAndACKDecodeErrorZ
pub union CResult_RevokeAndACKDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::RevokeAndACK,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RevokeAndACKDecodeErrorZ {
	/// The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RevokeAndACKDecodeErrorZPtr,
	/// Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_ok(o: crate::lightning::ln::msgs::RevokeAndACK) -> CResult_RevokeAndACKDecodeErrorZ {
	CResult_RevokeAndACKDecodeErrorZ {
		contents: CResult_RevokeAndACKDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RevokeAndACKDecodeErrorZ {
	CResult_RevokeAndACKDecodeErrorZ {
		contents: CResult_RevokeAndACKDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_is_ok(o: &CResult_RevokeAndACKDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_free(_res: CResult_RevokeAndACKDecodeErrorZ) { }
impl Drop for CResult_RevokeAndACKDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::RevokeAndACK, crate::lightning::ln::msgs::DecodeError>> for CResult_RevokeAndACKDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::RevokeAndACK, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RevokeAndACKDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RevokeAndACKDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RevokeAndACKDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RevokeAndACKDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::RevokeAndACK>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RevokeAndACKDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RevokeAndACKDecodeErrorZ_clone(orig: &CResult_RevokeAndACKDecodeErrorZ) -> CResult_RevokeAndACKDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownDecodeErrorZ
pub union CResult_ShutdownDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Shutdown,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownDecodeErrorZ {
	/// The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownDecodeErrorZPtr,
	/// Whether this CResult_ShutdownDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownDecodeErrorZ in the success state.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Shutdown) -> CResult_ShutdownDecodeErrorZ {
	CResult_ShutdownDecodeErrorZ {
		contents: CResult_ShutdownDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownDecodeErrorZ in the error state.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ShutdownDecodeErrorZ {
	CResult_ShutdownDecodeErrorZ {
		contents: CResult_ShutdownDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownDecodeErrorZ_is_ok(o: &CResult_ShutdownDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownDecodeErrorZ.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_free(_res: CResult_ShutdownDecodeErrorZ) { }
impl Drop for CResult_ShutdownDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Shutdown, crate::lightning::ln::msgs::DecodeError>> for CResult_ShutdownDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Shutdown, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ShutdownDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Shutdown>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownDecodeErrorZ_clone(orig: &CResult_ShutdownDecodeErrorZ) -> CResult_ShutdownDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFailHTLCDecodeErrorZ
pub union CResult_UpdateFailHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFailHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFailHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFailHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFailHTLC) -> CResult_UpdateFailHTLCDecodeErrorZ {
	CResult_UpdateFailHTLCDecodeErrorZ {
		contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFailHTLCDecodeErrorZ {
	CResult_UpdateFailHTLCDecodeErrorZ {
		contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateFailHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_free(_res: CResult_UpdateFailHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateFailHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFailHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFailHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFailHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFailHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFailHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFailHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFailHTLCDecodeErrorZ_clone(orig: &CResult_UpdateFailHTLCDecodeErrorZ) -> CResult_UpdateFailHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
pub union CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFailMalformedHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFailMalformedHTLC) -> CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	CResult_UpdateFailMalformedHTLCDecodeErrorZ {
		contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	CResult_UpdateFailMalformedHTLCDecodeErrorZ {
		contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateFailMalformedHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res: CResult_UpdateFailMalformedHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailMalformedHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFailMalformedHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFailMalformedHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFailMalformedHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFailMalformedHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFailMalformedHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig: &CResult_UpdateFailMalformedHTLCDecodeErrorZ) -> CResult_UpdateFailMalformedHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFeeDecodeErrorZ
pub union CResult_UpdateFeeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFee,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFeeDecodeErrorZ {
	/// The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFeeDecodeErrorZPtr,
	/// Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFee) -> CResult_UpdateFeeDecodeErrorZ {
	CResult_UpdateFeeDecodeErrorZ {
		contents: CResult_UpdateFeeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFeeDecodeErrorZ {
	CResult_UpdateFeeDecodeErrorZ {
		contents: CResult_UpdateFeeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_is_ok(o: &CResult_UpdateFeeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_free(_res: CResult_UpdateFeeDecodeErrorZ) { }
impl Drop for CResult_UpdateFeeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFee, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFeeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFee, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFeeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFeeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFeeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFeeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFee>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFeeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFeeDecodeErrorZ_clone(orig: &CResult_UpdateFeeDecodeErrorZ) -> CResult_UpdateFeeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
pub union CResult_UpdateFulfillHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateFulfillHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateFulfillHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateFulfillHTLC) -> CResult_UpdateFulfillHTLCDecodeErrorZ {
	CResult_UpdateFulfillHTLCDecodeErrorZ {
		contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateFulfillHTLCDecodeErrorZ {
	CResult_UpdateFulfillHTLCDecodeErrorZ {
		contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateFulfillHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res: CResult_UpdateFulfillHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateFulfillHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFulfillHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateFulfillHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateFulfillHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateFulfillHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateFulfillHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateFulfillHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateFulfillHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateFulfillHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig: &CResult_UpdateFulfillHTLCDecodeErrorZ) -> CResult_UpdateFulfillHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OnionPacketDecodeErrorZ
pub union CResult_OnionPacketDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OnionPacket,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OnionPacketDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OnionPacket on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OnionPacketDecodeErrorZ {
	/// The contents of this CResult_OnionPacketDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OnionPacketDecodeErrorZPtr,
	/// Whether this CResult_OnionPacketDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OnionPacketDecodeErrorZ in the success state.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_ok(o: crate::lightning::ln::msgs::OnionPacket) -> CResult_OnionPacketDecodeErrorZ {
	CResult_OnionPacketDecodeErrorZ {
		contents: CResult_OnionPacketDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OnionPacketDecodeErrorZ in the error state.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OnionPacketDecodeErrorZ {
	CResult_OnionPacketDecodeErrorZ {
		contents: CResult_OnionPacketDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_is_ok(o: &CResult_OnionPacketDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OnionPacketDecodeErrorZ.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_free(_res: CResult_OnionPacketDecodeErrorZ) { }
impl Drop for CResult_OnionPacketDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionPacket, crate::lightning::ln::msgs::DecodeError>> for CResult_OnionPacketDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionPacket, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OnionPacketDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OnionPacketDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OnionPacketDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OnionPacketDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OnionPacket>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OnionPacketDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OnionPacketDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OnionPacketDecodeErrorZ_clone(orig: &CResult_OnionPacketDecodeErrorZ) -> CResult_OnionPacketDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UpdateAddHTLCDecodeErrorZ
pub union CResult_UpdateAddHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UpdateAddHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UpdateAddHTLCDecodeErrorZ {
	/// The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UpdateAddHTLCDecodeErrorZPtr,
	/// Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UpdateAddHTLC) -> CResult_UpdateAddHTLCDecodeErrorZ {
	CResult_UpdateAddHTLCDecodeErrorZ {
		contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UpdateAddHTLCDecodeErrorZ {
	CResult_UpdateAddHTLCDecodeErrorZ {
		contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o: &CResult_UpdateAddHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_free(_res: CResult_UpdateAddHTLCDecodeErrorZ) { }
impl Drop for CResult_UpdateAddHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateAddHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_UpdateAddHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UpdateAddHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UpdateAddHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UpdateAddHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UpdateAddHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UpdateAddHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UpdateAddHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UpdateAddHTLCDecodeErrorZ_clone(orig: &CResult_UpdateAddHTLCDecodeErrorZ) -> CResult_UpdateAddHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OnionMessageDecodeErrorZ
pub union CResult_OnionMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::OnionMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OnionMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::OnionMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OnionMessageDecodeErrorZ {
	/// The contents of this CResult_OnionMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OnionMessageDecodeErrorZPtr,
	/// Whether this CResult_OnionMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OnionMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_ok(o: crate::lightning::ln::msgs::OnionMessage) -> CResult_OnionMessageDecodeErrorZ {
	CResult_OnionMessageDecodeErrorZ {
		contents: CResult_OnionMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OnionMessageDecodeErrorZ {
	CResult_OnionMessageDecodeErrorZ {
		contents: CResult_OnionMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_is_ok(o: &CResult_OnionMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OnionMessageDecodeErrorZ.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_free(_res: CResult_OnionMessageDecodeErrorZ) { }
impl Drop for CResult_OnionMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_OnionMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::OnionMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OnionMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OnionMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OnionMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OnionMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::OnionMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OnionMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OnionMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OnionMessageDecodeErrorZ_clone(orig: &CResult_OnionMessageDecodeErrorZ) -> CResult_OnionMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_FinalOnionHopDataDecodeErrorZ
pub union CResult_FinalOnionHopDataDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::FinalOnionHopData,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_FinalOnionHopDataDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::FinalOnionHopData on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_FinalOnionHopDataDecodeErrorZ {
	/// The contents of this CResult_FinalOnionHopDataDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_FinalOnionHopDataDecodeErrorZPtr,
	/// Whether this CResult_FinalOnionHopDataDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_FinalOnionHopDataDecodeErrorZ in the success state.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_ok(o: crate::lightning::ln::msgs::FinalOnionHopData) -> CResult_FinalOnionHopDataDecodeErrorZ {
	CResult_FinalOnionHopDataDecodeErrorZ {
		contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_FinalOnionHopDataDecodeErrorZ in the error state.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_FinalOnionHopDataDecodeErrorZ {
	CResult_FinalOnionHopDataDecodeErrorZ {
		contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_is_ok(o: &CResult_FinalOnionHopDataDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_FinalOnionHopDataDecodeErrorZ.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_free(_res: CResult_FinalOnionHopDataDecodeErrorZ) { }
impl Drop for CResult_FinalOnionHopDataDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::FinalOnionHopData, crate::lightning::ln::msgs::DecodeError>> for CResult_FinalOnionHopDataDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::FinalOnionHopData, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_FinalOnionHopDataDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_FinalOnionHopDataDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_FinalOnionHopDataDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::FinalOnionHopData>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_FinalOnionHopDataDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_FinalOnionHopDataDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_FinalOnionHopDataDecodeErrorZ_clone(orig: &CResult_FinalOnionHopDataDecodeErrorZ) -> CResult_FinalOnionHopDataDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PingDecodeErrorZ
pub union CResult_PingDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Ping,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PingDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PingDecodeErrorZ {
	/// The contents of this CResult_PingDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PingDecodeErrorZPtr,
	/// Whether this CResult_PingDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PingDecodeErrorZ in the success state.
pub extern "C" fn CResult_PingDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Ping) -> CResult_PingDecodeErrorZ {
	CResult_PingDecodeErrorZ {
		contents: CResult_PingDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PingDecodeErrorZ in the error state.
pub extern "C" fn CResult_PingDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PingDecodeErrorZ {
	CResult_PingDecodeErrorZ {
		contents: CResult_PingDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PingDecodeErrorZ_is_ok(o: &CResult_PingDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PingDecodeErrorZ.
pub extern "C" fn CResult_PingDecodeErrorZ_free(_res: CResult_PingDecodeErrorZ) { }
impl Drop for CResult_PingDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Ping, crate::lightning::ln::msgs::DecodeError>> for CResult_PingDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Ping, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PingDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PingDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PingDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PingDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Ping>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PingDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PingDecodeErrorZ_clone(orig: &CResult_PingDecodeErrorZ) -> CResult_PingDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PongDecodeErrorZ
pub union CResult_PongDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::Pong,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PongDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PongDecodeErrorZ {
	/// The contents of this CResult_PongDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PongDecodeErrorZPtr,
	/// Whether this CResult_PongDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PongDecodeErrorZ in the success state.
pub extern "C" fn CResult_PongDecodeErrorZ_ok(o: crate::lightning::ln::msgs::Pong) -> CResult_PongDecodeErrorZ {
	CResult_PongDecodeErrorZ {
		contents: CResult_PongDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PongDecodeErrorZ in the error state.
pub extern "C" fn CResult_PongDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PongDecodeErrorZ {
	CResult_PongDecodeErrorZ {
		contents: CResult_PongDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PongDecodeErrorZ_is_ok(o: &CResult_PongDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PongDecodeErrorZ.
pub extern "C" fn CResult_PongDecodeErrorZ_free(_res: CResult_PongDecodeErrorZ) { }
impl Drop for CResult_PongDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::Pong, crate::lightning::ln::msgs::DecodeError>> for CResult_PongDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::Pong, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PongDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PongDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PongDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PongDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::Pong>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PongDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PongDecodeErrorZ_clone(orig: &CResult_PongDecodeErrorZ) -> CResult_PongDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
pub union CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UnsignedChannelAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	/// The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UnsignedChannelAnnouncement) -> CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	CResult_UnsignedChannelAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	CResult_UnsignedChannelAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o: &CResult_UnsignedChannelAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res: CResult_UnsignedChannelAnnouncementDecodeErrorZ) { }
impl Drop for CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedChannelAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedChannelAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedChannelAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UnsignedChannelAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig: &CResult_UnsignedChannelAnnouncementDecodeErrorZ) -> CResult_UnsignedChannelAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelAnnouncementDecodeErrorZ
pub union CResult_ChannelAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelAnnouncementDecodeErrorZ {
	/// The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelAnnouncement) -> CResult_ChannelAnnouncementDecodeErrorZ {
	CResult_ChannelAnnouncementDecodeErrorZ {
		contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelAnnouncementDecodeErrorZ {
	CResult_ChannelAnnouncementDecodeErrorZ {
		contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o: &CResult_ChannelAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_free(_res: CResult_ChannelAnnouncementDecodeErrorZ) { }
impl Drop for CResult_ChannelAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelAnnouncementDecodeErrorZ_clone(orig: &CResult_ChannelAnnouncementDecodeErrorZ) -> CResult_ChannelAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
pub union CResult_UnsignedChannelUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UnsignedChannelUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedChannelUpdateDecodeErrorZ {
	/// The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr,
	/// Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UnsignedChannelUpdate) -> CResult_UnsignedChannelUpdateDecodeErrorZ {
	CResult_UnsignedChannelUpdateDecodeErrorZ {
		contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UnsignedChannelUpdateDecodeErrorZ {
	CResult_UnsignedChannelUpdateDecodeErrorZ {
		contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o: &CResult_UnsignedChannelUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res: CResult_UnsignedChannelUpdateDecodeErrorZ) { }
impl Drop for CResult_UnsignedChannelUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_UnsignedChannelUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedChannelUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedChannelUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedChannelUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedChannelUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UnsignedChannelUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedChannelUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig: &CResult_UnsignedChannelUpdateDecodeErrorZ) -> CResult_UnsignedChannelUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelUpdateDecodeErrorZ
pub union CResult_ChannelUpdateDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ChannelUpdate,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelUpdateDecodeErrorZ {
	/// The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelUpdateDecodeErrorZPtr,
	/// Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ChannelUpdate) -> CResult_ChannelUpdateDecodeErrorZ {
	CResult_ChannelUpdateDecodeErrorZ {
		contents: CResult_ChannelUpdateDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelUpdateDecodeErrorZ {
	CResult_ChannelUpdateDecodeErrorZ {
		contents: CResult_ChannelUpdateDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_is_ok(o: &CResult_ChannelUpdateDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_free(_res: CResult_ChannelUpdateDecodeErrorZ) { }
impl Drop for CResult_ChannelUpdateDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelUpdateDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ChannelUpdate, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelUpdateDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelUpdateDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelUpdateDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelUpdateDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ChannelUpdate>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelUpdateDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelUpdateDecodeErrorZ_clone(orig: &CResult_ChannelUpdateDecodeErrorZ) -> CResult_ChannelUpdateDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ErrorMessageDecodeErrorZ
pub union CResult_ErrorMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ErrorMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ErrorMessageDecodeErrorZ {
	/// The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ErrorMessageDecodeErrorZPtr,
	/// Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ErrorMessage) -> CResult_ErrorMessageDecodeErrorZ {
	CResult_ErrorMessageDecodeErrorZ {
		contents: CResult_ErrorMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ErrorMessageDecodeErrorZ {
	CResult_ErrorMessageDecodeErrorZ {
		contents: CResult_ErrorMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_is_ok(o: &CResult_ErrorMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_free(_res: CResult_ErrorMessageDecodeErrorZ) { }
impl Drop for CResult_ErrorMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ErrorMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_ErrorMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ErrorMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ErrorMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ErrorMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ErrorMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ErrorMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ErrorMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ErrorMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ErrorMessageDecodeErrorZ_clone(orig: &CResult_ErrorMessageDecodeErrorZ) -> CResult_ErrorMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_WarningMessageDecodeErrorZ
pub union CResult_WarningMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::WarningMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_WarningMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::WarningMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_WarningMessageDecodeErrorZ {
	/// The contents of this CResult_WarningMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_WarningMessageDecodeErrorZPtr,
	/// Whether this CResult_WarningMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_WarningMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_ok(o: crate::lightning::ln::msgs::WarningMessage) -> CResult_WarningMessageDecodeErrorZ {
	CResult_WarningMessageDecodeErrorZ {
		contents: CResult_WarningMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_WarningMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_WarningMessageDecodeErrorZ {
	CResult_WarningMessageDecodeErrorZ {
		contents: CResult_WarningMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_is_ok(o: &CResult_WarningMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_WarningMessageDecodeErrorZ.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_free(_res: CResult_WarningMessageDecodeErrorZ) { }
impl Drop for CResult_WarningMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::WarningMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_WarningMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::WarningMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_WarningMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_WarningMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_WarningMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_WarningMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::WarningMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_WarningMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_WarningMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_WarningMessageDecodeErrorZ_clone(orig: &CResult_WarningMessageDecodeErrorZ) -> CResult_WarningMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
pub union CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::UnsignedNodeAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	/// The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::UnsignedNodeAnnouncement) -> CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	CResult_UnsignedNodeAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	CResult_UnsignedNodeAnnouncementDecodeErrorZ {
		contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o: &CResult_UnsignedNodeAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res: CResult_UnsignedNodeAnnouncementDecodeErrorZ) { }
impl Drop for CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedNodeAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::UnsignedNodeAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UnsignedNodeAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UnsignedNodeAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UnsignedNodeAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::UnsignedNodeAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig: &CResult_UnsignedNodeAnnouncementDecodeErrorZ) -> CResult_UnsignedNodeAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NodeAnnouncementDecodeErrorZ
pub union CResult_NodeAnnouncementDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::NodeAnnouncement,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NodeAnnouncementDecodeErrorZ {
	/// The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NodeAnnouncementDecodeErrorZPtr,
	/// Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_ok(o: crate::lightning::ln::msgs::NodeAnnouncement) -> CResult_NodeAnnouncementDecodeErrorZ {
	CResult_NodeAnnouncementDecodeErrorZ {
		contents: CResult_NodeAnnouncementDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_NodeAnnouncementDecodeErrorZ {
	CResult_NodeAnnouncementDecodeErrorZ {
		contents: CResult_NodeAnnouncementDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_is_ok(o: &CResult_NodeAnnouncementDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_free(_res: CResult_NodeAnnouncementDecodeErrorZ) { }
impl Drop for CResult_NodeAnnouncementDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::NodeAnnouncement, crate::lightning::ln::msgs::DecodeError>> for CResult_NodeAnnouncementDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::NodeAnnouncement, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_NodeAnnouncementDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NodeAnnouncementDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NodeAnnouncementDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NodeAnnouncementDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::NodeAnnouncement>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_NodeAnnouncementDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NodeAnnouncementDecodeErrorZ_clone(orig: &CResult_NodeAnnouncementDecodeErrorZ) -> CResult_NodeAnnouncementDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_QueryShortChannelIdsDecodeErrorZ
pub union CResult_QueryShortChannelIdsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::QueryShortChannelIds,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_QueryShortChannelIdsDecodeErrorZ {
	/// The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_QueryShortChannelIdsDecodeErrorZPtr,
	/// Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_ok(o: crate::lightning::ln::msgs::QueryShortChannelIds) -> CResult_QueryShortChannelIdsDecodeErrorZ {
	CResult_QueryShortChannelIdsDecodeErrorZ {
		contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_QueryShortChannelIdsDecodeErrorZ {
	CResult_QueryShortChannelIdsDecodeErrorZ {
		contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o: &CResult_QueryShortChannelIdsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_free(_res: CResult_QueryShortChannelIdsDecodeErrorZ) { }
impl Drop for CResult_QueryShortChannelIdsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryShortChannelIds, crate::lightning::ln::msgs::DecodeError>> for CResult_QueryShortChannelIdsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryShortChannelIds, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_QueryShortChannelIdsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_QueryShortChannelIdsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_QueryShortChannelIdsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::QueryShortChannelIds>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_QueryShortChannelIdsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig: &CResult_QueryShortChannelIdsDecodeErrorZ) -> CResult_QueryShortChannelIdsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
pub union CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ReplyShortChannelIdsEnd,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	/// The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr,
	/// Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ReplyShortChannelIdsEnd) -> CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	CResult_ReplyShortChannelIdsEndDecodeErrorZ {
		contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	CResult_ReplyShortChannelIdsEndDecodeErrorZ {
		contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o: &CResult_ReplyShortChannelIdsEndDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res: CResult_ReplyShortChannelIdsEndDecodeErrorZ) { }
impl Drop for CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyShortChannelIdsEnd, crate::lightning::ln::msgs::DecodeError>> for CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyShortChannelIdsEnd, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ReplyShortChannelIdsEndDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ReplyShortChannelIdsEndDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ReplyShortChannelIdsEndDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ReplyShortChannelIdsEnd>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig: &CResult_ReplyShortChannelIdsEndDecodeErrorZ) -> CResult_ReplyShortChannelIdsEndDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_QueryChannelRangeDecodeErrorZ
pub union CResult_QueryChannelRangeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::QueryChannelRange,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_QueryChannelRangeDecodeErrorZ {
	/// The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_QueryChannelRangeDecodeErrorZPtr,
	/// Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::QueryChannelRange) -> CResult_QueryChannelRangeDecodeErrorZ {
	CResult_QueryChannelRangeDecodeErrorZ {
		contents: CResult_QueryChannelRangeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_QueryChannelRangeDecodeErrorZ {
	CResult_QueryChannelRangeDecodeErrorZ {
		contents: CResult_QueryChannelRangeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_is_ok(o: &CResult_QueryChannelRangeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_free(_res: CResult_QueryChannelRangeDecodeErrorZ) { }
impl Drop for CResult_QueryChannelRangeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryChannelRange, crate::lightning::ln::msgs::DecodeError>> for CResult_QueryChannelRangeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::QueryChannelRange, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_QueryChannelRangeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_QueryChannelRangeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_QueryChannelRangeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_QueryChannelRangeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::QueryChannelRange>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_QueryChannelRangeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_QueryChannelRangeDecodeErrorZ_clone(orig: &CResult_QueryChannelRangeDecodeErrorZ) -> CResult_QueryChannelRangeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ReplyChannelRangeDecodeErrorZ
pub union CResult_ReplyChannelRangeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::ReplyChannelRange,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ReplyChannelRangeDecodeErrorZ {
	/// The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ReplyChannelRangeDecodeErrorZPtr,
	/// Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_ok(o: crate::lightning::ln::msgs::ReplyChannelRange) -> CResult_ReplyChannelRangeDecodeErrorZ {
	CResult_ReplyChannelRangeDecodeErrorZ {
		contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ReplyChannelRangeDecodeErrorZ {
	CResult_ReplyChannelRangeDecodeErrorZ {
		contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o: &CResult_ReplyChannelRangeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_free(_res: CResult_ReplyChannelRangeDecodeErrorZ) { }
impl Drop for CResult_ReplyChannelRangeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyChannelRange, crate::lightning::ln::msgs::DecodeError>> for CResult_ReplyChannelRangeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::ReplyChannelRange, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ReplyChannelRangeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ReplyChannelRangeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ReplyChannelRangeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::ReplyChannelRange>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ReplyChannelRangeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ReplyChannelRangeDecodeErrorZ_clone(orig: &CResult_ReplyChannelRangeDecodeErrorZ) -> CResult_ReplyChannelRangeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_GossipTimestampFilterDecodeErrorZ
pub union CResult_GossipTimestampFilterDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::msgs::GossipTimestampFilter,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_GossipTimestampFilterDecodeErrorZ {
	/// The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_GossipTimestampFilterDecodeErrorZPtr,
	/// Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_ok(o: crate::lightning::ln::msgs::GossipTimestampFilter) -> CResult_GossipTimestampFilterDecodeErrorZ {
	CResult_GossipTimestampFilterDecodeErrorZ {
		contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_GossipTimestampFilterDecodeErrorZ {
	CResult_GossipTimestampFilterDecodeErrorZ {
		contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o: &CResult_GossipTimestampFilterDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_free(_res: CResult_GossipTimestampFilterDecodeErrorZ) { }
impl Drop for CResult_GossipTimestampFilterDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::msgs::GossipTimestampFilter, crate::lightning::ln::msgs::DecodeError>> for CResult_GossipTimestampFilterDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::msgs::GossipTimestampFilter, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_GossipTimestampFilterDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_GossipTimestampFilterDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_GossipTimestampFilterDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::msgs::GossipTimestampFilter>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_GossipTimestampFilterDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_GossipTimestampFilterDecodeErrorZ_clone(orig: &CResult_GossipTimestampFilterDecodeErrorZ) -> CResult_GossipTimestampFilterDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::ln::channelmanager::PhantomRouteHintss of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PhantomRouteHintsZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::ln::channelmanager::PhantomRouteHints,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PhantomRouteHintsZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::ln::channelmanager::PhantomRouteHints> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::ln::channelmanager::PhantomRouteHints] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::ln::channelmanager::PhantomRouteHints>> for CVec_PhantomRouteHintsZ {
	fn from(v: Vec<crate::lightning::ln::channelmanager::PhantomRouteHints>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PhantomRouteHintsZ_free(_res: CVec_PhantomRouteHintsZ) { }
impl Drop for CVec_PhantomRouteHintsZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PhantomRouteHintsZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceSignOrCreationErrorZ
pub union CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Bolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::SignOrCreationError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceSignOrCreationErrorZ {
	/// The contents of this CResult_Bolt11InvoiceSignOrCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceSignOrCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_ok(o: crate::lightning_invoice::Bolt11Invoice) -> CResult_Bolt11InvoiceSignOrCreationErrorZ {
	CResult_Bolt11InvoiceSignOrCreationErrorZ {
		contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_err(e: crate::lightning_invoice::SignOrCreationError) -> CResult_Bolt11InvoiceSignOrCreationErrorZ {
	CResult_Bolt11InvoiceSignOrCreationErrorZ {
		contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_is_ok(o: &CResult_Bolt11InvoiceSignOrCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceSignOrCreationErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_free(_res: CResult_Bolt11InvoiceSignOrCreationErrorZ) { }
impl Drop for CResult_Bolt11InvoiceSignOrCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::SignOrCreationError>> for CResult_Bolt11InvoiceSignOrCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::SignOrCreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceSignOrCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceSignOrCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceSignOrCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceSignOrCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::SignOrCreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceSignOrCreationErrorZ_clone(orig: &CResult_Bolt11InvoiceSignOrCreationErrorZ) -> CResult_Bolt11InvoiceSignOrCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::util::wakers::Futures of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_FutureZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::util::wakers::Future,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_FutureZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::util::wakers::Future> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::util::wakers::Future] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::util::wakers::Future>> for CVec_FutureZ {
	fn from(v: Vec<crate::lightning::util::wakers::Future>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_FutureZ_free(_res: CVec_FutureZ) { }
impl Drop for CVec_FutureZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_FutureZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_OffersMessageDecodeErrorZ
pub union CResult_OffersMessageDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::offers::OffersMessage,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OffersMessageDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::offers::OffersMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OffersMessageDecodeErrorZ {
	/// The contents of this CResult_OffersMessageDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OffersMessageDecodeErrorZPtr,
	/// Whether this CResult_OffersMessageDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OffersMessageDecodeErrorZ in the success state.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_ok(o: crate::lightning::onion_message::offers::OffersMessage) -> CResult_OffersMessageDecodeErrorZ {
	CResult_OffersMessageDecodeErrorZ {
		contents: CResult_OffersMessageDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OffersMessageDecodeErrorZ in the error state.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OffersMessageDecodeErrorZ {
	CResult_OffersMessageDecodeErrorZ {
		contents: CResult_OffersMessageDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_is_ok(o: &CResult_OffersMessageDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OffersMessageDecodeErrorZ.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_free(_res: CResult_OffersMessageDecodeErrorZ) { }
impl Drop for CResult_OffersMessageDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::offers::OffersMessage, crate::lightning::ln::msgs::DecodeError>> for CResult_OffersMessageDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::offers::OffersMessage, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OffersMessageDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OffersMessageDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OffersMessageDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OffersMessageDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::onion_message::offers::OffersMessage>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OffersMessageDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OffersMessageDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OffersMessageDecodeErrorZ_clone(orig: &CResult_OffersMessageDecodeErrorZ) -> CResult_OffersMessageDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::ln::chan_utils::HTLCClaim or not
pub enum COption_HTLCClaimZ {
	/// When we're in this state, this COption_HTLCClaimZ contains a crate::lightning::ln::chan_utils::HTLCClaim
	Some(crate::lightning::ln::chan_utils::HTLCClaim),
	/// When we're in this state, this COption_HTLCClaimZ contains nothing
	None
}
impl COption_HTLCClaimZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::ln::chan_utils::HTLCClaim {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_HTLCClaimZ containing a crate::lightning::ln::chan_utils::HTLCClaim
pub extern "C" fn COption_HTLCClaimZ_some(o: crate::lightning::ln::chan_utils::HTLCClaim) -> COption_HTLCClaimZ {
	COption_HTLCClaimZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_HTLCClaimZ containing nothing
pub extern "C" fn COption_HTLCClaimZ_none() -> COption_HTLCClaimZ {
	COption_HTLCClaimZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::ln::chan_utils::HTLCClaim, if we are in the Some state
pub extern "C" fn COption_HTLCClaimZ_free(_res: COption_HTLCClaimZ) { }
#[repr(C)]
/// The contents of CResult_CounterpartyCommitmentSecretsDecodeErrorZ
pub union CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	/// The contents of this CResult_CounterpartyCommitmentSecretsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr,
	/// Whether this CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the success state.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets) -> CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
		contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the error state.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
		contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(o: &CResult_CounterpartyCommitmentSecretsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CounterpartyCommitmentSecretsDecodeErrorZ.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(_res: CResult_CounterpartyCommitmentSecretsDecodeErrorZ) { }
impl Drop for CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets, crate::lightning::ln::msgs::DecodeError>> for CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CounterpartyCommitmentSecretsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(orig: &CResult_CounterpartyCommitmentSecretsDecodeErrorZ) -> CResult_CounterpartyCommitmentSecretsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxCreationKeysDecodeErrorZ
pub union CResult_TxCreationKeysDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::TxCreationKeys,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxCreationKeysDecodeErrorZ {
	/// The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxCreationKeysDecodeErrorZPtr,
	/// Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::TxCreationKeys) -> CResult_TxCreationKeysDecodeErrorZ {
	CResult_TxCreationKeysDecodeErrorZ {
		contents: CResult_TxCreationKeysDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TxCreationKeysDecodeErrorZ {
	CResult_TxCreationKeysDecodeErrorZ {
		contents: CResult_TxCreationKeysDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_is_ok(o: &CResult_TxCreationKeysDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_free(_res: CResult_TxCreationKeysDecodeErrorZ) { }
impl Drop for CResult_TxCreationKeysDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TxCreationKeys, crate::lightning::ln::msgs::DecodeError>> for CResult_TxCreationKeysDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TxCreationKeys, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxCreationKeysDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxCreationKeysDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxCreationKeysDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxCreationKeysDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::TxCreationKeys>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxCreationKeysDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxCreationKeysDecodeErrorZ_clone(orig: &CResult_TxCreationKeysDecodeErrorZ) -> CResult_TxCreationKeysDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelPublicKeysDecodeErrorZ
pub union CResult_ChannelPublicKeysDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::ChannelPublicKeys,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelPublicKeysDecodeErrorZ {
	/// The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelPublicKeysDecodeErrorZPtr,
	/// Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::ChannelPublicKeys) -> CResult_ChannelPublicKeysDecodeErrorZ {
	CResult_ChannelPublicKeysDecodeErrorZ {
		contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelPublicKeysDecodeErrorZ {
	CResult_ChannelPublicKeysDecodeErrorZ {
		contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o: &CResult_ChannelPublicKeysDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_free(_res: CResult_ChannelPublicKeysDecodeErrorZ) { }
impl Drop for CResult_ChannelPublicKeysDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelPublicKeys, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelPublicKeysDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelPublicKeys, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelPublicKeysDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelPublicKeysDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelPublicKeysDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::ChannelPublicKeys>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelPublicKeysDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelPublicKeysDecodeErrorZ_clone(orig: &CResult_ChannelPublicKeysDecodeErrorZ) -> CResult_ChannelPublicKeysDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
pub union CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::HTLCOutputInCommitment,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HTLCOutputInCommitmentDecodeErrorZ {
	/// The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr,
	/// Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::HTLCOutputInCommitment) -> CResult_HTLCOutputInCommitmentDecodeErrorZ {
	CResult_HTLCOutputInCommitmentDecodeErrorZ {
		contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HTLCOutputInCommitmentDecodeErrorZ {
	CResult_HTLCOutputInCommitmentDecodeErrorZ {
		contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o: &CResult_HTLCOutputInCommitmentDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res: CResult_HTLCOutputInCommitmentDecodeErrorZ) { }
impl Drop for CResult_HTLCOutputInCommitmentDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HTLCOutputInCommitment, crate::lightning::ln::msgs::DecodeError>> for CResult_HTLCOutputInCommitmentDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HTLCOutputInCommitment, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HTLCOutputInCommitmentDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HTLCOutputInCommitmentDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HTLCOutputInCommitmentDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::HTLCOutputInCommitment>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HTLCOutputInCommitmentDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig: &CResult_HTLCOutputInCommitmentDecodeErrorZ) -> CResult_HTLCOutputInCommitmentDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
pub union CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	/// The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr,
	/// Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters) -> CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
		contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
		contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o: &CResult_CounterpartyChannelTransactionParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res: CResult_CounterpartyChannelTransactionParametersDecodeErrorZ) { }
impl Drop for CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig: &CResult_CounterpartyChannelTransactionParametersDecodeErrorZ) -> CResult_CounterpartyChannelTransactionParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ChannelTransactionParametersDecodeErrorZ
pub union CResult_ChannelTransactionParametersDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::ChannelTransactionParameters,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ChannelTransactionParametersDecodeErrorZ {
	/// The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ChannelTransactionParametersDecodeErrorZPtr,
	/// Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::ChannelTransactionParameters) -> CResult_ChannelTransactionParametersDecodeErrorZ {
	CResult_ChannelTransactionParametersDecodeErrorZ {
		contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ChannelTransactionParametersDecodeErrorZ {
	CResult_ChannelTransactionParametersDecodeErrorZ {
		contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o: &CResult_ChannelTransactionParametersDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_free(_res: CResult_ChannelTransactionParametersDecodeErrorZ) { }
impl Drop for CResult_ChannelTransactionParametersDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>> for CResult_ChannelTransactionParametersDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::ChannelTransactionParameters, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ChannelTransactionParametersDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ChannelTransactionParametersDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ChannelTransactionParametersDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::ChannelTransactionParameters>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ChannelTransactionParametersDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig: &CResult_ChannelTransactionParametersDecodeErrorZ) -> CResult_ChannelTransactionParametersDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
pub union CResult_HolderCommitmentTransactionDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::HolderCommitmentTransaction,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HolderCommitmentTransactionDecodeErrorZ {
	/// The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr,
	/// Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::HolderCommitmentTransaction) -> CResult_HolderCommitmentTransactionDecodeErrorZ {
	CResult_HolderCommitmentTransactionDecodeErrorZ {
		contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HolderCommitmentTransactionDecodeErrorZ {
	CResult_HolderCommitmentTransactionDecodeErrorZ {
		contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o: &CResult_HolderCommitmentTransactionDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res: CResult_HolderCommitmentTransactionDecodeErrorZ) { }
impl Drop for CResult_HolderCommitmentTransactionDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HolderCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>> for CResult_HolderCommitmentTransactionDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::HolderCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HolderCommitmentTransactionDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HolderCommitmentTransactionDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HolderCommitmentTransactionDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::HolderCommitmentTransaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HolderCommitmentTransactionDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig: &CResult_HolderCommitmentTransactionDecodeErrorZ) -> CResult_HolderCommitmentTransactionDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
pub union CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::BuiltCommitmentTransaction,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BuiltCommitmentTransactionDecodeErrorZ {
	/// The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr,
	/// Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::BuiltCommitmentTransaction) -> CResult_BuiltCommitmentTransactionDecodeErrorZ {
	CResult_BuiltCommitmentTransactionDecodeErrorZ {
		contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BuiltCommitmentTransactionDecodeErrorZ {
	CResult_BuiltCommitmentTransactionDecodeErrorZ {
		contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o: &CResult_BuiltCommitmentTransactionDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res: CResult_BuiltCommitmentTransactionDecodeErrorZ) { }
impl Drop for CResult_BuiltCommitmentTransactionDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::BuiltCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>> for CResult_BuiltCommitmentTransactionDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::BuiltCommitmentTransaction, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BuiltCommitmentTransactionDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BuiltCommitmentTransactionDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BuiltCommitmentTransactionDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::BuiltCommitmentTransaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BuiltCommitmentTransactionDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig: &CResult_BuiltCommitmentTransactionDecodeErrorZ) -> CResult_BuiltCommitmentTransactionDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TrustedClosingTransactionNoneZ
pub union CResult_TrustedClosingTransactionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::TrustedClosingTransaction,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TrustedClosingTransactionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TrustedClosingTransaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TrustedClosingTransactionNoneZ {
	/// The contents of this CResult_TrustedClosingTransactionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TrustedClosingTransactionNoneZPtr,
	/// Whether this CResult_TrustedClosingTransactionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_ok(o: crate::lightning::ln::chan_utils::TrustedClosingTransaction) -> CResult_TrustedClosingTransactionNoneZ {
	CResult_TrustedClosingTransactionNoneZ {
		contents: CResult_TrustedClosingTransactionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_err() -> CResult_TrustedClosingTransactionNoneZ {
	CResult_TrustedClosingTransactionNoneZ {
		contents: CResult_TrustedClosingTransactionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_is_ok(o: &CResult_TrustedClosingTransactionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TrustedClosingTransactionNoneZ.
pub extern "C" fn CResult_TrustedClosingTransactionNoneZ_free(_res: CResult_TrustedClosingTransactionNoneZ) { }
impl Drop for CResult_TrustedClosingTransactionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedClosingTransaction, ()>> for CResult_TrustedClosingTransactionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedClosingTransaction, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TrustedClosingTransactionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TrustedClosingTransactionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_CommitmentTransactionDecodeErrorZ
pub union CResult_CommitmentTransactionDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::CommitmentTransaction,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CommitmentTransactionDecodeErrorZ {
	/// The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CommitmentTransactionDecodeErrorZPtr,
	/// Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_ok(o: crate::lightning::ln::chan_utils::CommitmentTransaction) -> CResult_CommitmentTransactionDecodeErrorZ {
	CResult_CommitmentTransactionDecodeErrorZ {
		contents: CResult_CommitmentTransactionDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_CommitmentTransactionDecodeErrorZ {
	CResult_CommitmentTransactionDecodeErrorZ {
		contents: CResult_CommitmentTransactionDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_is_ok(o: &CResult_CommitmentTransactionDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_free(_res: CResult_CommitmentTransactionDecodeErrorZ) { }
impl Drop for CResult_CommitmentTransactionDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CommitmentTransaction, crate::lightning::ln::msgs::DecodeError>> for CResult_CommitmentTransactionDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::CommitmentTransaction, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CommitmentTransactionDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_CommitmentTransactionDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CommitmentTransactionDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CommitmentTransactionDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::chan_utils::CommitmentTransaction>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CommitmentTransactionDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CommitmentTransactionDecodeErrorZ_clone(orig: &CResult_CommitmentTransactionDecodeErrorZ) -> CResult_CommitmentTransactionDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TrustedCommitmentTransactionNoneZ
pub union CResult_TrustedCommitmentTransactionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::chan_utils::TrustedCommitmentTransaction,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TrustedCommitmentTransactionNoneZ {
	/// The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TrustedCommitmentTransactionNoneZPtr,
	/// Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_ok(o: crate::lightning::ln::chan_utils::TrustedCommitmentTransaction) -> CResult_TrustedCommitmentTransactionNoneZ {
	CResult_TrustedCommitmentTransactionNoneZ {
		contents: CResult_TrustedCommitmentTransactionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_err() -> CResult_TrustedCommitmentTransactionNoneZ {
	CResult_TrustedCommitmentTransactionNoneZ {
		contents: CResult_TrustedCommitmentTransactionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_is_ok(o: &CResult_TrustedCommitmentTransactionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
pub extern "C" fn CResult_TrustedCommitmentTransactionNoneZ_free(_res: CResult_TrustedCommitmentTransactionNoneZ) { }
impl Drop for CResult_TrustedCommitmentTransactionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedCommitmentTransaction, ()>> for CResult_TrustedCommitmentTransactionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::chan_utils::TrustedCommitmentTransaction, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TrustedCommitmentTransactionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TrustedCommitmentTransactionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_CVec_ECDSASignatureZNoneZ
pub union CResult_CVec_ECDSASignatureZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::CVec_ECDSASignatureZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_CVec_ECDSASignatureZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::CVec_ECDSASignatureZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_CVec_ECDSASignatureZNoneZ {
	/// The contents of this CResult_CVec_ECDSASignatureZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_CVec_ECDSASignatureZNoneZPtr,
	/// Whether this CResult_CVec_ECDSASignatureZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_CVec_ECDSASignatureZNoneZ in the success state.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_ok(o: crate::c_types::derived::CVec_ECDSASignatureZ) -> CResult_CVec_ECDSASignatureZNoneZ {
	CResult_CVec_ECDSASignatureZNoneZ {
		contents: CResult_CVec_ECDSASignatureZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_ECDSASignatureZNoneZ in the error state.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_err() -> CResult_CVec_ECDSASignatureZNoneZ {
	CResult_CVec_ECDSASignatureZNoneZ {
		contents: CResult_CVec_ECDSASignatureZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_is_ok(o: &CResult_CVec_ECDSASignatureZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_CVec_ECDSASignatureZNoneZ.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_free(_res: CResult_CVec_ECDSASignatureZNoneZ) { }
impl Drop for CResult_CVec_ECDSASignatureZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::CVec_ECDSASignatureZ, ()>> for CResult_CVec_ECDSASignatureZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::CVec_ECDSASignatureZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_CVec_ECDSASignatureZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_CVec_ECDSASignatureZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_CVec_ECDSASignatureZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_CVec_ECDSASignatureZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::CVec_ECDSASignatureZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_CVec_ECDSASignatureZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_CVec_ECDSASignatureZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_CVec_ECDSASignatureZNoneZ_clone(orig: &CResult_CVec_ECDSASignatureZNoneZ) -> CResult_CVec_ECDSASignatureZNoneZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a usize or not
pub enum COption_usizeZ {
	/// When we're in this state, this COption_usizeZ contains a usize
	Some(usize),
	/// When we're in this state, this COption_usizeZ contains nothing
	None
}
impl COption_usizeZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> usize {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_usizeZ containing a usize
pub extern "C" fn COption_usizeZ_some(o: usize) -> COption_usizeZ {
	COption_usizeZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_usizeZ containing nothing
pub extern "C" fn COption_usizeZ_none() -> COption_usizeZ {
	COption_usizeZ::None
}
#[no_mangle]
/// Frees any resources associated with the usize, if we are in the Some state
pub extern "C" fn COption_usizeZ_free(_res: COption_usizeZ) { }
#[no_mangle]
/// Creates a new COption_usizeZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_usizeZ_clone(orig: &COption_usizeZ) -> COption_usizeZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownScriptDecodeErrorZ
pub union CResult_ShutdownScriptDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::script::ShutdownScript,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ShutdownScriptDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownScriptDecodeErrorZ {
	/// The contents of this CResult_ShutdownScriptDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownScriptDecodeErrorZPtr,
	/// Whether this CResult_ShutdownScriptDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_ok(o: crate::lightning::ln::script::ShutdownScript) -> CResult_ShutdownScriptDecodeErrorZ {
	CResult_ShutdownScriptDecodeErrorZ {
		contents: CResult_ShutdownScriptDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ShutdownScriptDecodeErrorZ {
	CResult_ShutdownScriptDecodeErrorZ {
		contents: CResult_ShutdownScriptDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_is_ok(o: &CResult_ShutdownScriptDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownScriptDecodeErrorZ.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_free(_res: CResult_ShutdownScriptDecodeErrorZ) { }
impl Drop for CResult_ShutdownScriptDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::msgs::DecodeError>> for CResult_ShutdownScriptDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownScriptDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ShutdownScriptDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownScriptDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownScriptDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::script::ShutdownScript>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownScriptDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownScriptDecodeErrorZ_clone(orig: &CResult_ShutdownScriptDecodeErrorZ) -> CResult_ShutdownScriptDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ShutdownScriptInvalidShutdownScriptZ
pub union CResult_ShutdownScriptInvalidShutdownScriptZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::script::ShutdownScript,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::script::InvalidShutdownScript,
}
#[repr(C)]
/// A CResult_ShutdownScriptInvalidShutdownScriptZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::script::InvalidShutdownScript on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ShutdownScriptInvalidShutdownScriptZ {
	/// The contents of this CResult_ShutdownScriptInvalidShutdownScriptZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr,
	/// Whether this CResult_ShutdownScriptInvalidShutdownScriptZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o: crate::lightning::ln::script::ShutdownScript) -> CResult_ShutdownScriptInvalidShutdownScriptZ {
	CResult_ShutdownScriptInvalidShutdownScriptZ {
		contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_err(e: crate::lightning::ln::script::InvalidShutdownScript) -> CResult_ShutdownScriptInvalidShutdownScriptZ {
	CResult_ShutdownScriptInvalidShutdownScriptZ {
		contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o: &CResult_ShutdownScriptInvalidShutdownScriptZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ShutdownScriptInvalidShutdownScriptZ.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res: CResult_ShutdownScriptInvalidShutdownScriptZ) { }
impl Drop for CResult_ShutdownScriptInvalidShutdownScriptZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::script::InvalidShutdownScript>> for CResult_ShutdownScriptInvalidShutdownScriptZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::script::ShutdownScript, crate::lightning::ln::script::InvalidShutdownScript>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ShutdownScriptInvalidShutdownScriptZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ShutdownScriptInvalidShutdownScriptZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ShutdownScriptInvalidShutdownScriptZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::script::ShutdownScript>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ShutdownScriptInvalidShutdownScriptZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::script::InvalidShutdownScript>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig: &CResult_ShutdownScriptInvalidShutdownScriptZ) -> CResult_ShutdownScriptInvalidShutdownScriptZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PaymentPurposeDecodeErrorZ
pub union CResult_PaymentPurposeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::PaymentPurpose,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentPurposeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::events::PaymentPurpose on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentPurposeDecodeErrorZ {
	/// The contents of this CResult_PaymentPurposeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentPurposeDecodeErrorZPtr,
	/// Whether this CResult_PaymentPurposeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentPurposeDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_ok(o: crate::lightning::events::PaymentPurpose) -> CResult_PaymentPurposeDecodeErrorZ {
	CResult_PaymentPurposeDecodeErrorZ {
		contents: CResult_PaymentPurposeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentPurposeDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentPurposeDecodeErrorZ {
	CResult_PaymentPurposeDecodeErrorZ {
		contents: CResult_PaymentPurposeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_is_ok(o: &CResult_PaymentPurposeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentPurposeDecodeErrorZ.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_free(_res: CResult_PaymentPurposeDecodeErrorZ) { }
impl Drop for CResult_PaymentPurposeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::PaymentPurpose, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentPurposeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::PaymentPurpose, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentPurposeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentPurposeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentPurposeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentPurposeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::PaymentPurpose>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentPurposeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentPurposeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentPurposeDecodeErrorZ_clone(orig: &CResult_PaymentPurposeDecodeErrorZ) -> CResult_PaymentPurposeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_ClaimedHTLCDecodeErrorZ
pub union CResult_ClaimedHTLCDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::ClaimedHTLC,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_ClaimedHTLCDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::events::ClaimedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_ClaimedHTLCDecodeErrorZ {
	/// The contents of this CResult_ClaimedHTLCDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_ClaimedHTLCDecodeErrorZPtr,
	/// Whether this CResult_ClaimedHTLCDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_ClaimedHTLCDecodeErrorZ in the success state.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_ok(o: crate::lightning::events::ClaimedHTLC) -> CResult_ClaimedHTLCDecodeErrorZ {
	CResult_ClaimedHTLCDecodeErrorZ {
		contents: CResult_ClaimedHTLCDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_ClaimedHTLCDecodeErrorZ in the error state.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_ClaimedHTLCDecodeErrorZ {
	CResult_ClaimedHTLCDecodeErrorZ {
		contents: CResult_ClaimedHTLCDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_is_ok(o: &CResult_ClaimedHTLCDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_ClaimedHTLCDecodeErrorZ.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_free(_res: CResult_ClaimedHTLCDecodeErrorZ) { }
impl Drop for CResult_ClaimedHTLCDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::ClaimedHTLC, crate::lightning::ln::msgs::DecodeError>> for CResult_ClaimedHTLCDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::ClaimedHTLC, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_ClaimedHTLCDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_ClaimedHTLCDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_ClaimedHTLCDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_ClaimedHTLCDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::ClaimedHTLC>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_ClaimedHTLCDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_ClaimedHTLCDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_ClaimedHTLCDecodeErrorZ_clone(orig: &CResult_ClaimedHTLCDecodeErrorZ) -> CResult_ClaimedHTLCDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::PathFailure or not
pub enum COption_PathFailureZ {
	/// When we're in this state, this COption_PathFailureZ contains a crate::lightning::events::PathFailure
	Some(crate::lightning::events::PathFailure),
	/// When we're in this state, this COption_PathFailureZ contains nothing
	None
}
impl COption_PathFailureZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::PathFailure {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_PathFailureZ containing a crate::lightning::events::PathFailure
pub extern "C" fn COption_PathFailureZ_some(o: crate::lightning::events::PathFailure) -> COption_PathFailureZ {
	COption_PathFailureZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_PathFailureZ containing nothing
pub extern "C" fn COption_PathFailureZ_none() -> COption_PathFailureZ {
	COption_PathFailureZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::PathFailure, if we are in the Some state
pub extern "C" fn COption_PathFailureZ_free(_res: COption_PathFailureZ) { }
#[no_mangle]
/// Creates a new COption_PathFailureZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_PathFailureZ_clone(orig: &COption_PathFailureZ) -> COption_PathFailureZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_PathFailureZDecodeErrorZ
pub union CResult_COption_PathFailureZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_PathFailureZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_PathFailureZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_PathFailureZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_PathFailureZDecodeErrorZ {
	/// The contents of this CResult_COption_PathFailureZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_PathFailureZDecodeErrorZPtr,
	/// Whether this CResult_COption_PathFailureZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_PathFailureZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_ok(o: crate::c_types::derived::COption_PathFailureZ) -> CResult_COption_PathFailureZDecodeErrorZ {
	CResult_COption_PathFailureZDecodeErrorZ {
		contents: CResult_COption_PathFailureZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_PathFailureZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_PathFailureZDecodeErrorZ {
	CResult_COption_PathFailureZDecodeErrorZ {
		contents: CResult_COption_PathFailureZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_is_ok(o: &CResult_COption_PathFailureZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_PathFailureZDecodeErrorZ.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_free(_res: CResult_COption_PathFailureZDecodeErrorZ) { }
impl Drop for CResult_COption_PathFailureZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_PathFailureZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_PathFailureZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_PathFailureZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_PathFailureZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_PathFailureZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_PathFailureZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_PathFailureZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_PathFailureZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_PathFailureZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_PathFailureZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_PathFailureZDecodeErrorZ_clone(orig: &CResult_COption_PathFailureZDecodeErrorZ) -> CResult_COption_PathFailureZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::ClosureReason or not
pub enum COption_ClosureReasonZ {
	/// When we're in this state, this COption_ClosureReasonZ contains a crate::lightning::events::ClosureReason
	Some(crate::lightning::events::ClosureReason),
	/// When we're in this state, this COption_ClosureReasonZ contains nothing
	None
}
impl COption_ClosureReasonZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::ClosureReason {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_ClosureReasonZ containing a crate::lightning::events::ClosureReason
pub extern "C" fn COption_ClosureReasonZ_some(o: crate::lightning::events::ClosureReason) -> COption_ClosureReasonZ {
	COption_ClosureReasonZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_ClosureReasonZ containing nothing
pub extern "C" fn COption_ClosureReasonZ_none() -> COption_ClosureReasonZ {
	COption_ClosureReasonZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::ClosureReason, if we are in the Some state
pub extern "C" fn COption_ClosureReasonZ_free(_res: COption_ClosureReasonZ) { }
#[no_mangle]
/// Creates a new COption_ClosureReasonZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_ClosureReasonZ_clone(orig: &COption_ClosureReasonZ) -> COption_ClosureReasonZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_ClosureReasonZDecodeErrorZ
pub union CResult_COption_ClosureReasonZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_ClosureReasonZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_ClosureReasonZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_ClosureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_ClosureReasonZDecodeErrorZ {
	/// The contents of this CResult_COption_ClosureReasonZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_ClosureReasonZDecodeErrorZPtr,
	/// Whether this CResult_COption_ClosureReasonZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_ok(o: crate::c_types::derived::COption_ClosureReasonZ) -> CResult_COption_ClosureReasonZDecodeErrorZ {
	CResult_COption_ClosureReasonZDecodeErrorZ {
		contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_ClosureReasonZDecodeErrorZ {
	CResult_COption_ClosureReasonZDecodeErrorZ {
		contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o: &CResult_COption_ClosureReasonZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_ClosureReasonZDecodeErrorZ.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_free(_res: CResult_COption_ClosureReasonZDecodeErrorZ) { }
impl Drop for CResult_COption_ClosureReasonZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_ClosureReasonZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_ClosureReasonZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_ClosureReasonZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_ClosureReasonZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_ClosureReasonZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_ClosureReasonZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_ClosureReasonZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_ClosureReasonZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig: &CResult_COption_ClosureReasonZDecodeErrorZ) -> CResult_COption_ClosureReasonZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::HTLCDestination or not
pub enum COption_HTLCDestinationZ {
	/// When we're in this state, this COption_HTLCDestinationZ contains a crate::lightning::events::HTLCDestination
	Some(crate::lightning::events::HTLCDestination),
	/// When we're in this state, this COption_HTLCDestinationZ contains nothing
	None
}
impl COption_HTLCDestinationZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::HTLCDestination {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_HTLCDestinationZ containing a crate::lightning::events::HTLCDestination
pub extern "C" fn COption_HTLCDestinationZ_some(o: crate::lightning::events::HTLCDestination) -> COption_HTLCDestinationZ {
	COption_HTLCDestinationZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_HTLCDestinationZ containing nothing
pub extern "C" fn COption_HTLCDestinationZ_none() -> COption_HTLCDestinationZ {
	COption_HTLCDestinationZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::HTLCDestination, if we are in the Some state
pub extern "C" fn COption_HTLCDestinationZ_free(_res: COption_HTLCDestinationZ) { }
#[no_mangle]
/// Creates a new COption_HTLCDestinationZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_HTLCDestinationZ_clone(orig: &COption_HTLCDestinationZ) -> COption_HTLCDestinationZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_HTLCDestinationZDecodeErrorZ
pub union CResult_COption_HTLCDestinationZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_HTLCDestinationZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_HTLCDestinationZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_HTLCDestinationZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_HTLCDestinationZDecodeErrorZ {
	/// The contents of this CResult_COption_HTLCDestinationZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr,
	/// Whether this CResult_COption_HTLCDestinationZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_ok(o: crate::c_types::derived::COption_HTLCDestinationZ) -> CResult_COption_HTLCDestinationZDecodeErrorZ {
	CResult_COption_HTLCDestinationZDecodeErrorZ {
		contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_HTLCDestinationZDecodeErrorZ {
	CResult_COption_HTLCDestinationZDecodeErrorZ {
		contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(o: &CResult_COption_HTLCDestinationZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_HTLCDestinationZDecodeErrorZ.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_free(_res: CResult_COption_HTLCDestinationZDecodeErrorZ) { }
impl Drop for CResult_COption_HTLCDestinationZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_HTLCDestinationZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_HTLCDestinationZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_HTLCDestinationZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_HTLCDestinationZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_HTLCDestinationZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_HTLCDestinationZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_HTLCDestinationZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_HTLCDestinationZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_HTLCDestinationZDecodeErrorZ_clone(orig: &CResult_COption_HTLCDestinationZDecodeErrorZ) -> CResult_COption_HTLCDestinationZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PaymentFailureReasonDecodeErrorZ
pub union CResult_PaymentFailureReasonDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::events::PaymentFailureReason,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentFailureReasonDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::events::PaymentFailureReason on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentFailureReasonDecodeErrorZ {
	/// The contents of this CResult_PaymentFailureReasonDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentFailureReasonDecodeErrorZPtr,
	/// Whether this CResult_PaymentFailureReasonDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentFailureReasonDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentFailureReasonDecodeErrorZ_ok(o: crate::lightning::events::PaymentFailureReason) -> CResult_PaymentFailureReasonDecodeErrorZ {
	CResult_PaymentFailureReasonDecodeErrorZ {
		contents: CResult_PaymentFailureReasonDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentFailureReasonDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentFailureReasonDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentFailureReasonDecodeErrorZ {
	CResult_PaymentFailureReasonDecodeErrorZ {
		contents: CResult_PaymentFailureReasonDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentFailureReasonDecodeErrorZ_is_ok(o: &CResult_PaymentFailureReasonDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentFailureReasonDecodeErrorZ.
pub extern "C" fn CResult_PaymentFailureReasonDecodeErrorZ_free(_res: CResult_PaymentFailureReasonDecodeErrorZ) { }
impl Drop for CResult_PaymentFailureReasonDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::events::PaymentFailureReason, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentFailureReasonDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::events::PaymentFailureReason, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentFailureReasonDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentFailureReasonDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentFailureReasonDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentFailureReasonDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::events::PaymentFailureReason>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentFailureReasonDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentFailureReasonDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentFailureReasonDecodeErrorZ_clone(orig: &CResult_PaymentFailureReasonDecodeErrorZ) -> CResult_PaymentFailureReasonDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::c_types::U128 or not
pub enum COption_U128Z {
	/// When we're in this state, this COption_U128Z contains a crate::c_types::U128
	Some(crate::c_types::U128),
	/// When we're in this state, this COption_U128Z contains nothing
	None
}
impl COption_U128Z {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::c_types::U128 {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_U128Z containing a crate::c_types::U128
pub extern "C" fn COption_U128Z_some(o: crate::c_types::U128) -> COption_U128Z {
	COption_U128Z::Some(o)
}
#[no_mangle]
/// Constructs a new COption_U128Z containing nothing
pub extern "C" fn COption_U128Z_none() -> COption_U128Z {
	COption_U128Z::None
}
#[no_mangle]
/// Frees any resources associated with the crate::c_types::U128, if we are in the Some state
pub extern "C" fn COption_U128Z_free(_res: COption_U128Z) { }
#[no_mangle]
/// Creates a new COption_U128Z which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_U128Z_clone(orig: &COption_U128Z) -> COption_U128Z { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::events::ClaimedHTLCs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ClaimedHTLCZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::events::ClaimedHTLC,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ClaimedHTLCZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::events::ClaimedHTLC> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::events::ClaimedHTLC] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::events::ClaimedHTLC>> for CVec_ClaimedHTLCZ {
	fn from(v: Vec<crate::lightning::events::ClaimedHTLC>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ClaimedHTLCZ_free(_res: CVec_ClaimedHTLCZ) { }
impl Drop for CVec_ClaimedHTLCZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ClaimedHTLCZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::PaymentFailureReason or not
pub enum COption_PaymentFailureReasonZ {
	/// When we're in this state, this COption_PaymentFailureReasonZ contains a crate::lightning::events::PaymentFailureReason
	Some(crate::lightning::events::PaymentFailureReason),
	/// When we're in this state, this COption_PaymentFailureReasonZ contains nothing
	None
}
impl COption_PaymentFailureReasonZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::PaymentFailureReason {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_PaymentFailureReasonZ containing a crate::lightning::events::PaymentFailureReason
pub extern "C" fn COption_PaymentFailureReasonZ_some(o: crate::lightning::events::PaymentFailureReason) -> COption_PaymentFailureReasonZ {
	COption_PaymentFailureReasonZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_PaymentFailureReasonZ containing nothing
pub extern "C" fn COption_PaymentFailureReasonZ_none() -> COption_PaymentFailureReasonZ {
	COption_PaymentFailureReasonZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::PaymentFailureReason, if we are in the Some state
pub extern "C" fn COption_PaymentFailureReasonZ_free(_res: COption_PaymentFailureReasonZ) { }
#[no_mangle]
/// Creates a new COption_PaymentFailureReasonZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_PaymentFailureReasonZ_clone(orig: &COption_PaymentFailureReasonZ) -> COption_PaymentFailureReasonZ { Clone::clone(&orig) }
#[repr(C)]
#[derive(Clone)]
/// An enum which can either contain a crate::lightning::events::Event or not
pub enum COption_EventZ {
	/// When we're in this state, this COption_EventZ contains a crate::lightning::events::Event
	Some(crate::lightning::events::Event),
	/// When we're in this state, this COption_EventZ contains nothing
	None
}
impl COption_EventZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::events::Event {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_EventZ containing a crate::lightning::events::Event
pub extern "C" fn COption_EventZ_some(o: crate::lightning::events::Event) -> COption_EventZ {
	COption_EventZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_EventZ containing nothing
pub extern "C" fn COption_EventZ_none() -> COption_EventZ {
	COption_EventZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::events::Event, if we are in the Some state
pub extern "C" fn COption_EventZ_free(_res: COption_EventZ) { }
#[no_mangle]
/// Creates a new COption_EventZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn COption_EventZ_clone(orig: &COption_EventZ) -> COption_EventZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_COption_EventZDecodeErrorZ
pub union CResult_COption_EventZDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::COption_EventZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_COption_EventZDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::COption_EventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_COption_EventZDecodeErrorZ {
	/// The contents of this CResult_COption_EventZDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_COption_EventZDecodeErrorZPtr,
	/// Whether this CResult_COption_EventZDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_ok(o: crate::c_types::derived::COption_EventZ) -> CResult_COption_EventZDecodeErrorZ {
	CResult_COption_EventZDecodeErrorZ {
		contents: CResult_COption_EventZDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_COption_EventZDecodeErrorZ {
	CResult_COption_EventZDecodeErrorZ {
		contents: CResult_COption_EventZDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_is_ok(o: &CResult_COption_EventZDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_COption_EventZDecodeErrorZ.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_free(_res: CResult_COption_EventZDecodeErrorZ) { }
impl Drop for CResult_COption_EventZDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::COption_EventZ, crate::lightning::ln::msgs::DecodeError>> for CResult_COption_EventZDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::COption_EventZ, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_COption_EventZDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_COption_EventZDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_COption_EventZDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_COption_EventZDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::COption_EventZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_COption_EventZDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_COption_EventZDecodeErrorZ_clone(orig: &CResult_COption_EventZDecodeErrorZ) -> CResult_COption_EventZDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SiPrefixBolt11ParseErrorZ
pub union CResult_SiPrefixBolt11ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::SiPrefix,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11ParseError,
}
#[repr(C)]
/// A CResult_SiPrefixBolt11ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::SiPrefix on success and a crate::lightning_invoice::Bolt11ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SiPrefixBolt11ParseErrorZ {
	/// The contents of this CResult_SiPrefixBolt11ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SiPrefixBolt11ParseErrorZPtr,
	/// Whether this CResult_SiPrefixBolt11ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SiPrefixBolt11ParseErrorZ in the success state.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_ok(o: crate::lightning_invoice::SiPrefix) -> CResult_SiPrefixBolt11ParseErrorZ {
	CResult_SiPrefixBolt11ParseErrorZ {
		contents: CResult_SiPrefixBolt11ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SiPrefixBolt11ParseErrorZ in the error state.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_err(e: crate::lightning_invoice::Bolt11ParseError) -> CResult_SiPrefixBolt11ParseErrorZ {
	CResult_SiPrefixBolt11ParseErrorZ {
		contents: CResult_SiPrefixBolt11ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_is_ok(o: &CResult_SiPrefixBolt11ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SiPrefixBolt11ParseErrorZ.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_free(_res: CResult_SiPrefixBolt11ParseErrorZ) { }
impl Drop for CResult_SiPrefixBolt11ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::SiPrefix, crate::lightning_invoice::Bolt11ParseError>> for CResult_SiPrefixBolt11ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::SiPrefix, crate::lightning_invoice::Bolt11ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SiPrefixBolt11ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SiPrefixBolt11ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SiPrefixBolt11ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SiPrefixBolt11ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::SiPrefix>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SiPrefixBolt11ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SiPrefixBolt11ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SiPrefixBolt11ParseErrorZ_clone(orig: &CResult_SiPrefixBolt11ParseErrorZ) -> CResult_SiPrefixBolt11ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceParseOrSemanticErrorZ
pub union CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Bolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::ParseOrSemanticError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceParseOrSemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::ParseOrSemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	/// The contents of this CResult_Bolt11InvoiceParseOrSemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceParseOrSemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_ok(o: crate::lightning_invoice::Bolt11Invoice) -> CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	CResult_Bolt11InvoiceParseOrSemanticErrorZ {
		contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_err(e: crate::lightning_invoice::ParseOrSemanticError) -> CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	CResult_Bolt11InvoiceParseOrSemanticErrorZ {
		contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_is_ok(o: &CResult_Bolt11InvoiceParseOrSemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceParseOrSemanticErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_free(_res: CResult_Bolt11InvoiceParseOrSemanticErrorZ) { }
impl Drop for CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::ParseOrSemanticError>> for CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::ParseOrSemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceParseOrSemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceParseOrSemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceParseOrSemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::ParseOrSemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone(orig: &CResult_Bolt11InvoiceParseOrSemanticErrorZ) -> CResult_Bolt11InvoiceParseOrSemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ
pub union CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::SignedRawBolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11ParseError,
}
#[repr(C)]
/// A CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::SignedRawBolt11Invoice on success and a crate::lightning_invoice::Bolt11ParseError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	/// The contents of this CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr,
	/// Whether this CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ in the success state.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_ok(o: crate::lightning_invoice::SignedRawBolt11Invoice) -> CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
		contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ in the error state.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_err(e: crate::lightning_invoice::Bolt11ParseError) -> CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
		contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_is_ok(o: &CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_free(_res: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ) { }
impl Drop for CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::SignedRawBolt11Invoice, crate::lightning_invoice::Bolt11ParseError>> for CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::SignedRawBolt11Invoice, crate::lightning_invoice::Bolt11ParseError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::SignedRawBolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11ParseError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone(orig: &CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ) -> CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	/// The element at position 0
	pub a: crate::lightning_invoice::RawBolt11Invoice,
	/// The element at position 1
	pub b: crate::c_types::ThirtyTwoBytes,
	/// The element at position 2
	pub c: crate::lightning_invoice::Bolt11InvoiceSignature,
}
impl From<(crate::lightning_invoice::RawBolt11Invoice, crate::c_types::ThirtyTwoBytes, crate::lightning_invoice::Bolt11InvoiceSignature)> for C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	fn from (tup: (crate::lightning_invoice::RawBolt11Invoice, crate::c_types::ThirtyTwoBytes, crate::lightning_invoice::Bolt11InvoiceSignature)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning_invoice::RawBolt11Invoice, crate::c_types::ThirtyTwoBytes, crate::lightning_invoice::Bolt11InvoiceSignature) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone(orig: &C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ) -> C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_new(a: crate::lightning_invoice::RawBolt11Invoice, b: crate::c_types::ThirtyTwoBytes, c: crate::lightning_invoice::Bolt11InvoiceSignature) -> C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
	C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ.
pub extern "C" fn C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_free(_res: C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ) { }
#[repr(C)]
/// The contents of CResult_PayeePubKeySecp256k1ErrorZ
pub union CResult_PayeePubKeySecp256k1ErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::PayeePubKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::Secp256k1Error,
}
#[repr(C)]
/// A CResult_PayeePubKeySecp256k1ErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PayeePubKeySecp256k1ErrorZ {
	/// The contents of this CResult_PayeePubKeySecp256k1ErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PayeePubKeySecp256k1ErrorZPtr,
	/// Whether this CResult_PayeePubKeySecp256k1ErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PayeePubKeySecp256k1ErrorZ in the success state.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_ok(o: crate::lightning_invoice::PayeePubKey) -> CResult_PayeePubKeySecp256k1ErrorZ {
	CResult_PayeePubKeySecp256k1ErrorZ {
		contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PayeePubKeySecp256k1ErrorZ in the error state.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_err(e: crate::c_types::Secp256k1Error) -> CResult_PayeePubKeySecp256k1ErrorZ {
	CResult_PayeePubKeySecp256k1ErrorZ {
		contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_is_ok(o: &CResult_PayeePubKeySecp256k1ErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PayeePubKeySecp256k1ErrorZ.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_free(_res: CResult_PayeePubKeySecp256k1ErrorZ) { }
impl Drop for CResult_PayeePubKeySecp256k1ErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::PayeePubKey, crate::c_types::Secp256k1Error>> for CResult_PayeePubKeySecp256k1ErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::PayeePubKey, crate::c_types::Secp256k1Error>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PayeePubKeySecp256k1ErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PayeePubKeySecp256k1ErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PayeePubKeySecp256k1ErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::PayeePubKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PayeePubKeySecp256k1ErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::Secp256k1Error>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PayeePubKeySecp256k1ErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PayeePubKeySecp256k1ErrorZ_clone(orig: &CResult_PayeePubKeySecp256k1ErrorZ) -> CResult_PayeePubKeySecp256k1ErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_PrivateRouteZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning_invoice::PrivateRoute,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_PrivateRouteZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning_invoice::PrivateRoute> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning_invoice::PrivateRoute] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning_invoice::PrivateRoute>> for CVec_PrivateRouteZ {
	fn from(v: Vec<crate::lightning_invoice::PrivateRoute>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_PrivateRouteZ_free(_res: CVec_PrivateRouteZ) { }
impl Drop for CVec_PrivateRouteZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_PrivateRouteZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_PositiveTimestampCreationErrorZ
pub union CResult_PositiveTimestampCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::PositiveTimestamp,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::CreationError,
}
#[repr(C)]
/// A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PositiveTimestampCreationErrorZ {
	/// The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PositiveTimestampCreationErrorZPtr,
	/// Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_ok(o: crate::lightning_invoice::PositiveTimestamp) -> CResult_PositiveTimestampCreationErrorZ {
	CResult_PositiveTimestampCreationErrorZ {
		contents: CResult_PositiveTimestampCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_err(e: crate::lightning_invoice::CreationError) -> CResult_PositiveTimestampCreationErrorZ {
	CResult_PositiveTimestampCreationErrorZ {
		contents: CResult_PositiveTimestampCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_is_ok(o: &CResult_PositiveTimestampCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_free(_res: CResult_PositiveTimestampCreationErrorZ) { }
impl Drop for CResult_PositiveTimestampCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::PositiveTimestamp, crate::lightning_invoice::CreationError>> for CResult_PositiveTimestampCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::PositiveTimestamp, crate::lightning_invoice::CreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PositiveTimestampCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PositiveTimestampCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PositiveTimestampCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PositiveTimestampCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::PositiveTimestamp>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PositiveTimestampCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::CreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PositiveTimestampCreationErrorZ_clone(orig: &CResult_PositiveTimestampCreationErrorZ) -> CResult_PositiveTimestampCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_NoneBolt11SemanticErrorZ
pub union CResult_NoneBolt11SemanticErrorZPtr {
	/// Note that this value is always NULL, as there are no contents in the OK variant
	pub result: *mut core::ffi::c_void,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11SemanticError,
}
#[repr(C)]
/// A CResult_NoneBolt11SemanticErrorZ represents the result of a fallible operation,
/// containing a () on success and a crate::lightning_invoice::Bolt11SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_NoneBolt11SemanticErrorZ {
	/// The contents of this CResult_NoneBolt11SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_NoneBolt11SemanticErrorZPtr,
	/// Whether this CResult_NoneBolt11SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_NoneBolt11SemanticErrorZ in the success state.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_ok() -> CResult_NoneBolt11SemanticErrorZ {
	CResult_NoneBolt11SemanticErrorZ {
		contents: CResult_NoneBolt11SemanticErrorZPtr {
			result: core::ptr::null_mut(),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt11SemanticErrorZ in the error state.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_err(e: crate::lightning_invoice::Bolt11SemanticError) -> CResult_NoneBolt11SemanticErrorZ {
	CResult_NoneBolt11SemanticErrorZ {
		contents: CResult_NoneBolt11SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_is_ok(o: &CResult_NoneBolt11SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_NoneBolt11SemanticErrorZ.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_free(_res: CResult_NoneBolt11SemanticErrorZ) { }
impl Drop for CResult_NoneBolt11SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<(), crate::lightning_invoice::Bolt11SemanticError>> for CResult_NoneBolt11SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<(), crate::lightning_invoice::Bolt11SemanticError>) -> Self {
		let contents = if o.result_ok {
			let _ = unsafe { Box::from_raw(o.contents.result) };
			o.contents.result = core::ptr::null_mut();
			CResult_NoneBolt11SemanticErrorZPtr { result: core::ptr::null_mut() }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_NoneBolt11SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_NoneBolt11SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_NoneBolt11SemanticErrorZPtr {
				result: core::ptr::null_mut()
			} }
		} else {
			Self { result_ok: false, contents: CResult_NoneBolt11SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_NoneBolt11SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_NoneBolt11SemanticErrorZ_clone(orig: &CResult_NoneBolt11SemanticErrorZ) -> CResult_NoneBolt11SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_Bolt11InvoiceBolt11SemanticErrorZ
pub union CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Bolt11Invoice,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::Bolt11SemanticError,
}
#[repr(C)]
/// A CResult_Bolt11InvoiceBolt11SemanticErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::Bolt11SemanticError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	/// The contents of this CResult_Bolt11InvoiceBolt11SemanticErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr,
	/// Whether this CResult_Bolt11InvoiceBolt11SemanticErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ in the success state.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_ok(o: crate::lightning_invoice::Bolt11Invoice) -> CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	CResult_Bolt11InvoiceBolt11SemanticErrorZ {
		contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ in the error state.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_err(e: crate::lightning_invoice::Bolt11SemanticError) -> CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	CResult_Bolt11InvoiceBolt11SemanticErrorZ {
		contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_is_ok(o: &CResult_Bolt11InvoiceBolt11SemanticErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_Bolt11InvoiceBolt11SemanticErrorZ.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_free(_res: CResult_Bolt11InvoiceBolt11SemanticErrorZ) { }
impl Drop for CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::Bolt11SemanticError>> for CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Bolt11Invoice, crate::lightning_invoice::Bolt11SemanticError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_Bolt11InvoiceBolt11SemanticErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_Bolt11InvoiceBolt11SemanticErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_Bolt11InvoiceBolt11SemanticErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11Invoice>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::Bolt11SemanticError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone(orig: &CResult_Bolt11InvoiceBolt11SemanticErrorZ) -> CResult_Bolt11InvoiceBolt11SemanticErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DescriptionCreationErrorZ
pub union CResult_DescriptionCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::Description,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::CreationError,
}
#[repr(C)]
/// A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DescriptionCreationErrorZ {
	/// The contents of this CResult_DescriptionCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DescriptionCreationErrorZPtr,
	/// Whether this CResult_DescriptionCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DescriptionCreationErrorZ in the success state.
pub extern "C" fn CResult_DescriptionCreationErrorZ_ok(o: crate::lightning_invoice::Description) -> CResult_DescriptionCreationErrorZ {
	CResult_DescriptionCreationErrorZ {
		contents: CResult_DescriptionCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DescriptionCreationErrorZ in the error state.
pub extern "C" fn CResult_DescriptionCreationErrorZ_err(e: crate::lightning_invoice::CreationError) -> CResult_DescriptionCreationErrorZ {
	CResult_DescriptionCreationErrorZ {
		contents: CResult_DescriptionCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DescriptionCreationErrorZ_is_ok(o: &CResult_DescriptionCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DescriptionCreationErrorZ.
pub extern "C" fn CResult_DescriptionCreationErrorZ_free(_res: CResult_DescriptionCreationErrorZ) { }
impl Drop for CResult_DescriptionCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::Description, crate::lightning_invoice::CreationError>> for CResult_DescriptionCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::Description, crate::lightning_invoice::CreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DescriptionCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DescriptionCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DescriptionCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DescriptionCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::Description>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DescriptionCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::CreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DescriptionCreationErrorZ_clone(orig: &CResult_DescriptionCreationErrorZ) -> CResult_DescriptionCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PrivateRouteCreationErrorZ
pub union CResult_PrivateRouteCreationErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning_invoice::PrivateRoute,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning_invoice::CreationError,
}
#[repr(C)]
/// A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
/// containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PrivateRouteCreationErrorZ {
	/// The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PrivateRouteCreationErrorZPtr,
	/// Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_ok(o: crate::lightning_invoice::PrivateRoute) -> CResult_PrivateRouteCreationErrorZ {
	CResult_PrivateRouteCreationErrorZ {
		contents: CResult_PrivateRouteCreationErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_err(e: crate::lightning_invoice::CreationError) -> CResult_PrivateRouteCreationErrorZ {
	CResult_PrivateRouteCreationErrorZ {
		contents: CResult_PrivateRouteCreationErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_is_ok(o: &CResult_PrivateRouteCreationErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_free(_res: CResult_PrivateRouteCreationErrorZ) { }
impl Drop for CResult_PrivateRouteCreationErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning_invoice::PrivateRoute, crate::lightning_invoice::CreationError>> for CResult_PrivateRouteCreationErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning_invoice::PrivateRoute, crate::lightning_invoice::CreationError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PrivateRouteCreationErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PrivateRouteCreationErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PrivateRouteCreationErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PrivateRouteCreationErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning_invoice::PrivateRoute>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PrivateRouteCreationErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning_invoice::CreationError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PrivateRouteCreationErrorZ_clone(orig: &CResult_PrivateRouteCreationErrorZ) -> CResult_PrivateRouteCreationErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_OutPointDecodeErrorZ
pub union CResult_OutPointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::transaction::OutPoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_OutPointDecodeErrorZ {
	/// The contents of this CResult_OutPointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_OutPointDecodeErrorZPtr,
	/// Whether this CResult_OutPointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_OutPointDecodeErrorZ in the success state.
pub extern "C" fn CResult_OutPointDecodeErrorZ_ok(o: crate::lightning::chain::transaction::OutPoint) -> CResult_OutPointDecodeErrorZ {
	CResult_OutPointDecodeErrorZ {
		contents: CResult_OutPointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_OutPointDecodeErrorZ in the error state.
pub extern "C" fn CResult_OutPointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_OutPointDecodeErrorZ {
	CResult_OutPointDecodeErrorZ {
		contents: CResult_OutPointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_OutPointDecodeErrorZ_is_ok(o: &CResult_OutPointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_OutPointDecodeErrorZ.
pub extern "C" fn CResult_OutPointDecodeErrorZ_free(_res: CResult_OutPointDecodeErrorZ) { }
impl Drop for CResult_OutPointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::msgs::DecodeError>> for CResult_OutPointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::transaction::OutPoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_OutPointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_OutPointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_OutPointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_OutPointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::chain::transaction::OutPoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_OutPointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_OutPointDecodeErrorZ_clone(orig: &CResult_OutPointDecodeErrorZ) -> CResult_OutPointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BigSizeDecodeErrorZ
pub union CResult_BigSizeDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::BigSize,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BigSizeDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::BigSize on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BigSizeDecodeErrorZ {
	/// The contents of this CResult_BigSizeDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BigSizeDecodeErrorZPtr,
	/// Whether this CResult_BigSizeDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BigSizeDecodeErrorZ in the success state.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_ok(o: crate::lightning::util::ser::BigSize) -> CResult_BigSizeDecodeErrorZ {
	CResult_BigSizeDecodeErrorZ {
		contents: CResult_BigSizeDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BigSizeDecodeErrorZ in the error state.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BigSizeDecodeErrorZ {
	CResult_BigSizeDecodeErrorZ {
		contents: CResult_BigSizeDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BigSizeDecodeErrorZ_is_ok(o: &CResult_BigSizeDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BigSizeDecodeErrorZ.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_free(_res: CResult_BigSizeDecodeErrorZ) { }
impl Drop for CResult_BigSizeDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::BigSize, crate::lightning::ln::msgs::DecodeError>> for CResult_BigSizeDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::BigSize, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BigSizeDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BigSizeDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BigSizeDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BigSizeDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::BigSize>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BigSizeDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BigSizeDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BigSizeDecodeErrorZ_clone(orig: &CResult_BigSizeDecodeErrorZ) -> CResult_BigSizeDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HostnameDecodeErrorZ
pub union CResult_HostnameDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::Hostname,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HostnameDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::Hostname on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HostnameDecodeErrorZ {
	/// The contents of this CResult_HostnameDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HostnameDecodeErrorZPtr,
	/// Whether this CResult_HostnameDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HostnameDecodeErrorZ in the success state.
pub extern "C" fn CResult_HostnameDecodeErrorZ_ok(o: crate::lightning::util::ser::Hostname) -> CResult_HostnameDecodeErrorZ {
	CResult_HostnameDecodeErrorZ {
		contents: CResult_HostnameDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HostnameDecodeErrorZ in the error state.
pub extern "C" fn CResult_HostnameDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HostnameDecodeErrorZ {
	CResult_HostnameDecodeErrorZ {
		contents: CResult_HostnameDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HostnameDecodeErrorZ_is_ok(o: &CResult_HostnameDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HostnameDecodeErrorZ.
pub extern "C" fn CResult_HostnameDecodeErrorZ_free(_res: CResult_HostnameDecodeErrorZ) { }
impl Drop for CResult_HostnameDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::Hostname, crate::lightning::ln::msgs::DecodeError>> for CResult_HostnameDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::Hostname, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HostnameDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HostnameDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HostnameDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HostnameDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::Hostname>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HostnameDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HostnameDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HostnameDecodeErrorZ_clone(orig: &CResult_HostnameDecodeErrorZ) -> CResult_HostnameDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TransactionU16LenLimitedNoneZ
pub union CResult_TransactionU16LenLimitedNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::TransactionU16LenLimited,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_TransactionU16LenLimitedNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::TransactionU16LenLimited on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TransactionU16LenLimitedNoneZ {
	/// The contents of this CResult_TransactionU16LenLimitedNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TransactionU16LenLimitedNoneZPtr,
	/// Whether this CResult_TransactionU16LenLimitedNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedNoneZ in the success state.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_ok(o: crate::lightning::util::ser::TransactionU16LenLimited) -> CResult_TransactionU16LenLimitedNoneZ {
	CResult_TransactionU16LenLimitedNoneZ {
		contents: CResult_TransactionU16LenLimitedNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedNoneZ in the error state.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_err() -> CResult_TransactionU16LenLimitedNoneZ {
	CResult_TransactionU16LenLimitedNoneZ {
		contents: CResult_TransactionU16LenLimitedNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_is_ok(o: &CResult_TransactionU16LenLimitedNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TransactionU16LenLimitedNoneZ.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_free(_res: CResult_TransactionU16LenLimitedNoneZ) { }
impl Drop for CResult_TransactionU16LenLimitedNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, ()>> for CResult_TransactionU16LenLimitedNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TransactionU16LenLimitedNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_TransactionU16LenLimitedNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TransactionU16LenLimitedNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TransactionU16LenLimitedNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::TransactionU16LenLimited>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TransactionU16LenLimitedNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TransactionU16LenLimitedNoneZ_clone(orig: &CResult_TransactionU16LenLimitedNoneZ) -> CResult_TransactionU16LenLimitedNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TransactionU16LenLimitedDecodeErrorZ
pub union CResult_TransactionU16LenLimitedDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::ser::TransactionU16LenLimited,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_TransactionU16LenLimitedDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::ser::TransactionU16LenLimited on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TransactionU16LenLimitedDecodeErrorZ {
	/// The contents of this CResult_TransactionU16LenLimitedDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr,
	/// Whether this CResult_TransactionU16LenLimitedDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ in the success state.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_ok(o: crate::lightning::util::ser::TransactionU16LenLimited) -> CResult_TransactionU16LenLimitedDecodeErrorZ {
	CResult_TransactionU16LenLimitedDecodeErrorZ {
		contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ in the error state.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_TransactionU16LenLimitedDecodeErrorZ {
	CResult_TransactionU16LenLimitedDecodeErrorZ {
		contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_is_ok(o: &CResult_TransactionU16LenLimitedDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TransactionU16LenLimitedDecodeErrorZ.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_free(_res: CResult_TransactionU16LenLimitedDecodeErrorZ) { }
impl Drop for CResult_TransactionU16LenLimitedDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, crate::lightning::ln::msgs::DecodeError>> for CResult_TransactionU16LenLimitedDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::ser::TransactionU16LenLimited, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TransactionU16LenLimitedDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TransactionU16LenLimitedDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TransactionU16LenLimitedDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::ser::TransactionU16LenLimited>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TransactionU16LenLimitedDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TransactionU16LenLimitedDecodeErrorZ_clone(orig: &CResult_TransactionU16LenLimitedDecodeErrorZ) -> CResult_TransactionU16LenLimitedDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_UntrustedStringDecodeErrorZ
pub union CResult_UntrustedStringDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::util::string::UntrustedString,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_UntrustedStringDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::util::string::UntrustedString on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_UntrustedStringDecodeErrorZ {
	/// The contents of this CResult_UntrustedStringDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_UntrustedStringDecodeErrorZPtr,
	/// Whether this CResult_UntrustedStringDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_UntrustedStringDecodeErrorZ in the success state.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_ok(o: crate::lightning::util::string::UntrustedString) -> CResult_UntrustedStringDecodeErrorZ {
	CResult_UntrustedStringDecodeErrorZ {
		contents: CResult_UntrustedStringDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_UntrustedStringDecodeErrorZ in the error state.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_UntrustedStringDecodeErrorZ {
	CResult_UntrustedStringDecodeErrorZ {
		contents: CResult_UntrustedStringDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_is_ok(o: &CResult_UntrustedStringDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_UntrustedStringDecodeErrorZ.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_free(_res: CResult_UntrustedStringDecodeErrorZ) { }
impl Drop for CResult_UntrustedStringDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::util::string::UntrustedString, crate::lightning::ln::msgs::DecodeError>> for CResult_UntrustedStringDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::util::string::UntrustedString, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_UntrustedStringDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_UntrustedStringDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_UntrustedStringDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_UntrustedStringDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::util::string::UntrustedString>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_UntrustedStringDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_UntrustedStringDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_UntrustedStringDecodeErrorZ_clone(orig: &CResult_UntrustedStringDecodeErrorZ) -> CResult_UntrustedStringDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple__u832u16Z {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: u16,
}
impl From<(crate::c_types::ThirtyTwoBytes, u16)> for C2Tuple__u832u16Z {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, u16)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple__u832u16Z {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, u16) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple__u832u16Z {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple__u832u16Z_clone(orig: &C2Tuple__u832u16Z) -> C2Tuple__u832u16Z { Clone::clone(&orig) }
/// Creates a new C2Tuple__u832u16Z from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple__u832u16Z_new(a: crate::c_types::ThirtyTwoBytes, b: u16) -> C2Tuple__u832u16Z {
	C2Tuple__u832u16Z { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple__u832u16Z.
pub extern "C" fn C2Tuple__u832u16Z_free(_res: C2Tuple__u832u16Z) { }
#[repr(C)]
/// The contents of CResult_PaymentRelayDecodeErrorZ
pub union CResult_PaymentRelayDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::PaymentRelay,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentRelayDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::PaymentRelay on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentRelayDecodeErrorZ {
	/// The contents of this CResult_PaymentRelayDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentRelayDecodeErrorZPtr,
	/// Whether this CResult_PaymentRelayDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentRelayDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::PaymentRelay) -> CResult_PaymentRelayDecodeErrorZ {
	CResult_PaymentRelayDecodeErrorZ {
		contents: CResult_PaymentRelayDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentRelayDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentRelayDecodeErrorZ {
	CResult_PaymentRelayDecodeErrorZ {
		contents: CResult_PaymentRelayDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_is_ok(o: &CResult_PaymentRelayDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentRelayDecodeErrorZ.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_free(_res: CResult_PaymentRelayDecodeErrorZ) { }
impl Drop for CResult_PaymentRelayDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentRelay, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentRelayDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentRelay, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentRelayDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentRelayDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentRelayDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentRelayDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::PaymentRelay>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentRelayDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentRelayDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentRelayDecodeErrorZ_clone(orig: &CResult_PaymentRelayDecodeErrorZ) -> CResult_PaymentRelayDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_PaymentConstraintsDecodeErrorZ
pub union CResult_PaymentConstraintsDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::payment::PaymentConstraints,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_PaymentConstraintsDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::payment::PaymentConstraints on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PaymentConstraintsDecodeErrorZ {
	/// The contents of this CResult_PaymentConstraintsDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PaymentConstraintsDecodeErrorZPtr,
	/// Whether this CResult_PaymentConstraintsDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PaymentConstraintsDecodeErrorZ in the success state.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_ok(o: crate::lightning::blinded_path::payment::PaymentConstraints) -> CResult_PaymentConstraintsDecodeErrorZ {
	CResult_PaymentConstraintsDecodeErrorZ {
		contents: CResult_PaymentConstraintsDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentConstraintsDecodeErrorZ in the error state.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_PaymentConstraintsDecodeErrorZ {
	CResult_PaymentConstraintsDecodeErrorZ {
		contents: CResult_PaymentConstraintsDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_is_ok(o: &CResult_PaymentConstraintsDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PaymentConstraintsDecodeErrorZ.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_free(_res: CResult_PaymentConstraintsDecodeErrorZ) { }
impl Drop for CResult_PaymentConstraintsDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentConstraints, crate::lightning::ln::msgs::DecodeError>> for CResult_PaymentConstraintsDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::payment::PaymentConstraints, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PaymentConstraintsDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_PaymentConstraintsDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_PaymentConstraintsDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_PaymentConstraintsDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::payment::PaymentConstraints>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_PaymentConstraintsDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_PaymentConstraintsDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_PaymentConstraintsDecodeErrorZ_clone(orig: &CResult_PaymentConstraintsDecodeErrorZ) -> CResult_PaymentConstraintsDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	/// The element at position 0
	pub a: crate::c_types::ThirtyTwoBytes,
	/// The element at position 1
	pub b: crate::lightning::ln::outbound_payment::RecipientOnionFields,
	/// The element at position 2
	pub c: crate::lightning::routing::router::RouteParameters,
}
impl From<(crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::routing::router::RouteParameters)> for C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	fn from (tup: (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::routing::router::RouteParameters)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::ThirtyTwoBytes, crate::lightning::ln::outbound_payment::RecipientOnionFields, crate::lightning::routing::router::RouteParameters) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ_clone(orig: &C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ) -> C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ_new(a: crate::c_types::ThirtyTwoBytes, b: crate::lightning::ln::outbound_payment::RecipientOnionFields, c: crate::lightning::routing::router::RouteParameters) -> C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ {
	C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ.
pub extern "C" fn C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ_free(_res: C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ) { }
#[repr(C)]
/// The contents of CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ
pub union CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	/// The contents of this CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr,
	/// Whether this CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ in the success state.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_ok(o: crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ) -> CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
		contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ in the error state.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_err() -> CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
		contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_is_ok(o: &CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_free(_res: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ) { }
impl Drop for CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ, ()>> for CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ_clone(orig: &CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ) -> CResult_C3Tuple_ThirtyTwoBytesRecipientOnionFieldsRouteParametersZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_StrSecp256k1ErrorZ
pub union CResult_StrSecp256k1ErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::Str,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::c_types::Secp256k1Error,
}
#[repr(C)]
/// A CResult_StrSecp256k1ErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::Str on success and a crate::c_types::Secp256k1Error on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_StrSecp256k1ErrorZ {
	/// The contents of this CResult_StrSecp256k1ErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_StrSecp256k1ErrorZPtr,
	/// Whether this CResult_StrSecp256k1ErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_StrSecp256k1ErrorZ in the success state.
pub extern "C" fn CResult_StrSecp256k1ErrorZ_ok(o: crate::c_types::Str) -> CResult_StrSecp256k1ErrorZ {
	CResult_StrSecp256k1ErrorZ {
		contents: CResult_StrSecp256k1ErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_StrSecp256k1ErrorZ in the error state.
pub extern "C" fn CResult_StrSecp256k1ErrorZ_err(e: crate::c_types::Secp256k1Error) -> CResult_StrSecp256k1ErrorZ {
	CResult_StrSecp256k1ErrorZ {
		contents: CResult_StrSecp256k1ErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_StrSecp256k1ErrorZ_is_ok(o: &CResult_StrSecp256k1ErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_StrSecp256k1ErrorZ.
pub extern "C" fn CResult_StrSecp256k1ErrorZ_free(_res: CResult_StrSecp256k1ErrorZ) { }
impl Drop for CResult_StrSecp256k1ErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::Str, crate::c_types::Secp256k1Error>> for CResult_StrSecp256k1ErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::Str, crate::c_types::Secp256k1Error>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_StrSecp256k1ErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_StrSecp256k1ErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_StrSecp256k1ErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_StrSecp256k1ErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::Str>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_StrSecp256k1ErrorZPtr {
				err: Box::into_raw(Box::new(<crate::c_types::Secp256k1Error>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_StrSecp256k1ErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_StrSecp256k1ErrorZ_clone(orig: &CResult_StrSecp256k1ErrorZ) -> CResult_StrSecp256k1ErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_TxOutUtxoLookupErrorZ
pub union CResult_TxOutUtxoLookupErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::TxOut,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::routing::utxo::UtxoLookupError,
}
#[repr(C)]
/// A CResult_TxOutUtxoLookupErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::TxOut on success and a crate::lightning::routing::utxo::UtxoLookupError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_TxOutUtxoLookupErrorZ {
	/// The contents of this CResult_TxOutUtxoLookupErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_TxOutUtxoLookupErrorZPtr,
	/// Whether this CResult_TxOutUtxoLookupErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_TxOutUtxoLookupErrorZ in the success state.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_ok(o: crate::c_types::TxOut) -> CResult_TxOutUtxoLookupErrorZ {
	CResult_TxOutUtxoLookupErrorZ {
		contents: CResult_TxOutUtxoLookupErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_TxOutUtxoLookupErrorZ in the error state.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_err(e: crate::lightning::routing::utxo::UtxoLookupError) -> CResult_TxOutUtxoLookupErrorZ {
	CResult_TxOutUtxoLookupErrorZ {
		contents: CResult_TxOutUtxoLookupErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_is_ok(o: &CResult_TxOutUtxoLookupErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_TxOutUtxoLookupErrorZ.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_free(_res: CResult_TxOutUtxoLookupErrorZ) { }
impl Drop for CResult_TxOutUtxoLookupErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::TxOut, crate::lightning::routing::utxo::UtxoLookupError>> for CResult_TxOutUtxoLookupErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::TxOut, crate::lightning::routing::utxo::UtxoLookupError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_TxOutUtxoLookupErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_TxOutUtxoLookupErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_TxOutUtxoLookupErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_TxOutUtxoLookupErrorZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::TxOut>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_TxOutUtxoLookupErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::routing::utxo::UtxoLookupError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_TxOutUtxoLookupErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_TxOutUtxoLookupErrorZ_clone(orig: &CResult_TxOutUtxoLookupErrorZ) -> CResult_TxOutUtxoLookupErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// A tuple of 3 elements. See the individual fields for the types contained.
pub struct C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	/// The element at position 0
	pub a: crate::c_types::PublicKey,
	/// The element at position 1
	pub b: crate::lightning::ln::msgs::OnionMessage,
	/// The element at position 2
	pub c: crate::c_types::derived::COption_CVec_SocketAddressZZ,
}
impl From<(crate::c_types::PublicKey, crate::lightning::ln::msgs::OnionMessage, crate::c_types::derived::COption_CVec_SocketAddressZZ)> for C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	fn from (tup: (crate::c_types::PublicKey, crate::lightning::ln::msgs::OnionMessage, crate::c_types::derived::COption_CVec_SocketAddressZZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
			c: tup.2,
		}
	}
}
impl C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::c_types::PublicKey, crate::lightning::ln::msgs::OnionMessage, crate::c_types::derived::COption_CVec_SocketAddressZZ) {
		(self.a, self.b, self.c)
	}
}
impl Clone for C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
			c: Clone::clone(&self.c),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ_clone(orig: &C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ) -> C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ { Clone::clone(&orig) }
/// Creates a new C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ_new(a: crate::c_types::PublicKey, b: crate::lightning::ln::msgs::OnionMessage, c: crate::c_types::derived::COption_CVec_SocketAddressZZ) -> C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ {
	C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ { a, b, c, }
}

#[no_mangle]
/// Frees any resources used by the C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ.
pub extern "C" fn C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ_free(_res: C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ) { }
#[repr(C)]
/// The contents of CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ
pub union CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::onion_message::messenger::SendError,
}
#[repr(C)]
/// A CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ on success and a crate::lightning::onion_message::messenger::SendError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	/// The contents of this CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr,
	/// Whether this CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ in the success state.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_ok(o: crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ) -> CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
		contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ in the error state.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_err(e: crate::lightning::onion_message::messenger::SendError) -> CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
		contents: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_is_ok(o: &CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ.
pub extern "C" fn CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ_free(_res: CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ) { }
impl Drop for CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ, crate::lightning::onion_message::messenger::SendError>> for CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZ, crate::lightning::onion_message::messenger::SendError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_C3Tuple_PublicKeyOnionMessageCOption_CVec_SocketAddressZZZSendErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_PeeledOnionNoneZ
pub union CResult_PeeledOnionNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::PeeledOnion,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_PeeledOnionNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::PeeledOnion on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_PeeledOnionNoneZ {
	/// The contents of this CResult_PeeledOnionNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_PeeledOnionNoneZPtr,
	/// Whether this CResult_PeeledOnionNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_PeeledOnionNoneZ in the success state.
pub extern "C" fn CResult_PeeledOnionNoneZ_ok(o: crate::lightning::onion_message::messenger::PeeledOnion) -> CResult_PeeledOnionNoneZ {
	CResult_PeeledOnionNoneZ {
		contents: CResult_PeeledOnionNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_PeeledOnionNoneZ in the error state.
pub extern "C" fn CResult_PeeledOnionNoneZ_err() -> CResult_PeeledOnionNoneZ {
	CResult_PeeledOnionNoneZ {
		contents: CResult_PeeledOnionNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_PeeledOnionNoneZ_is_ok(o: &CResult_PeeledOnionNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_PeeledOnionNoneZ.
pub extern "C" fn CResult_PeeledOnionNoneZ_free(_res: CResult_PeeledOnionNoneZ) { }
impl Drop for CResult_PeeledOnionNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::PeeledOnion, ()>> for CResult_PeeledOnionNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::PeeledOnion, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_PeeledOnionNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_PeeledOnionNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_SendSuccessSendErrorZ
pub union CResult_SendSuccessSendErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::onion_message::messenger::SendSuccess,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::onion_message::messenger::SendError,
}
#[repr(C)]
/// A CResult_SendSuccessSendErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::onion_message::messenger::SendSuccess on success and a crate::lightning::onion_message::messenger::SendError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_SendSuccessSendErrorZ {
	/// The contents of this CResult_SendSuccessSendErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_SendSuccessSendErrorZPtr,
	/// Whether this CResult_SendSuccessSendErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_SendSuccessSendErrorZ in the success state.
pub extern "C" fn CResult_SendSuccessSendErrorZ_ok(o: crate::lightning::onion_message::messenger::SendSuccess) -> CResult_SendSuccessSendErrorZ {
	CResult_SendSuccessSendErrorZ {
		contents: CResult_SendSuccessSendErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_SendSuccessSendErrorZ in the error state.
pub extern "C" fn CResult_SendSuccessSendErrorZ_err(e: crate::lightning::onion_message::messenger::SendError) -> CResult_SendSuccessSendErrorZ {
	CResult_SendSuccessSendErrorZ {
		contents: CResult_SendSuccessSendErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_SendSuccessSendErrorZ_is_ok(o: &CResult_SendSuccessSendErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_SendSuccessSendErrorZ.
pub extern "C" fn CResult_SendSuccessSendErrorZ_free(_res: CResult_SendSuccessSendErrorZ) { }
impl Drop for CResult_SendSuccessSendErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::SendSuccess, crate::lightning::onion_message::messenger::SendError>> for CResult_SendSuccessSendErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::onion_message::messenger::SendSuccess, crate::lightning::onion_message::messenger::SendError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_SendSuccessSendErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_SendSuccessSendErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// The contents of CResult_BlindedPathNoneZ
pub union CResult_BlindedPathNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::BlindedPath,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_BlindedPathNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::BlindedPath on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedPathNoneZ {
	/// The contents of this CResult_BlindedPathNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedPathNoneZPtr,
	/// Whether this CResult_BlindedPathNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedPathNoneZ in the success state.
pub extern "C" fn CResult_BlindedPathNoneZ_ok(o: crate::lightning::blinded_path::BlindedPath) -> CResult_BlindedPathNoneZ {
	CResult_BlindedPathNoneZ {
		contents: CResult_BlindedPathNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPathNoneZ in the error state.
pub extern "C" fn CResult_BlindedPathNoneZ_err() -> CResult_BlindedPathNoneZ {
	CResult_BlindedPathNoneZ {
		contents: CResult_BlindedPathNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedPathNoneZ_is_ok(o: &CResult_BlindedPathNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedPathNoneZ.
pub extern "C" fn CResult_BlindedPathNoneZ_free(_res: CResult_BlindedPathNoneZ) { }
impl Drop for CResult_BlindedPathNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedPath, ()>> for CResult_BlindedPathNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedPath, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedPathNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_BlindedPathNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedPathNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedPathNoneZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::BlindedPath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedPathNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPathNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedPathNoneZ_clone(orig: &CResult_BlindedPathNoneZ) -> CResult_BlindedPathNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ
pub union CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ represents the result of a fallible operation,
/// containing a crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
	/// The contents of this CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr,
	/// Whether this CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ in the success state.
pub extern "C" fn CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_ok(o: crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ) -> CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
	CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
		contents: CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ in the error state.
pub extern "C" fn CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_err() -> CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
	CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
		contents: CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_is_ok(o: &CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ.
pub extern "C" fn CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_free(_res: CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ) { }
impl Drop for CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ, ()>> for CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr {
				result: Box::into_raw(Box::new(<crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr {
				err: core::ptr::null_mut()
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_clone(orig: &CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ) -> CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ { Clone::clone(&orig) }
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::blinded_path::payment::ForwardNodes of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_ForwardNodeZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::blinded_path::payment::ForwardNode,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_ForwardNodeZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::blinded_path::payment::ForwardNode> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::blinded_path::payment::ForwardNode] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::blinded_path::payment::ForwardNode>> for CVec_ForwardNodeZ {
	fn from(v: Vec<crate::lightning::blinded_path::payment::ForwardNode>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_ForwardNodeZ_free(_res: CVec_ForwardNodeZ) { }
impl Drop for CVec_ForwardNodeZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_ForwardNodeZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// The contents of CResult_BlindedPathDecodeErrorZ
pub union CResult_BlindedPathDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::BlindedPath,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedPathDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::BlindedPath on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedPathDecodeErrorZ {
	/// The contents of this CResult_BlindedPathDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedPathDecodeErrorZPtr,
	/// Whether this CResult_BlindedPathDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedPathDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedPathDecodeErrorZ_ok(o: crate::lightning::blinded_path::BlindedPath) -> CResult_BlindedPathDecodeErrorZ {
	CResult_BlindedPathDecodeErrorZ {
		contents: CResult_BlindedPathDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPathDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedPathDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedPathDecodeErrorZ {
	CResult_BlindedPathDecodeErrorZ {
		contents: CResult_BlindedPathDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedPathDecodeErrorZ_is_ok(o: &CResult_BlindedPathDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedPathDecodeErrorZ.
pub extern "C" fn CResult_BlindedPathDecodeErrorZ_free(_res: CResult_BlindedPathDecodeErrorZ) { }
impl Drop for CResult_BlindedPathDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedPath, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedPathDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedPath, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedPathDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedPathDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedPathDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedPathDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::BlindedPath>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedPathDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedPathDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedPathDecodeErrorZ_clone(orig: &CResult_BlindedPathDecodeErrorZ) -> CResult_BlindedPathDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_BlindedHopDecodeErrorZ
pub union CResult_BlindedHopDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::blinded_path::BlindedHop,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_BlindedHopDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::blinded_path::BlindedHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_BlindedHopDecodeErrorZ {
	/// The contents of this CResult_BlindedHopDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_BlindedHopDecodeErrorZPtr,
	/// Whether this CResult_BlindedHopDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_BlindedHopDecodeErrorZ in the success state.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_ok(o: crate::lightning::blinded_path::BlindedHop) -> CResult_BlindedHopDecodeErrorZ {
	CResult_BlindedHopDecodeErrorZ {
		contents: CResult_BlindedHopDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopDecodeErrorZ in the error state.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_BlindedHopDecodeErrorZ {
	CResult_BlindedHopDecodeErrorZ {
		contents: CResult_BlindedHopDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_is_ok(o: &CResult_BlindedHopDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_BlindedHopDecodeErrorZ.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_free(_res: CResult_BlindedHopDecodeErrorZ) { }
impl Drop for CResult_BlindedHopDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedHop, crate::lightning::ln::msgs::DecodeError>> for CResult_BlindedHopDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::blinded_path::BlindedHop, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_BlindedHopDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_BlindedHopDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_BlindedHopDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_BlindedHopDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::blinded_path::BlindedHop>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_BlindedHopDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_BlindedHopDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_BlindedHopDecodeErrorZ_clone(orig: &CResult_BlindedHopDecodeErrorZ) -> CResult_BlindedHopDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_InvoiceErrorDecodeErrorZ
pub union CResult_InvoiceErrorDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::offers::invoice_error::InvoiceError,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_InvoiceErrorDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::offers::invoice_error::InvoiceError on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_InvoiceErrorDecodeErrorZ {
	/// The contents of this CResult_InvoiceErrorDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_InvoiceErrorDecodeErrorZPtr,
	/// Whether this CResult_InvoiceErrorDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_InvoiceErrorDecodeErrorZ in the success state.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_ok(o: crate::lightning::offers::invoice_error::InvoiceError) -> CResult_InvoiceErrorDecodeErrorZ {
	CResult_InvoiceErrorDecodeErrorZ {
		contents: CResult_InvoiceErrorDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceErrorDecodeErrorZ in the error state.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_InvoiceErrorDecodeErrorZ {
	CResult_InvoiceErrorDecodeErrorZ {
		contents: CResult_InvoiceErrorDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_is_ok(o: &CResult_InvoiceErrorDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_InvoiceErrorDecodeErrorZ.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_free(_res: CResult_InvoiceErrorDecodeErrorZ) { }
impl Drop for CResult_InvoiceErrorDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::offers::invoice_error::InvoiceError, crate::lightning::ln::msgs::DecodeError>> for CResult_InvoiceErrorDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::offers::invoice_error::InvoiceError, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_InvoiceErrorDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_InvoiceErrorDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_InvoiceErrorDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_InvoiceErrorDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::offers::invoice_error::InvoiceError>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_InvoiceErrorDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_InvoiceErrorDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_InvoiceErrorDecodeErrorZ_clone(orig: &CResult_InvoiceErrorDecodeErrorZ) -> CResult_InvoiceErrorDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DelayedPaymentBasepointDecodeErrorZ
pub union CResult_DelayedPaymentBasepointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::DelayedPaymentBasepoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DelayedPaymentBasepointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::DelayedPaymentBasepoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DelayedPaymentBasepointDecodeErrorZ {
	/// The contents of this CResult_DelayedPaymentBasepointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr,
	/// Whether this CResult_DelayedPaymentBasepointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentBasepointDecodeErrorZ in the success state.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::DelayedPaymentBasepoint) -> CResult_DelayedPaymentBasepointDecodeErrorZ {
	CResult_DelayedPaymentBasepointDecodeErrorZ {
		contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentBasepointDecodeErrorZ in the error state.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DelayedPaymentBasepointDecodeErrorZ {
	CResult_DelayedPaymentBasepointDecodeErrorZ {
		contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_is_ok(o: &CResult_DelayedPaymentBasepointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DelayedPaymentBasepointDecodeErrorZ.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_free(_res: CResult_DelayedPaymentBasepointDecodeErrorZ) { }
impl Drop for CResult_DelayedPaymentBasepointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentBasepoint, crate::lightning::ln::msgs::DecodeError>> for CResult_DelayedPaymentBasepointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentBasepoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DelayedPaymentBasepointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DelayedPaymentBasepointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DelayedPaymentBasepointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::DelayedPaymentBasepoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DelayedPaymentBasepointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentBasepointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DelayedPaymentBasepointDecodeErrorZ_clone(orig: &CResult_DelayedPaymentBasepointDecodeErrorZ) -> CResult_DelayedPaymentBasepointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_DelayedPaymentKeyDecodeErrorZ
pub union CResult_DelayedPaymentKeyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::DelayedPaymentKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_DelayedPaymentKeyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::DelayedPaymentKey on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_DelayedPaymentKeyDecodeErrorZ {
	/// The contents of this CResult_DelayedPaymentKeyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_DelayedPaymentKeyDecodeErrorZPtr,
	/// Whether this CResult_DelayedPaymentKeyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentKeyDecodeErrorZ in the success state.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::DelayedPaymentKey) -> CResult_DelayedPaymentKeyDecodeErrorZ {
	CResult_DelayedPaymentKeyDecodeErrorZ {
		contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentKeyDecodeErrorZ in the error state.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_DelayedPaymentKeyDecodeErrorZ {
	CResult_DelayedPaymentKeyDecodeErrorZ {
		contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_is_ok(o: &CResult_DelayedPaymentKeyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_DelayedPaymentKeyDecodeErrorZ.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_free(_res: CResult_DelayedPaymentKeyDecodeErrorZ) { }
impl Drop for CResult_DelayedPaymentKeyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentKey, crate::lightning::ln::msgs::DecodeError>> for CResult_DelayedPaymentKeyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::DelayedPaymentKey, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_DelayedPaymentKeyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_DelayedPaymentKeyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_DelayedPaymentKeyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::DelayedPaymentKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_DelayedPaymentKeyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_DelayedPaymentKeyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_DelayedPaymentKeyDecodeErrorZ_clone(orig: &CResult_DelayedPaymentKeyDecodeErrorZ) -> CResult_DelayedPaymentKeyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HtlcBasepointDecodeErrorZ
pub union CResult_HtlcBasepointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::HtlcBasepoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HtlcBasepointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::HtlcBasepoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HtlcBasepointDecodeErrorZ {
	/// The contents of this CResult_HtlcBasepointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HtlcBasepointDecodeErrorZPtr,
	/// Whether this CResult_HtlcBasepointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HtlcBasepointDecodeErrorZ in the success state.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::HtlcBasepoint) -> CResult_HtlcBasepointDecodeErrorZ {
	CResult_HtlcBasepointDecodeErrorZ {
		contents: CResult_HtlcBasepointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcBasepointDecodeErrorZ in the error state.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HtlcBasepointDecodeErrorZ {
	CResult_HtlcBasepointDecodeErrorZ {
		contents: CResult_HtlcBasepointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_is_ok(o: &CResult_HtlcBasepointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HtlcBasepointDecodeErrorZ.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_free(_res: CResult_HtlcBasepointDecodeErrorZ) { }
impl Drop for CResult_HtlcBasepointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcBasepoint, crate::lightning::ln::msgs::DecodeError>> for CResult_HtlcBasepointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcBasepoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HtlcBasepointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HtlcBasepointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HtlcBasepointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HtlcBasepointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::HtlcBasepoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HtlcBasepointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcBasepointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HtlcBasepointDecodeErrorZ_clone(orig: &CResult_HtlcBasepointDecodeErrorZ) -> CResult_HtlcBasepointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_HtlcKeyDecodeErrorZ
pub union CResult_HtlcKeyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::HtlcKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_HtlcKeyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::HtlcKey on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_HtlcKeyDecodeErrorZ {
	/// The contents of this CResult_HtlcKeyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_HtlcKeyDecodeErrorZPtr,
	/// Whether this CResult_HtlcKeyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_HtlcKeyDecodeErrorZ in the success state.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::HtlcKey) -> CResult_HtlcKeyDecodeErrorZ {
	CResult_HtlcKeyDecodeErrorZ {
		contents: CResult_HtlcKeyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcKeyDecodeErrorZ in the error state.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_HtlcKeyDecodeErrorZ {
	CResult_HtlcKeyDecodeErrorZ {
		contents: CResult_HtlcKeyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_is_ok(o: &CResult_HtlcKeyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_HtlcKeyDecodeErrorZ.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_free(_res: CResult_HtlcKeyDecodeErrorZ) { }
impl Drop for CResult_HtlcKeyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcKey, crate::lightning::ln::msgs::DecodeError>> for CResult_HtlcKeyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::HtlcKey, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_HtlcKeyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_HtlcKeyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_HtlcKeyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_HtlcKeyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::HtlcKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_HtlcKeyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_HtlcKeyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_HtlcKeyDecodeErrorZ_clone(orig: &CResult_HtlcKeyDecodeErrorZ) -> CResult_HtlcKeyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RevocationBasepointDecodeErrorZ
pub union CResult_RevocationBasepointDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::RevocationBasepoint,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RevocationBasepointDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::RevocationBasepoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RevocationBasepointDecodeErrorZ {
	/// The contents of this CResult_RevocationBasepointDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RevocationBasepointDecodeErrorZPtr,
	/// Whether this CResult_RevocationBasepointDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RevocationBasepointDecodeErrorZ in the success state.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::RevocationBasepoint) -> CResult_RevocationBasepointDecodeErrorZ {
	CResult_RevocationBasepointDecodeErrorZ {
		contents: CResult_RevocationBasepointDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationBasepointDecodeErrorZ in the error state.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RevocationBasepointDecodeErrorZ {
	CResult_RevocationBasepointDecodeErrorZ {
		contents: CResult_RevocationBasepointDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_is_ok(o: &CResult_RevocationBasepointDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RevocationBasepointDecodeErrorZ.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_free(_res: CResult_RevocationBasepointDecodeErrorZ) { }
impl Drop for CResult_RevocationBasepointDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationBasepoint, crate::lightning::ln::msgs::DecodeError>> for CResult_RevocationBasepointDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationBasepoint, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RevocationBasepointDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RevocationBasepointDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RevocationBasepointDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RevocationBasepointDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::RevocationBasepoint>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RevocationBasepointDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationBasepointDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RevocationBasepointDecodeErrorZ_clone(orig: &CResult_RevocationBasepointDecodeErrorZ) -> CResult_RevocationBasepointDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// The contents of CResult_RevocationKeyDecodeErrorZ
pub union CResult_RevocationKeyDecodeErrorZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::ln::channel_keys::RevocationKey,
	/// A pointer to the contents in the error state.
	/// Reading from this pointer when `result_ok` is set is undefined.
	pub err: *mut crate::lightning::ln::msgs::DecodeError,
}
#[repr(C)]
/// A CResult_RevocationKeyDecodeErrorZ represents the result of a fallible operation,
/// containing a crate::lightning::ln::channel_keys::RevocationKey on success and a crate::lightning::ln::msgs::DecodeError on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_RevocationKeyDecodeErrorZ {
	/// The contents of this CResult_RevocationKeyDecodeErrorZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_RevocationKeyDecodeErrorZPtr,
	/// Whether this CResult_RevocationKeyDecodeErrorZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_RevocationKeyDecodeErrorZ in the success state.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_ok(o: crate::lightning::ln::channel_keys::RevocationKey) -> CResult_RevocationKeyDecodeErrorZ {
	CResult_RevocationKeyDecodeErrorZ {
		contents: CResult_RevocationKeyDecodeErrorZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationKeyDecodeErrorZ in the error state.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_err(e: crate::lightning::ln::msgs::DecodeError) -> CResult_RevocationKeyDecodeErrorZ {
	CResult_RevocationKeyDecodeErrorZ {
		contents: CResult_RevocationKeyDecodeErrorZPtr {
			err: Box::into_raw(Box::new(e)),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_is_ok(o: &CResult_RevocationKeyDecodeErrorZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_RevocationKeyDecodeErrorZ.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_free(_res: CResult_RevocationKeyDecodeErrorZ) { }
impl Drop for CResult_RevocationKeyDecodeErrorZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
			if unsafe { !(self.contents.err as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.err) };
			}
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationKey, crate::lightning::ln::msgs::DecodeError>> for CResult_RevocationKeyDecodeErrorZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::ln::channel_keys::RevocationKey, crate::lightning::ln::msgs::DecodeError>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_RevocationKeyDecodeErrorZPtr { result }
		} else {
			let err = unsafe { o.contents.err };
			unsafe { o.contents.err = core::ptr::null_mut(); }
			CResult_RevocationKeyDecodeErrorZPtr { err }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
impl Clone for CResult_RevocationKeyDecodeErrorZ {
	fn clone(&self) -> Self {
		if self.result_ok {
			Self { result_ok: true, contents: CResult_RevocationKeyDecodeErrorZPtr {
				result: Box::into_raw(Box::new(<crate::lightning::ln::channel_keys::RevocationKey>::clone(unsafe { &*self.contents.result })))
			} }
		} else {
			Self { result_ok: false, contents: CResult_RevocationKeyDecodeErrorZPtr {
				err: Box::into_raw(Box::new(<crate::lightning::ln::msgs::DecodeError>::clone(unsafe { &*self.contents.err })))
			} }
		}
	}
}
#[no_mangle]
/// Creates a new CResult_RevocationKeyDecodeErrorZ which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn CResult_RevocationKeyDecodeErrorZ_clone(orig: &CResult_RevocationKeyDecodeErrorZ) -> CResult_RevocationKeyDecodeErrorZ { Clone::clone(&orig) }
#[repr(C)]
/// An enum which can either contain a crate::lightning::chain::Filter or not
pub enum COption_FilterZ {
	/// When we're in this state, this COption_FilterZ contains a crate::lightning::chain::Filter
	Some(crate::lightning::chain::Filter),
	/// When we're in this state, this COption_FilterZ contains nothing
	None
}
impl COption_FilterZ {
	#[allow(unused)] pub(crate) fn is_some(&self) -> bool {
		if let Self::None = self { false } else { true }
	}
	#[allow(unused)] pub(crate) fn is_none(&self) -> bool {
		!self.is_some()
	}
	#[allow(unused)] pub(crate) fn take(mut self) -> crate::lightning::chain::Filter {
		if let Self::Some(v) = self { v } else { unreachable!() }
	}
}
#[no_mangle]
/// Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
pub extern "C" fn COption_FilterZ_some(o: crate::lightning::chain::Filter) -> COption_FilterZ {
	COption_FilterZ::Some(o)
}
#[no_mangle]
/// Constructs a new COption_FilterZ containing nothing
pub extern "C" fn COption_FilterZ_none() -> COption_FilterZ {
	COption_FilterZ::None
}
#[no_mangle]
/// Frees any resources associated with the crate::lightning::chain::Filter, if we are in the Some state
pub extern "C" fn COption_FilterZ_free(_res: COption_FilterZ) { }
#[repr(C)]
/// The contents of CResult_LockedChannelMonitorNoneZ
pub union CResult_LockedChannelMonitorNoneZPtr {
	/// A pointer to the contents in the success state.
	/// Reading from this pointer when `result_ok` is not set is undefined.
	pub result: *mut crate::lightning::chain::chainmonitor::LockedChannelMonitor,
	/// Note that this value is always NULL, as there are no contents in the Err variant
	pub err: *mut core::ffi::c_void,
}
#[repr(C)]
/// A CResult_LockedChannelMonitorNoneZ represents the result of a fallible operation,
/// containing a crate::lightning::chain::chainmonitor::LockedChannelMonitor on success and a () on failure.
/// `result_ok` indicates the overall state, and the contents are provided via `contents`.
pub struct CResult_LockedChannelMonitorNoneZ {
	/// The contents of this CResult_LockedChannelMonitorNoneZ, accessible via either
	/// `err` or `result` depending on the state of `result_ok`.
	pub contents: CResult_LockedChannelMonitorNoneZPtr,
	/// Whether this CResult_LockedChannelMonitorNoneZ represents a success state.
	pub result_ok: bool,
}
#[no_mangle]
/// Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_ok(o: crate::lightning::chain::chainmonitor::LockedChannelMonitor) -> CResult_LockedChannelMonitorNoneZ {
	CResult_LockedChannelMonitorNoneZ {
		contents: CResult_LockedChannelMonitorNoneZPtr {
			result: Box::into_raw(Box::new(o)),
		},
		result_ok: true,
	}
}
#[no_mangle]
/// Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_err() -> CResult_LockedChannelMonitorNoneZ {
	CResult_LockedChannelMonitorNoneZ {
		contents: CResult_LockedChannelMonitorNoneZPtr {
			err: core::ptr::null_mut(),
		},
		result_ok: false,
	}
}
/// Checks if the given object is currently in the success state
#[no_mangle]
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_is_ok(o: &CResult_LockedChannelMonitorNoneZ) -> bool {
	o.result_ok
}
#[no_mangle]
/// Frees any resources used by the CResult_LockedChannelMonitorNoneZ.
pub extern "C" fn CResult_LockedChannelMonitorNoneZ_free(_res: CResult_LockedChannelMonitorNoneZ) { }
impl Drop for CResult_LockedChannelMonitorNoneZ {
	fn drop(&mut self) {
		if self.result_ok {
			if unsafe { !(self.contents.result as *mut ()).is_null() } {
				let _ = unsafe { Box::from_raw(self.contents.result) };
			}
		} else {
		}
	}
}
impl From<crate::c_types::CResultTempl<crate::lightning::chain::chainmonitor::LockedChannelMonitor, ()>> for CResult_LockedChannelMonitorNoneZ {
	fn from(mut o: crate::c_types::CResultTempl<crate::lightning::chain::chainmonitor::LockedChannelMonitor, ()>) -> Self {
		let contents = if o.result_ok {
			let result = unsafe { o.contents.result };
			unsafe { o.contents.result = core::ptr::null_mut() };
			CResult_LockedChannelMonitorNoneZPtr { result }
		} else {
			let _ = unsafe { Box::from_raw(o.contents.err) };
			o.contents.err = core::ptr::null_mut();
			CResult_LockedChannelMonitorNoneZPtr { err: core::ptr::null_mut() }
		};
		Self {
			contents,
			result_ok: o.result_ok,
		}
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::transaction::OutPoints of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_OutPointZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::transaction::OutPoint,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_OutPointZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::transaction::OutPoint> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::transaction::OutPoint] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::transaction::OutPoint>> for CVec_OutPointZ {
	fn from(v: Vec<crate::lightning::chain::transaction::OutPoint>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_OutPointZ_free(_res: CVec_OutPointZ) { }
impl Drop for CVec_OutPointZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_OutPointZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A dynamically-allocated array of crate::lightning::chain::chainmonitor::MonitorUpdateIds of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_MonitorUpdateIdZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::lightning::chain::chainmonitor::MonitorUpdateId,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_MonitorUpdateIdZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::lightning::chain::chainmonitor::MonitorUpdateId> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::lightning::chain::chainmonitor::MonitorUpdateId] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::lightning::chain::chainmonitor::MonitorUpdateId>> for CVec_MonitorUpdateIdZ {
	fn from(v: Vec<crate::lightning::chain::chainmonitor::MonitorUpdateId>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_MonitorUpdateIdZ_free(_res: CVec_MonitorUpdateIdZ) { }
impl Drop for CVec_MonitorUpdateIdZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_MonitorUpdateIdZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
#[repr(C)]
/// A tuple of 2 elements. See the individual fields for the types contained.
pub struct C2Tuple_OutPointCVec_MonitorUpdateIdZZ {
	/// The element at position 0
	pub a: crate::lightning::chain::transaction::OutPoint,
	/// The element at position 1
	pub b: crate::c_types::derived::CVec_MonitorUpdateIdZ,
}
impl From<(crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_MonitorUpdateIdZ)> for C2Tuple_OutPointCVec_MonitorUpdateIdZZ {
	fn from (tup: (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_MonitorUpdateIdZ)) -> Self {
		Self {
			a: tup.0,
			b: tup.1,
		}
	}
}
impl C2Tuple_OutPointCVec_MonitorUpdateIdZZ {
	#[allow(unused)] pub(crate) fn to_rust(mut self) -> (crate::lightning::chain::transaction::OutPoint, crate::c_types::derived::CVec_MonitorUpdateIdZ) {
		(self.a, self.b)
	}
}
impl Clone for C2Tuple_OutPointCVec_MonitorUpdateIdZZ {
	fn clone(&self) -> Self {
		Self {
			a: Clone::clone(&self.a),
			b: Clone::clone(&self.b),
		}
	}
}
#[no_mangle]
/// Creates a new tuple which has the same data as `orig`
/// but with all dynamically-allocated buffers duplicated in new buffers.
pub extern "C" fn C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone(orig: &C2Tuple_OutPointCVec_MonitorUpdateIdZZ) -> C2Tuple_OutPointCVec_MonitorUpdateIdZZ { Clone::clone(&orig) }
/// Creates a new C2Tuple_OutPointCVec_MonitorUpdateIdZZ from the contained elements.
#[no_mangle]
pub extern "C" fn C2Tuple_OutPointCVec_MonitorUpdateIdZZ_new(a: crate::lightning::chain::transaction::OutPoint, b: crate::c_types::derived::CVec_MonitorUpdateIdZ) -> C2Tuple_OutPointCVec_MonitorUpdateIdZZ {
	C2Tuple_OutPointCVec_MonitorUpdateIdZZ { a, b, }
}

#[no_mangle]
/// Frees any resources used by the C2Tuple_OutPointCVec_MonitorUpdateIdZZ.
pub extern "C" fn C2Tuple_OutPointCVec_MonitorUpdateIdZZ_free(_res: C2Tuple_OutPointCVec_MonitorUpdateIdZZ) { }
#[repr(C)]
/// A dynamically-allocated array of crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZs of arbitrary size.
/// This corresponds to std::vector in C++
pub struct CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
	/// The elements in the array.
	/// If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
	pub data: *mut crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZ,
	/// The number of elements pointed to by `data`.
	pub datalen: usize
}
impl CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
	#[allow(unused)] pub(crate) fn into_rust(&mut self) -> Vec<crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZ> {
		if self.datalen == 0 { return Vec::new(); }
		let ret = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) }.into();
		self.data = core::ptr::null_mut();
		self.datalen = 0;
		ret
	}
	#[allow(unused)] pub(crate) fn as_slice(&self) -> &[crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZ] {
		unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) }
	}
}
impl From<Vec<crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZ>> for CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
	fn from(v: Vec<crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZ>) -> Self {
		let datalen = v.len();
		let data = Box::into_raw(v.into_boxed_slice());
		Self { datalen, data: unsafe { (*data).as_mut_ptr() } }
	}
}
#[no_mangle]
/// Frees the buffer pointed to by `data` if `datalen` is non-0.
pub extern "C" fn CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ_free(_res: CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ) { }
impl Drop for CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
	fn drop(&mut self) {
		if self.datalen == 0 { return; }
		let _ = unsafe { Box::from_raw(core::slice::from_raw_parts_mut(self.data, self.datalen)) };
	}
}
impl Clone for CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
	fn clone(&self) -> Self {
		let mut res = Vec::new();
		if self.datalen == 0 { return Self::from(res); }
		res.extend_from_slice(unsafe { core::slice::from_raw_parts_mut(self.data, self.datalen) });
		Self::from(res)
	}
}
